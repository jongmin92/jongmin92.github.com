<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="XPweYu29qWs-CX2Byp48Y71yuYCDvBDkR8_PrVUy9UA" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/images/etc/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          멀티플렉싱 기반의 다중 접속 서버로 가기까지 - 92Hz | Jongmin&#39;s Blog
        
    </title>

    <link rel="canonical" href="https://jongmin92.github.io/2019/02/28/Java/java-with-non-blocking-io/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            /* 기본 포스트 헤더 이미지 (페이지 이미지 || 기본 헤더 이미지) */
            /* background-image: url('undefined') */
            /* background-image: url('/images/etc/home.jpg') */
            background-image: url('/images/etc/home.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#select" title="select">select</a>
                            
                              <a class="tag" href="/tags/#multiplexing" title="multiplexing">multiplexing</a>
                            
                              <a class="tag" href="/tags/#socket" title="socket">socket</a>
                            
                              <a class="tag" href="/tags/#nonblocking" title="nonblocking">nonblocking</a>
                            
                              <a class="tag" href="/tags/#poll" title="poll">poll</a>
                            
                              <a class="tag" href="/tags/#epoll" title="epoll">epoll</a>
                            
                        </div>
                        <h1>멀티플렉싱 기반의 다중 접속 서버로 가기까지</h1>
                        <h2 class="subheading">멀티프로세스 -&gt; 멀티스레드 -&gt; 멀티플렉싱</h2>
                        <span class="meta">
                            Posted by KimJongMin on
                            2019-02-28
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">92Hz</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <center>
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <ins class="adsbygoogle"
         style="display:block; text-align:center;"
         data-ad-layout="in-article"
         data-ad-format="fluid"
         data-ad-client="ca-pub-3921438651818825"
         data-ad-slot="3015269677"></ins>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</center>

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="소켓이란"><a href="#소켓이란" class="headerlink" title="소켓이란?"></a>소켓이란?</h1><p><code>소켓</code>은 네트워크 상에서 서버와 클라이언트 두개의 프로그램이 특정 포트를 통해 양방향 통신이 가능하도록 만들어주는 추상화된 장치입니다. <strong>메모리의 유저 공간에 존재하는 프로세스(서버, 클라이언트)는 커널 공간에 생성된 소켓을 통해 데이터를 송수신할 수 있습니다.</strong><br><img src="/images/post/2019-02-21/socket_1.png" alt="socket"></p>
<p>소켓은 아래와 같이 지역(로컬) IP 주소, Port 번호와 상대방의 IP 주소와 Port 번호, 그리고 <code>수신 버퍼</code>와 <code>송신 버퍼</code>가 존재합니다. <strong>서버와 클라이언트의 소켓이 서로 연결된 후, 데이터가 들어오면 수신 버퍼로 수신 데이터가 쓰이고, 반대로 데이터를 내 보낼 때는 송신 버퍼에 데이터가 쓰입니다.</strong><br><img src="/images/post/2019-02-21/socket_2.png" alt="socket"></p>
<h1 id="c언어로-간단한-서버-amp-클라이언트-구현"><a href="#C언어로-간단한-서버-amp-클라이언트-구현" class="headerlink" title="C언어로 간단한 서버 &amp; 클라이언트 구현"></a>C언어로 간단한 서버 &amp; 클라이언트 구현</h1><p>C언어를 이용해 linux와 window에서 간단하게 소켓을 이용해 echo server와 client를 만들어 보겠습니다.<br><strong>코드 한줄 한줄을 전부 해석하기 보다는 주석을 참고해 server와 client에서 어떤 순서로 소켓이 만들어지고 통신이 이루어지는지에 중점을 두어 보겠습니다.</strong></p>
<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p><a href="https://en.wikipedia.org/wiki/Everything_is_a_file" target="_blank" rel="noopener">“Everything is a File”</a>라는 말이 있습니다. linux에서는 소켓도 하나의 파일(File), 더 정확히는 <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank" rel="noopener">파일 디스크립터(File descriptor)</a>로 생성되어 관리됩니다. 그러므로 저 수준 파일 입출력 함수를 기반으로 소켓 기반의 데이터 송수신이 가능합니다.</p>
<blockquote>
<p><code>파일 디스크립터(File descriptor)</code></p>
<ul>
<li>운영체제가 만든 파일을 구분하기 위한 일종의 숫자</li>
<li>저 수준 파일 입출력 함수는 입출력을 목적으로 파일 디스크립터를 요구한다.</li>
<li>저 수준 파일 입출력 함수에 소켓의 파일 디스크립터를 전달하면, 소켓을 대상으로 입출력을 진행한다.</li>
</ul>
</blockquote>
<h3 id="echo_serverc"><a href="#echo-server-c" class="headerlink" title="echo_server.c"></a>echo_server.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 파일 디스크립터를 위한 변수</span></span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> str_len, i;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_adr_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. socket 하나를 생성한다.</span></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. socket에 IP와 Port 번호를 할당한다.</span></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr*)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. server socket(listen socket)을 통해 클라이언트의 접속 요청을 대기한다.</span></span><br><span class="line">    <span class="comment">//    5개의 수신 대기열(큐)을 생성한다.</span></span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"listen() error"</span>);</span><br><span class="line"></span><br><span class="line">    clnt_adr_sz=<span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 4. 클라이언트 접속 요청을 수락한다. (클라이언트와 연결된 새로운 socket이 생성된다.)</span></span><br><span class="line">        clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>)</span><br><span class="line">            error_handling(<span class="string">"accept() error"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Connected client %d \n"</span>, i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 클라이언트와 연결된 socket을 통해 데이터를 송수신한다.</span></span><br><span class="line">        <span class="keyword">while</span>((str_len=read(clnt_sock, message, BUF_SIZE)) != <span class="number">0</span>)</span><br><span class="line">            write(clnt_sock, message, str_len);</span><br><span class="line"></span><br><span class="line">        close(clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="echo_clientc"><a href="#echo-client-c" class="headerlink" title="echo_client.c"></a>echo_client.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 파일 디스크립터를 위한 변수</span></span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;IP&gt; &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. socket 하나를 생성한다.</span></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. socket을 이용해 server의 server socket(listen socket)에 연결을 요청한다.</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (struct sockaddr*)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"connect() error!"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Connected..........."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"Input message(Q to quit): "</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        fgets(message, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message,<span class="string">"q\n"</span>) || !<span class="built_in">strcmp</span>(message,<span class="string">"Q\n"</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 연결된 socket을 통해 server로부터 데이터를 송수신한다.</span></span><br><span class="line">        write(sock, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">        str_len = read(sock, message, BUF_SIZE<span class="number">-1</span>);</span><br><span class="line">        message[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Message from server: %s"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="결과-확인"><a href="#결과-확인" class="headerlink" title="결과 확인"></a>결과 확인</h3><p>gcc로 컴파일 후 실행하면 결과는 다음과 같습니다.<br><img src="/images/post/2019-02-21/echo_result.gif" alt="linux_simple_socket_result"></p>
<h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><p>window는 linux와 달리 파일이 아닌 별도의 소켓 구조체가 존재합니다. 별도의 소켓 구조체를 이용한 함수를 기반으로 소켓 기반의 데이터 송수신이 가능합니다.<br>window 코드의 결과는 위의 linux 코드의 결과와 같으므로 생략합니다.</p>
<h3 id="echo_server_winc"><a href="#echo-server-win-c" class="headerlink" title="echo_server_win.c"></a>echo_server_win.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// window socket</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    SOCKET hServSock, hClntSock;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> strLen, i;</span><br><span class="line"></span><br><span class="line">    SOCKADDR_IN servAdr, clntAdr;</span><br><span class="line">    <span class="keyword">int</span> clntAdrSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">        ErrorHandling(<span class="string">"WSAStartup() error!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. socket 하나를 생성한다.</span></span><br><span class="line">    hServSock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hServSock == INVALID_SOCKET)</span><br><span class="line">        ErrorHandling(<span class="string">"socket() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAdr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servAdr));</span><br><span class="line">    servAdr.sin_family = AF_INET;</span><br><span class="line">    servAdr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servAdr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 생성한 socket을 server socket(listen socket)으로 등록한다.</span></span><br><span class="line">    <span class="keyword">if</span> (bind(hServSock, (SOCKADDR*)&amp;servAdr, <span class="keyword">sizeof</span>(servAdr)) == SOCKET_ERROR)</span><br><span class="line">        ErrorHandling(<span class="string">"bind() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. server socket을 통해 클라이언트의 접속 요청을 확인한다.</span></span><br><span class="line">    <span class="keyword">if</span> (listen(hServSock, <span class="number">5</span>) == SOCKET_ERROR)</span><br><span class="line">        ErrorHandling(<span class="string">"listen() error"</span>);</span><br><span class="line"></span><br><span class="line">    clntAdrSize=<span class="keyword">sizeof</span>(clntAdr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 4. 클라이언트 접속 요청 대기 및 허락 (클라이언트와 연결된 새로운 socket이 생성된다.)</span></span><br><span class="line">        hClntSock = accept(hServSock, (SOCKADDR*)&amp;clntAdr, &amp;clntAdrSize);</span><br><span class="line">        <span class="keyword">if</span> (hClntSock == <span class="number">-1</span>)</span><br><span class="line">            ErrorHandling(<span class="string">"accept() error"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Connected client %d \n"</span>, i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 클라이언트와 연결된 socket을 통해 데이터를 송수신한다.</span></span><br><span class="line">        <span class="keyword">while</span>((strLen=recv(hClntSock, message, BUF_SIZE, <span class="number">0</span>)) != <span class="number">0</span>)</span><br><span class="line">            send(hClntSock, message, strLen, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        closesocket(hClntSock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closesocket(hServSock);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="echo_client_winc"><a href="#echo-client-win-c" class="headerlink" title="echo_client_win.c"></a>echo_client_win.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// window socket</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    SOCKET hSocket;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> strLen;</span><br><span class="line">    SOCKADDR_IN servAdr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;IP&gt; &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">        ErrorHandling(<span class="string">"WSAStartup() error!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. socket 하나를 생성한다.</span></span><br><span class="line">    hSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hSocket == INVALID_SOCKET)</span><br><span class="line">        ErrorHandling(<span class="string">"socket() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAdr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servAdr));</span><br><span class="line">    servAdr.sin_family = AF_INET;</span><br><span class="line">    servAdr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    servAdr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. socket을 이용해 server의 server socket(listen socket)에 연결을 요청한다.</span></span><br><span class="line">    <span class="keyword">if</span> (connect(hSocket, (SOCKADDR*)&amp;servAdr, <span class="keyword">sizeof</span>(servAdr)) == SOCKET_ERROR)</span><br><span class="line">        ErrorHandling(<span class="string">"connect() error!"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Connected..........."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"Input message(Q to quit): "</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        fgets(message, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message,<span class="string">"q\n"</span>) || !<span class="built_in">strcmp</span>(message,<span class="string">"Q\n"</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 연결된 socket을 통해 server로부터 데이터를 송수신한다.</span></span><br><span class="line">        send(hSocket, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>);</span><br><span class="line">        strLen = recv(hSocket, message, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        message[strLen] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Message from server: %s"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closesocket(hSocket);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="고찰"><a href="#고찰" class="headerlink" title="고찰"></a>고찰</h2><p>linux와 window의 서버 &amp; 클라이언트 소켓 생성과 연결 과정은 다음과 같습니다.<br><img src="/images/post/2019-02-21/server_client_socket.png" alt="server_client_socket"></p>
<ul>
<li>서버<ul>
<li>클라이언트로부터의 연결요청도 일종의 데이터 전송입니다. 따라서 연결 요청을 받아들이기 위해서도 하나의 소켓이 필요하고, 이 소켓을 가리켜 <code>서버소켓</code> 또는 <code>리스닝 소켓</code>이라고 합니다. listen 함수의 호출은 소켓을 리스닝 소켓으로 만듭니다.</li>
<li>accept 함수의 결과로 서버소켓을 통해 클라이언트로부터의 연결요청을 받으면, 연결요청 정보를 참조하여 <strong>클라이언트 소켓과의 통신을 위한 별도의 소켓을 추가로 하나 더 생성합니다. 그리고 이렇게 생성된 소켓을 대상으로 데이터의 송수신이 진행됩니다.</strong></li>
</ul>
</li>
<li>클라이언트<ul>
<li>소켓을 생성하고 연결 요청을 위해서 connect 함수를 호출하는 것이 전부입니다.</li>
<li>서버의 listen 함수호출 이후에야(서버소켓이 준비된 이후) connect 함수 호출이 유효합니다.</li>
</ul>
</li>
</ul>
<h3 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h3><p><img src="/images/post/2019-02-21/echo_result_problem.gif" alt="linux_simple_socket_result"><br>위 예제의 경우 반복적(Iterable)으로 accept 함수를 호출하면, 계속해서 클라이언트의 연결요청을 수락할 수 있습니다. 그러나, 동시에 둘 이상의 클라이언트에게 서비스를 제공할 수 있는 상태는 아닙니다. (처음 소켓 연결을 맺은 클라이언트가 종료하기 전까지는 다른 클라이언트의 연결은 listen 큐에 들어가 대기해야합니다.)</p>
<p><strong>이 문제를 해결하기 위해 둘 이상의 클라이언트들이 동시에 접속해 서버로부터 서비스를 제공받을 수 있는 여러 <code>다중 접속 서버</code>의 구현 방법들에 대해 알아보겠습니다.</strong></p>
<blockquote>
<p>다중 접속 서버 구현 방법</p>
<ul>
<li><strong>멀티프로세스 기반 서버</strong> : 다수의 프로세스를 생성하는 방식으로 서비스를 제공한다.</li>
<li><strong>멀티스레드 기반 서버</strong> : 클라이언트의 수만큼 스레드를 생성하는 방식으로 서비스를 제공한다.</li>
<li><strong>멀티플렉싱 기반 서버</strong> : 입출력 대상을 묶어서 관리하는 방식으로 서비스를 제공한다.</li>
</ul>
</blockquote>
<h1 id="멀티프로세스-기반의-다중-접속-서버"><a href="#멀티프로세스-기반의-다중-접속-서버" class="headerlink" title="멀티프로세스 기반의 다중 접속 서버"></a>멀티프로세스 기반의 다중 접속 서버</h1><p><strong><code>멀티프로세스 기반의 다중 접속 서버</code>는 다수의 프로세스를 생성하는 방식으로 서비스를 제공합니다.</strong><br><img src="/images/post/2019-02-21/multi_process_server.png" alt="multi_process_server"></p>
<ol>
<li>부모 프로세스는 <code>리스닝 소켓</code>으로 accept 함수 호출을 통해서 연결요청을 수락합니다. </li>
<li>이때 얻게 되는 소켓의 파일 디스크립터(<code>클라이언트와 연결된 연결 소켓</code>)를 자식 프로세스를 생성해 넘겨줍니다.</li>
<li>자식 프로세스는 전달받은 파일 디스크립터를 바탕으로 서비스를 제공합니다.</li>
</ol>
<p>핵심은 연결이 하나 생성될 때마다 프로세스를 생성해서 해당 클라이언트에 대해 서비스를 제공하는 것입니다.</p>
<h2 id="echo_multi_process_serverc"><a href="#echo-multi-process-server-c" class="headerlink" title="echo_multi_process_server.c"></a>echo_multi_process_server.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_childproc</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="keyword">int</span> str_len, state;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    act.sa_handler = read_childproc;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    state = sigaction(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 1. socket 하나를 생성한다.</span></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. socket에 IP와 Port 번호를 할당한다.</span></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr*) &amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">    <span class="comment">// 3. 생성한 socket을 server socket(listen socket)으로 등록한다.</span></span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"listen() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        <span class="comment">// 4. 부모 프로세스는 리스닝 소켓으로 accept 함수 호출을 통해서 연결요청을 수락한다.</span></span><br><span class="line">        clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"new client connected..."</span>);</span><br><span class="line">        <span class="comment">// 5. 이때 얻게 되는 소켓의 파일 디스크립터(클라이언트와 연결된 연결 소켓)를 자식 프로세스를 생성해 넘겨준다.</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            close(clnt_sock);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            close(serv_sock);</span><br><span class="line">            <span class="comment">// 6. 자식 프로세스는 전달받은 파일 디스크립터를 바탕으로 서비스를 제공한다.</span></span><br><span class="line">            <span class="keyword">while</span>((str_len = read(clnt_sock, buf, BUF_SIZE)) != <span class="number">0</span>)</span><br><span class="line">                write(clnt_sock, buf, str_len);</span><br><span class="line"></span><br><span class="line">            close(clnt_sock);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"client disconnected..."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            close(clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_childproc</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"removed proc id: %d \n"</span>, pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="결과-확인"><a href="#결과-확인-1" class="headerlink" title="결과 확인"></a>결과 확인</h2><p><img src="/images/post/2019-02-21/echo_result_multi_process.gif" alt="echo_result_multi_process"><br>위에서 Iterable하게 구현했을때 발생했던 문제를 각 클라이언트 요청마다 별도의 프로세스를 생성함으로써 문제를 해결한 것을 확인할 수 있습니다.</p>
<h2 id="고찰"><a href="#고찰-1" class="headerlink" title="고찰"></a>고찰</h2><ul>
<li>장점<ul>
<li>프로그램 흐름이 단순하기 때문에 이해하기 쉽습니다.</li>
<li>안정적인 동작이 가능합니다. 운영체제에서 프로세스는 서로 독립된 실행 객체로 존재합니다. 서로 독립된 메모리 공간을 갖고 서로 다른 프로세스끼리 서로 영향을 미치지 않고 독립적으로 수행이 가능합니다.</li>
</ul>
</li>
<li>단점<ul>
<li>프로세스 복사에 따른 성능 문제가 있습니다.</li>
<li>병렬 처리해야 하는 만큼의 프로세스를 생성해야 합니다.</li>
<li>fork에 의해 자식 프로세스가 생성될 경우, 부모 프로세스의 자원이 복사됩니다. (코드, 소켓을 포함한 모든 열린 파일들(파일 디스크립터)) 부모 프로세스로부터 accept되어 생성된 하나의 소켓에 대해 부모 프로세스와 자식 프로세스 모두에서 한 소켓에 대한 파일 디스크립터가 존재합니다. 따라서 두 파일 디스크립터를 모두 종료해야 해당 소켓을 제거할 수 있습니다.</li>
<li>서로 다른 독립적인 메모리 공간을 갖기 때문에 프로세스간 정보 교환이 어렵다.</li>
</ul>
</li>
</ul>
<p>위의 단점들은 각 클라이언트의 요청마다 프로세스가 아닌 스레드를 생성함으로써 해결할 수 있습니다.<br>다음으로 멀티프로세스 기반의 다중 접속 서버의 단점을 개선할 수 있는 멀티스레드 기반의 다중 접속 서버에 대해 알아보겠습니다.</p>
<h1 id="멀티스레드-기반의-다중-접속-서버"><a href="#멀티스레드-기반의-다중-접속-서버" class="headerlink" title="멀티스레드 기반의 다중 접속 서버"></a>멀티스레드 기반의 다중 접속 서버</h1><p><strong><code>멀티스레드 기반의 다중 접속 서버</code>는 다수의 스레드를 생성하는 방식으로 서비스를 제공합니다.</strong><br><img src="/images/post/2019-02-21/multi_thread_server.png" alt="multi_thread_server"></p>
<ol>
<li>메인 스레드는 <code>리스닝 소켓</code>으로 accept 함수 호출을 통해서 연결요청을 수락합니다. </li>
<li>이때 얻게 되는 소켓의 파일 디스크립터(<code>클라이언트와 연결된 연결 소켓</code>)를 별도의 워커 스레드를 생성해 넘겨줍니다.</li>
<li>워커 스레드는 전달받은 파일 디스크립터를 바탕으로 서비스를 제공합니다.</li>
</ol>
<p>핵심은 연결이 하나 생성될 때마다 프로세스가 아닌 스레드를 생성해서 해당 클라이언트에 대해 서비스를 제공하는 것입니다.</p>
<h2 id="echo_multi_thread_serverc"><a href="#echo-multi-thread-server-c" class="headerlink" title="echo_multi_thread_server.c"></a>echo_multi_thread_server.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">handle_clnt</span><span class="params">(<span class="keyword">void</span> * arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> * msg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> t_id;</span><br><span class="line">    <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="keyword">int</span> str_len, state;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. socket 하나를 생성한다.</span></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. socket에 IP와 Port 번호를 할당한다.</span></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr*) &amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">    <span class="comment">// 3. 생성한 socket을 server socket(listen socket)으로 등록한다.</span></span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"listen() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        <span class="comment">// 4. 메인 스레드는 리스닝 소켓으로 accept 함수 호출을 통해서 연결요청을 수락한다.</span></span><br><span class="line">        clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"new client connected..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 클라이언트와 연결된 소켓의 파일 디스크립터를 워커 스레드를 생성해 넘겨준다.</span></span><br><span class="line">        pthread_create(&amp;t_id, <span class="literal">NULL</span>, handle_clnt, (<span class="keyword">void</span>*)&amp;clnt_sock);</span><br><span class="line">        pthread_detach(t_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">handle_clnt</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clnt_sock=*((<span class="keyword">int</span>*)arg);</span><br><span class="line">    <span class="keyword">int</span> str_len=<span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 워커 스레드는 전달받은 파일 디스크립터를 바탕으로 서비스를 제공한다.</span></span><br><span class="line">    <span class="keyword">while</span>((str_len = read(clnt_sock, buf, BUF_SIZE)) != <span class="number">0</span>)</span><br><span class="line">        write(clnt_sock, buf, str_len);</span><br><span class="line"></span><br><span class="line">    close(clnt_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> * msg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(msg, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="결과-확인"><a href="#결과-확인-2" class="headerlink" title="결과 확인"></a>결과 확인</h2><p><img src="/images/post/2019-02-21/echo_result_multi_thread.gif" alt="echo_result_multi_thread"><br>처음 Iterable하게 구현했을때 발생했던 문제를 각 클라이언트 요청마다 별도의 스레드를 생성함으로써 문제를 해결했으며, 클라이언트의 요청마다 각 프로세스를 할당해서 해결한 방법보다 스레드를 생성해 할당함으로써 리소스 소모를 줄였습니다.</p>
<h2 id="고찰"><a href="#고찰-2" class="headerlink" title="고찰"></a>고찰</h2><ul>
<li>장점<ul>
<li>프로세스 복사에 따른 비용보다 스레드 생성에 대한 비용이 적다.</li>
<li>스레드간 서로 공유하는 메모리를 갖기 때문에, 스레드간 정보 교환이 쉽다.</li>
</ul>
</li>
<li>단점<ul>
<li>하나의 프로세스 내의 다수의 스레드가 존재하기 때문에 하나의 스레드에서 문제가 생긴다면 프로세스에 영향을 미쳐 나머지 다수의 스레드에도 영향을 끼칠 수 있다.</li>
</ul>
</li>
</ul>
<p>각 클라이언트 요청마다 별도의 스레드를 생성함으로써 프로세스를 생성하던 방법보다 리소스의 비용을 줄일 수 있었고, 스레드들이 서로 공유하는 메모리를 가질 수 있는 환경이 되었습니다.<br>그러나 <strong><code>I/O 멀티플렉싱(multiplexing)</code> 기법을 사용한다면, 각 클라이언트 마다 별도의 스레드를 생성하는 것이 아닌 하나의 스레드에서 다수의 클라이언트에 연결된 소켓(파일 디스크립터)을 괸리하고 소켓에 이벤트(read/write)가 발생할 경우에만 별도의 스레드를 만들어 해당 이벤트를 처리하도록 구현할 수 있습니다.</strong></p>
<h1 id="멀티플렉싱-기반의-다중-접속-서버"><a href="#멀티플렉싱-기반의-다중-접속-서버" class="headerlink" title="멀티플렉싱 기반의 다중 접속 서버"></a>멀티플렉싱 기반의 다중 접속 서버</h1><p><code>입출력 다중화</code>란 하나의 프로세스 혹은 스레드에서 입력과 출력을 모두 다룰 수 있는 기술을 말합니다. 커널(kernel)에서는 <strong>하나의 스레드가 여러 개의 소켓(파일)을 핸들링 할 수 있는 <code>select</code>, <code>poll</code>, <code>epoll</code>과 같은 시스템 콜(system call)을 제공하고 있습니다.</strong></p>
<p>한개의 프로세스 혹은 스레드에서 한개의 클라이언트에 대한 입출력만 처리할 수 있었던 이유는 입출력 함수가 봉쇄(block)되었기 때문에, 입출력 데이터가 준비될때까지 무한정 봉쇄되어 여러 클라이언트의 입출력을 처리할 수 없었기 때문입니다.</p>
<p><strong>그러나 I/O 멀티플렉싱 기법을 사용하면 입출력 다중화에서도 입출력 함수는 여전히 봉쇄로 작동하지만, 입출력 함수를 호출하기전에 어떤 파일에서 입출력이 준비가 되었는지 확인할 수가 있습니다.</strong></p>
<blockquote>
<p><strong>봉쇄 (block)</strong></p>
<p>봉쇄를 이해하기 위해 먼저 두가지 짚고 넘어가야할 사항이 있습니다.</p>
<ol>
<li>애플리케이션에서 I/O 작업을 하는 경우, 스레드는 데이터 준비가 완료될 때까지 대기합니다. 예를 들어 소켓을 통해 read(recvfrom)를 수행하는 경우 데이터가 네트워크를 통해 도착하는 것을 기다립니다. 패킷이 네트워크를 통해 도착하면 커널 내의 버퍼에 복사됩니다. (처음에 커널 공간에 생성된 소켓의 구조에서 송신 버퍼와 수신 버퍼가 있는 것을 보았습니다.)</li>
<li>커널 내의 버퍼에 복사된 데이터를 애플리케이션에서 사용하기 위해서는 <code>커널 버퍼(kernel space)</code>에서 <code>유저 버퍼(user space)</code>로 복사 후 이용해야 합니다. 애플리케이션은 유버 모드에서 유저 버퍼에만 접근이 가능하기 때문입니다.</li>
</ol>
<p><strong>Blocking I/O Model</strong><br><img src="/images/post/2019-02-21/blocking_io_model.png" alt="blocking_io_model"><br>프로세스(스레드)는 하나의 소켓에 대해 recvfrom을 호출하고 데이터가 kernel space 도착해 user space의 프로세스 버퍼에 복사 될 때까지 시스템 호출이 반환되지 않습니다. <strong>즉 recvfrom은 kernel space에 데이터가 도착하길 기다리는것 부터 시작됩니다.</strong> 프로세스는 recvfrom을 호출할 때부터 반환 할 때까지 전체 프로세스가 봉쇄됩니다.</p>
</blockquote>
<p><strong>I/O Multiplexing Model</strong><br><img src="/images/post/2019-02-21/multiplexing_io_model.png" alt="multiplexing_io_model"><br>멀티플렉싱 모델에서는 select 함수를 호출해, 여러개의 소켓들 중 recvfrom이 가능한 소켓이 생길 때까지 대기합니다. select의 결과로 recvfrom을 호출할 수 있는 소켓의 목록이 반환되면, 해당 소켓들에 대해 recvfrom을 호출합니다.</p>
<p>봉쇄 모델(Blocking I/O model)에서는 하나의 프로세스(스레드)에서 하나의 소켓(파일 디스크립터)에 대해 recvfrom을 호출해 데이터가 kernel space에 도착했는지 확인하고 현재 읽을 수 있는 데이터가 없다면 봉쇄되어 대기했다면, <strong>멀티플렉싱 모델(I/O Multiplexing Model)에서는 하나 이상의 소켓(파일 디스크립터)이 준비 될 때까지 대기할 수 있습니다.</strong></p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p><strong><code>select</code> 방식은 이벤트(입력|출력|에러) 별로 감시할 파일들을 fd_set 이라는 파일 상태 테이블(fd 비트 배열)에 등록하고, 등록된 파일(파일 디스크립터)에 어떠한 이벤트가 발생했을 경우 fd_set을 확인하는 방식으로 동작합니다.</strong><br><img src="/images/post/2019-02-21/select_model.png" alt="select_model"><br>예를 들어 위와 같이 6개의 파일을 다루어야 한다고 했을 때, 6개의 파일에 대해 입출력 데이터가 준비될 때까지 이벤트를 기다리는 파일 상태 테이블을 준비합니다. 그 후 6개의 파일 중 입출력이 준비된 파일에 대해서 이벤트가 발생하면 이벤트가 발생한 파일 디스크립터의 수를 반환합니다. 이후 이벤트가 준비된 파일에 대해 입출력을 수행하는데 이미 데이터가 준비된 파일에 대해 입출력을 수행하기 때문에 봉쇄가 발생하지 않을 것이라는게 보장됩니다.</p>
<blockquote>
<p>int select(int nfds, fd_set <em>readfds, fd_set </em>writefds, fd_set <em>exceptfds, struct timeval </em>timeout)</p>
<ul>
<li>nfds: 검사 대상이 되는 파일 디스크립터의 수</li>
<li>readfs: 읽기 이벤트를 검사할 파일 디스크립터의 목록</li>
<li>writefds: 쓰기 이벤트를 검사할 파일 디스크립터의 목록</li>
<li>exceptfds: 예외 이벤트를 검사할 파일 디스크립터의 목록</li>
<li>timeout: 이벤트를 기다릴 시간 제한</li>
<li>반환 값: <strong>이벤트가 발생한 파일의 갯수</strong></li>
</ul>
<p>반환 값이 이벤트가 발생한 파일의 디스크립터 목록이 아닌 파일의 갯수임에 주의해야합니다. </p>
</blockquote>
<h3 id="echo_select_serverc"><a href="#echo-select-server-c" class="headerlink" title="echo_select_server.c"></a>echo_select_server.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    <span class="comment">// 파일 상태 테이블 선언</span></span><br><span class="line">    fd_set reads, cpy_reads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="keyword">int</span> fd_max, str_len, fd_num, i;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr*) &amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"listen() error"</span>);</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;reads); <span class="comment">// fd_set 테이블을 초기화한다.</span></span><br><span class="line">    FD_SET(serv_sock, &amp;reads); <span class="comment">// 서버 소켓(리스닝 소켓)의 이벤트 검사를 위해 fd_set 테이블에 추가한다.</span></span><br><span class="line">    fd_max = serv_sock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        cpy_reads = reads;</span><br><span class="line">        timeout.tv_sec = <span class="number">5</span>;</span><br><span class="line">        timeout.tv_usec = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// result</span></span><br><span class="line">        <span class="comment">// -1: 오류 발생</span></span><br><span class="line">        <span class="comment">// 0: 타임 아웃</span></span><br><span class="line">        <span class="comment">// 1 이상 : 등록된 파일 디스크립터에 해당 이벤트가 발생하면 이벤트가 발생한 파일 디스크립터의 수를 반환한다.</span></span><br><span class="line">        <span class="keyword">if</span> ((fd_num = select(fd_max+<span class="number">1</span>, &amp;cpy_reads, <span class="number">0</span>, <span class="number">0</span>, &amp;timeout)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd_num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;fd_max+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(i, &amp;cpy_reads)) &#123; <span class="comment">// fd_set 테이블을 검사한다.</span></span><br><span class="line">                <span class="comment">// 서버 소켓(리스닝 소켓)에 이벤트(연결 요청) 발생</span></span><br><span class="line">                <span class="keyword">if</span> (i == serv_sock) &#123;     <span class="comment">// connection request!</span></span><br><span class="line">                    adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">                    clnt_sock= accept(serv_sock, (struct sockaddr*)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line">                    FD_SET(clnt_sock, &amp;reads); <span class="comment">// fd_set 테이블에 클라이언트 소켓 디스크립터를 추가한다.</span></span><br><span class="line">                    <span class="keyword">if</span> (fd_max &lt; clnt_sock)</span><br><span class="line">                        fd_max = clnt_sock;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"connected client: %d \n"</span>, clnt_sock);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 클라이언트와 연결된 소켓에 이벤트 발생</span></span><br><span class="line">                <span class="keyword">else</span> &#123;   <span class="comment">// read message!</span></span><br><span class="line">                    str_len = read(i, buf, BUF_SIZE);</span><br><span class="line">                    <span class="keyword">if</span> (str_len == <span class="number">0</span>) &#123;   <span class="comment">// close request!</span></span><br><span class="line">                        FD_CLR(i, &amp;reads); <span class="comment">// fd_set 테이블에서 파일 디스크립터를 삭제한다.</span></span><br><span class="line">                        close(i);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"closed client: %d \n"</span>, i);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        write(i, buf, str_len);    <span class="comment">// echo!</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(buf, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="결과-확인"><a href="#결과-확인-3" class="headerlink" title="결과 확인"></a>결과 확인</h3><p><img src="/images/post/2019-02-21/echo_result_select.gif" alt="echo_result_select"></p>
<h3 id="고찰"><a href="#고찰-3" class="headerlink" title="고찰"></a>고찰</h3><ul>
<li>장점<ul>
<li>단일 프로세스(스레드)에서 여러 파일의 입출력 처리가 가능합니다.</li>
<li>지원 하는 OS가 많아 이식성이 좋습니다. (POSIX 표준)</li>
</ul>
</li>
<li>단점<ul>
<li>커널에 의해서 완성되는 기능이 아닌, 순수하게 함수에 의해 완성되는 기능이다. </li>
<li>select 함수의 호출을 통해서 전달된 정보는 커널에 등록되지 않은 것이며, 그래서 select 함수를 호출할 때마다 매번 관련 정보를 전달해야 합니다. </li>
<li>select 함수의 호출 결과가 이벤트가 발생한 파일 디스크립터의 개수이기 때문에 어떤 파일 디스크립터에서 이벤트가 발생했는지 확인하기 위해서는 fd_set 테이블 전체를 검사해야 합니다. (속도가 느립니다)</li>
<li>검사할 수 있는 fd 개수에 제한이 있습니다. (최대 1024개)</li>
<li>select 호출 때마다 데이터를 복사해야합니다. (select 함수를 호출한 후 이벤트를 처리할 때 fd_set 테이블 변경이 필요하기 때문에 미리 복사가 필요합니다)</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://ko.wikipedia.org/wiki/POSIX" target="_blank" rel="noopener">POSIX란?</a></p>
<p>POSIX(Portable Operating System Interface)는 이식 가능 운영 체제 인터페이스의 약자로, 서로 다른 UNIX OS의 공통 API를 정리하여 이식성이 높은 유닉스 응용 프로그램을 개발하기 위한 목적으로 IEEE가 책정한 애플리케이션 인터페이스 규격입니다.</p>
</blockquote>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll도 select와 마찬가지로 멀티플렉싱을 구현하기 위한 방법입니다. poll이 여러 개의 파일을 다루는 방법은 select와 마찬가지로 fd(파일 디스크립터)의 이벤트를 기다리다가 이벤트가 발생하면, poll에서의 block이 해제되고, 다음 루틴에서 어떤 fd에 이벤트가 발생했는지 검사하는 방식을 사용합니다.</p>
<p>poll의 동작 원리는 select와 비슷하므로 생략합니다. 간단히 select와 비교해 차이점에 대해서만 알아보겠습니다.</p>
<ul>
<li>장점<ul>
<li>select와 단일 프로세스(스레드)에서 여러 파일의 입출력 처리가 가능합니다.</li>
<li>select 방식처럼 표준 입력|출력|에러을 따로 감시할 필요가 없습니다.</li>
<li>select는 timeval이라는 구조체를 사용해 타임아웃 값을 세팅하지만, poll은 별다른 구조체 없이 타임아웃 기능을 지원합니다. </li>
</ul>
</li>
<li>단점<ul>
<li>일부 unix 시스템에서는 poll을 지원하지 않습니다.</li>
</ul>
</li>
</ul>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll은 select 함수의 단점 극복을 위해 <strong>커널 레벨멀티플렉싱을 지원해줍니다.</strong> 커널에 관찰대상에 대한 정보를 한 번만 전달하고, 관찰대상의 범위, 또는 내용에 변경이 있을 때만 변경 사항을 알려줍니다. <strong>리눅스에서는 <code>epoll</code>, 윈도우에서는 <code>IOCP</code>, 맥에서는 <code>Kqueue</code>가 이에 해당합니다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size); //size는 epoll_fd의 크기정보를 전달한다.</span><br><span class="line">// 반환 값 : 실패 시 -1, 일반적으로 epoll_fd의 값을 리턴</span><br><span class="line"></span><br><span class="line">int epoll_ctl(int epoll_fd,             // epoll_fd</span><br><span class="line">              int operate_enum,         // 어떤 변경을 할지 결정하는 enum값</span><br><span class="line">              int enroll_fd,            // 등록할 fd</span><br><span class="line">              struct epoll_event* event // 관찰 대상의 관찰 이벤트 유형</span><br><span class="line">              ); </span><br><span class="line">// 반환 값 : 실패 시 -1, 성공시 0</span><br><span class="line"></span><br><span class="line">int epoll_wait(int epoll_fd,              // epoll_fd</span><br><span class="line">               struct epoll_event* event, // event 버퍼의 주소</span><br><span class="line">               int maxevents,             // 버퍼에 들어갈 수 있는 구조체 최대 개수</span><br><span class="line">               int timeout                // select의 timeout과 동일 단위는 1/1000</span><br><span class="line">               );</span><br><span class="line">// 성공시 이벤트 발생한 파일 디스크립터 개수 반환, 실패시 -1 반환</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>epoll_create : epoll 파일 디스크립터 저장소 생성</li>
<li>epoll_ctl : 저장소에 파일 디스크립터 등록 및 삭제</li>
<li>epoll_wait : select 함수와 마찬가지로 파일 디스크립터의 변화를 대기한다.</li>
</ul>
<p>epoll_create를 통해 생성된 epoll 인스턴스에 관찰대상을 저장 및 삭제하는 함수가 epoll_ctl이고, epoll 인스턴스에 등록된 파일 디스크립터를 대상으로 이벤트의 발생 유무를 확인하는 함수가 epoll_wait이다.</p>
</blockquote>
<h3 id="echo_epoll_serverc"><a href="#echo-epoll-server-c" class="headerlink" title="echo_epoll_server.c"></a>echo_epoll_server.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 리눅스에서만 사용 가능</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLL_SIZE 50</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="keyword">int</span> str_len, i;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">ep_events</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="keyword">int</span> epfd, event_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr*) &amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"listen() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 커널이 관리하는 epoll 인스턴스라 불리는 파일 디스크립터의 저장소 생성</span></span><br><span class="line">    <span class="comment">// 성공 시 epoll 파일 디스크립터, 실패시 -1 반환</span></span><br><span class="line">    epfd = epoll_create(EPOLL_SIZE);</span><br><span class="line">    ep_events = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct epoll_event)*EPOLL_SIZE);</span><br><span class="line"></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = serv_sock;</span><br><span class="line">    <span class="comment">// 파일 디스크립터(serv_sock)를 epoll 인스턴스에 등록한다. (관찰대상의 관찰 이벤트 유형은 EPOLLIN)</span></span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 성공 시 이벤트가 발생한 파일 디스크립터이ㅡ 수, 실패 시 -1 반환</span></span><br><span class="line">        <span class="comment">// 두 번째 인자로 전달된 주소의 메모리 공간에 이벤트 발생한 파일 디스크립터에 대한 정보가 들어있다.</span></span><br><span class="line">        event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (event_cnt == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"epoll_wait() error"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;event_cnt; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ep_events[i].data.fd == serv_sock) &#123;</span><br><span class="line">                adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">                clnt_sock= accept(serv_sock, (struct sockaddr*)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line">                event.events = EPOLLIN;</span><br><span class="line">                event.data.fd = clnt_sock;</span><br><span class="line">                <span class="comment">// 파일 디스크립터(clnt_sock)를 epoll 인스턴스에 등록한다. (관찰대상의 관찰 이벤트 유형은 EPOLLIN)</span></span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, &amp;event);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"connected client: %d \n"</span>, clnt_sock);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                str_len = read(ep_events[i].data.fd, buf, BUF_SIZE);</span><br><span class="line">                <span class="keyword">if</span> (str_len == <span class="number">0</span>) &#123; <span class="comment">// close request!</span></span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(ep_events[i].data.fd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"closed client: %d \n"</span>, ep_events[i].data.fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    write(ep_events[i].data.fd, buf, str_len);    <span class="comment">// echo!</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(serv_sock);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(buf, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="결과-확인"><a href="#결과-확인-4" class="headerlink" title="결과 확인"></a>결과 확인</h3><p><img src="/images/post/2019-02-21/echo_result_epoll.gif" alt="echo_result_epoll"></p>
<h3 id="고찰"><a href="#고찰-4" class="headerlink" title="고찰"></a>고찰</h3><ul>
<li>장점<ul>
<li>상태변화의 확인을 위한, 전체 파일 디스크립터를 대상으로 하는 반복문이 필요 없습니다.</li>
<li>select 함수에 대응하는 epoll_wait 함수호출 시, 커널에서 상태정보를 유지하기 때문에 관찰대상의 정보를 매번 전달할 필요가 없습니다.</li>
</ul>
</li>
<li>단점<ul>
<li>리눅스의 select 기반 서버를 윈도우의 select 기반 서버로 변경하는 것은 간단하나, 리눅스의 epoll 기반의 서버를 윈도우의 IOCP 기반으로 변경하는 것은 select를 이용하는 것보다 번거롭습니다.</li>
</ul>
</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html" target="_blank" rel="noopener">I/O Models</a></li>
<li><a href="https://notes.shichao.io/unp/ch6/" target="_blank" rel="noopener">I/O Multiplexing: The select and poll Functions</a> </li>
<li><a href="http://www.hanbit.co.kr/store/books/look.php?p_code=B2142415021" target="_blank" rel="noopener">뇌를 자극하는 TCP/IP 소켓 프로그래밍</a></li>
</ul>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2019/03/03/Java/java-nio/" data-toggle="tooltip" data-placement="top" title="Java NIO와 멀티플렉싱 기반의 다중 접속 서버">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2019/02/18/Programming/computer-structure/" data-toggle="tooltip" data-placement="top" title="컴퓨터 구조와 I/O">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <center>
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <ins class="adsbygoogle"
         style="display:block; text-align:center;"
         data-ad-layout="in-article"
         data-ad-format="fluid"
         data-ad-client="ca-pub-3921438651818825"
         data-ad-slot="3015269677"></ins>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</center>

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                    <div class="comment">
                        <div id="disqus_thread" class="disqus-thread"></div>
                    </div>
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#소켓이란"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">소켓이란?</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#c언어로-간단한-서버-amp-클라이언트-구현"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">C언어로 간단한 서버 &amp; 클라이언트 구현</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#linux"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">linux</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#echo_serverc"><span class="toc-nav-number">2.1.1.</span> <span class="toc-nav-text">echo_server.c</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#echo_clientc"><span class="toc-nav-number">2.1.2.</span> <span class="toc-nav-text">echo_client.c</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#결과-확인"><span class="toc-nav-number">2.1.3.</span> <span class="toc-nav-text">결과 확인</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#window"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">window</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#echo_server_winc"><span class="toc-nav-number">2.2.1.</span> <span class="toc-nav-text">echo_server_win.c</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#echo_client_winc"><span class="toc-nav-number">2.2.2.</span> <span class="toc-nav-text">echo_client_win.c</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#고찰"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">고찰</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#문제점"><span class="toc-nav-number">2.3.1.</span> <span class="toc-nav-text">문제점</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#멀티프로세스-기반의-다중-접속-서버"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">멀티프로세스 기반의 다중 접속 서버</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#echo_multi_process_serverc"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">echo_multi_process_server.c</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#결과-확인"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">결과 확인</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#고찰"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">고찰</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#멀티스레드-기반의-다중-접속-서버"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">멀티스레드 기반의 다중 접속 서버</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#echo_multi_thread_serverc"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">echo_multi_thread_server.c</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#결과-확인"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">결과 확인</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#고찰"><span class="toc-nav-number">4.3.</span> <span class="toc-nav-text">고찰</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#멀티플렉싱-기반의-다중-접속-서버"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">멀티플렉싱 기반의 다중 접속 서버</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#select"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">select</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#echo_select_serverc"><span class="toc-nav-number">5.1.1.</span> <span class="toc-nav-text">echo_select_server.c</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#결과-확인"><span class="toc-nav-number">5.1.2.</span> <span class="toc-nav-text">결과 확인</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#고찰"><span class="toc-nav-number">5.1.3.</span> <span class="toc-nav-text">고찰</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#poll"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text">poll</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#epoll"><span class="toc-nav-number">5.3.</span> <span class="toc-nav-text">epoll</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#echo_epoll_serverc"><span class="toc-nav-number">5.3.1.</span> <span class="toc-nav-text">echo_epoll_server.c</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#결과-확인"><span class="toc-nav-number">5.3.2.</span> <span class="toc-nav-text">결과 확인</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#고찰"><span class="toc-nav-number">5.3.3.</span> <span class="toc-nav-text">고찰</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#참고"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">참고</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#select" title="select">select</a>
                        
                          <a class="tag" href="/tags/#multiplexing" title="multiplexing">multiplexing</a>
                        
                          <a class="tag" href="/tags/#socket" title="socket">socket</a>
                        
                          <a class="tag" href="/tags/#nonblocking" title="nonblocking">nonblocking</a>
                        
                          <a class="tag" href="/tags/#poll" title="poll">poll</a>
                        
                          <a class="tag" href="/tags/#epoll" title="epoll">epoll</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- disqus embedded js code start (one page only need to embed once) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "https-jongmin92-github-io";
    var disqus_identifier = "https://jongmin92.github.io/2019/02/28/Java/java-with-non-blocking-io/";
    var disqus_url = "https://jongmin92.github.io/2019/02/28/Java/java-with-non-blocking-io/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus embedded js code start end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'left',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: 0.6em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                
                    <li>
                        <a target="_blank" href="https://www.facebook.com/jongmin.kim.7796420">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://github.com/jongmin92">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; KimJongMin 2019 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://beantech.org">BeanTech</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=YenYuHsuan&repo=hexo-theme-beantech&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://jongmin92.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-90389042-1';
    var _gaDomain = 'auto';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://jongmin92.github.io/images/etc/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>

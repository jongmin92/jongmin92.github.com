<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>92Hz</title>
  <icon>https://www.gravatar.com/avatar/8b7f06e12e9f3c555a0587f51748ac7f</icon>
  <subtitle>To Be A Lean Developer!</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://jongmin92.github.io/"/>
  <updated>2018-04-07T01:58:26.701Z</updated>
  <id>https://jongmin92.github.io/</id>
  
  <author>
    <name>KimJongMin</name>
    <email>kdhx92@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java.lang 패키지와 유용한 클래스</title>
    <link href="https://jongmin92.github.io/2018/04/07/Java/java-lang-package-and-useful-class/"/>
    <id>https://jongmin92.github.io/2018/04/07/Java/java-lang-package-and-useful-class/</id>
    <published>2018-04-07T02:00:00.000Z</published>
    <updated>2018-04-07T01:58:26.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javalang-패키지와-유용한-클래스">java.lang 패키지와 유용한 클래스</h1><p>java.lang 패키지는 자바프로그래밍에 가장 기본이 되는 클래스들을 포함하고 있다. 그렇기 때문에 java.lang 패키지의 클래스들은 import문 없이도 사용할 수 있게 되어 있다. 그 동안 String 클래스나 System 클래스를 import문 없이 사용할 수 있었던 이유가 바로 java.lang 패키지에 속한 클래스들이기 때문이었던 것이다.</p><h2 id="javalang-패키지">java.lang 패키지</h2><h3 id="object-클래스">Object 클래스</h3><p>Object 클래스는 멤버변수는 없고 오직 11개의 메서드만 가지고 있다.</p><p><strong>equals(Object obj)</strong><em>매개변수로 객체의 참조변수를 받아서 비교하여 그 결과를 booelan 값으로 알려주는 역할을 한다.</em>* 아래의 코드는 Object 클래스에 정의되어 있는 equals 메서드의 실제 내용이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>==obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>두 객체의 같고 다름을 참조변수의 값으로 판단한다.</p><p>String 클래스는 Object 클래스의 equals 메서드를 그대로 사용하는 것이 아니라 이처럼 오버라이딩을 통해서 String 인스턴스가 갖는 문자열 값을 비교하도록 되어있다.</p><p>String 클래스 뿐만 아니라 Date, File, Wrapper 클래스(Integer, Double 등)의 equals 메서드도 주소값이 아닌 내용을 비교하도록 오버라이딩되어 있다. 그러나 StringBuffer 클래스는 오버라이딩되어 있지 않다.</p><p><strong>hashCode()</strong><em>이 메서드는 해싱(hashing)기법에 사용되는 '해시함수(hash function)'를 구현한 것이다. 해싱은 데이터관리기법 중의 하나인데 다량의 데이터를 저장하고 검색하는 데 유용하다.</em>*</p><p>해시함수는 찾고자하는 값을 입력하면, 그 값이 저장된 위치를 알려주는 해시코드(hashcode)를 반환한다.</p><p>Object 클래스에 정의된 hashCode 메서드는 객체의 주소값을 이용해서 해시코드를 만들어 반환하기 때문에 서로 다른 두 객체는 결코 같은 해시코드를 가질 수 없다. (해싱기법을 사용하는 HashMap이나 HashSet과 같은 클래스에 저장할 객체라면 반드시 hashCode 메서드를 오버라이딩해야 한다.)</p><p>String 클래스는 문자열의 내용이 같으면, 동일한 해시코드를 반환하도록 hashCode 메서드가 오버라이딩되어 있기 때문에, 문자열의 내용이 같은 str1과 str2에 대해 hashCode()를 호출하면 항상 동일한 해시코드값을 얻는다.</p><p>반면에 System.identifyHashCode(Object x)는 Object 클래스의 hashCode 메서드처럼 객체의 주소값으로 해시코드를 생성하기 때문에 모든 객체에 대해 항상 다른 해시코드값을 반환할 것을 보장한다. 그래서 str1과 str2가 해시코드는 같지만 서로 다른 객체라는 것을 알 수 있다.</p><p><strong>toString()</strong><strong>인스턴스에 대한 정보를 문자열(String)로 제공할 목적으로 정의한 것이다.</strong> 인스턴스의 정보를 제공한다는 것은 대부분의 경우 인스턴스 변수에 저장된 값들을 문자열로 표현한다는 뜻이다.</p><p>Object클래스에 정의된 toString()은 아래와 같다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>clone()</strong><strong>자신을 복제하여 새로운 인스턴스를 생성하는 일을 한다.</strong> Object 클래스에 정의된 clone()은 단순히 인스턴스변수의 값만을 복사하기 때문에 참조 변수 타입의 인스턴스 변수가 정의되어 있는 클래스는 완전한 인스턴스 복제가 이루어지지 않는다.</p><p>cloneable 인터페이스를 구현한 클래스에서만 clone()을 호출할 수 있다. 또한 clone()을 오버라이딩하면서 접근 제어자를 protected에서 public으로 변경해야 한다.</p><p>clone()은 단순히 객체에 저장된 값을 그대로 복제할 뿐, 객체가 참조하고 있는 객체까지 복제하지는 않는다. 반면에 원본이 참조하고 있는 객체까지 복제하는 것을 '깊은 복사'라고 한다. 깊은 복사에서는 원본과 복사본이 서로 다른 객체를 참조하기 때문에 원본의 변경이 복사본에 영향을 미치지 않는다.</p><blockquote><p>공변 반환타입</p><p>JDK 1.5부터 '공변 반환타입' 이라는 것이 추가되었다. 이 기능은 오버라이딩할 때 조상 메서드의 반환타입을 자손 클래스의 타입으로 변경하는 것이다. 따라서 clone()의 반환타입을 Object가 아닌 자손의 타입으로 변경가능하다.</p><p>'공변 반환타입'을 사용하면 조상의 타입이 아닌 실제로 반환되는 자손 객체의 타입으로 반환할 수 있어서 번거로운 형변환이 줄어든다는 장점이 있다.</p></blockquote><p><strong>getClass()</strong>자신이 속한 클래스의 Class객체를 반환하는 메서드인데, Class 객체는 이름이 'Class'인 클래스의 객체이다. Class 객체는 아래와 같이 정의되어 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> <span class="keyword">implements</span> ... </span>&#123;<span class="comment">// Class 클래스</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Class 객체는 클래스의 모든 정보를 담고 있으며, 클래스당 단 1개만 존재한다. 그리고 클래스 파일이 '클래스 로더(ClassLoader)'에 의해서 메모리에 올라갈 때, 자동적으로 생성된다.</strong></p><p>클래스 로더는 실행 시에 필요한 클래스를 동적으로 메모리에 로드하는 역할을 한다. 먼저 기존에 생성된 클래스 객체가 메모리에 존재하는지 확인하고, 있으면 객체의 참조를 반환하고 없으면 클래스 패스(classpath)에 지정된 경로를 따라서 클래스 파일을 찾는다. 못 찾으면 ClassNotFoundException이 발생하고, 찾으면 해당 클래스 파일을 읽어서 Class 객체로 변환한다.</p><p>파일 형태로 저장되어 있는 클래스를 읽어서 Class 클래스에 정의된 형식으로 변환하는 것이다. 즉, 클래스 파일을 읽어서 사용하기 편한 형태로 저장해 놓은 것이 클래스 객체이다. (클래스 파일을 메모리에 로드하고 변환하는 일은 클래스 로더가 한다.)</p><blockquote><p><strong>Class 객체를 얻는 방법</strong></p><p>Class 객체에 대한 참조를 얻는 방법은 여러 가지가 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Class cObj = <span class="keyword">new</span> Card().getClass();<span class="comment">// 생성된 객체로 부터 얻는 방법</span></span><br><span class="line">&gt; Class cObj = Card.class;<span class="comment">// 클래스 리터럴(*.class)로 부터 얻는 방법</span></span><br><span class="line">&gt; Class cObj = Class.forName(<span class="string">"Card"</span>);<span class="comment">// 클래스 이름으로 부터 얻는 방법</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>특히 forName()은 특정 클래스 파일, 예를 들어 데이터베이스 드라이버를 메모리에 올릴 때 주로 사용한다. Class 객체를 이용하면 클래스에 정의된 멤버의 이름이나 개수 등, 클래스에 대한 모든 정보를 얻을 수 있기 때문에 Class 객체를 통해서 객체를 생성하고 메서드를 호출하는 등 보다 동적인 코드를 작성할 수 있다.</p></blockquote><h3 id="string-클래스"><strong>String 클래스</strong></h3><p><strong>기존의 다른 언어에서는 문자열을 char형의 배열로 다루었으나 자바에서는 문자열을 위한 클래스를 제공한다.</strong></p><p><strong>변경 불가능한(immutable) 클래스</strong>String 클래스는 문자열을 저장하기 위해서 문자형 배열 변수(char[]) value를 인스턴스 변수로 정의해놓고 있다. 인스턴스 생성 시 생성자의 매개변수로 입력받는 문자열은 이 인스턴스변수(value)에 문자형 배열(char[])로 저장되는 것이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] value;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>한번 생성된 String 인스턴스가 갖고 있는 문자열은 읽어 올 수만 있고, 변경할 수는 없다. 예를 들어 '+' 연산자를 이용해서 문자열을 결합하는 경우 인스턴스내의 문자열이 바뀌는 것이 아니라 새로운 문자열이 담긴 String 인스턴스가 생성되는 것이다.</p><p>덧셈 연산자 '+'를 사용해서 문자열을 결합하는 것은 매 연산 시 마다 새로운 문자열을 가진 String 인스턴스가 생성되어 메모리공간을 차지하게 되므로 가능한 한 결합횟수를 줄이는 것이 좋다.</p><p>문자열을 다루는 작업이 많이 필요한 경우에는 String 클래스 대신 StringBuffer 클래스를 사용하는 것이 좋다. StringBuffer 인스턴스에 저장된 문자열은 변경이 가능하므로 하나의 StringBuffer 인스턴스만으로도 문자열을 다루는 것이 가능하다.</p><p><strong>문자열의 비교</strong>문자열을 만들 때는 두 가지 방법, 문자열 리터럴을 지정하는 방법과 String 클래스의 생성자를 사용해서 만드는 방법이 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Strig str1 = <span class="string">"abc"</span>;<span class="comment">// 문자열 리터럴 "abc"의 주소가 str1에 저장됨</span></span><br><span class="line">Strig str2 = <span class="string">"abc"</span>;<span class="comment">// 문자열 리터럴 "abc"의 주소가 str2에 저장됨</span></span><br><span class="line">Strig str3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">// 새로운 String 인스턴스를 생성</span></span><br><span class="line">Strig str4 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">// 새로운 String 인스턴스를 생성</span></span><br></pre></td></tr></table></figure></p><p>String 클래스의 생성자를 이용한 경우에는 new 연산자에 의해서 메모리할당이 이루어지기 때문에 항상 새로운 String 인스턴스가 생성된다. 그러나 문자열 리터럴은 이미 존재하는 것을 재사용하는 것이다. (문자열 리터럴은 클래스가 메모리에 로드될 때 자동적으로 미리 생성된다.)</p><p>equals()를 사용했을 때는 두 문자열의 내용(&quot;abc&quot;)을 비교하기 때문에 두 경우 모두 true를 결과로 얻는다. 하지만, 각 String 인스턴스의 주소를 등가비교연산자 &quot;==&quot;로 비교했을 때는 결과가 다르다.</p><p><strong>문자열 리터럴</strong><em>자바 소스파일에 포함된 모든 문자열 리터럴은 컴파일 시에 클래스 파일에 저장된다. 이대 같은 내용의 문자열 리터럴은 한번만 저장된다.</em>* 문자열 리터럴도 String 인스턴스이고 한번 생성하면 내용을 변경할 수 없기 때문에 하나의 인스턴스를 공유하면 되기 때문이다.</p><p><strong>String 리터럴들은 컴파일 시에 클래스파일에 저장된다. 클래스 파일에는 소스파일에 포함된 모든 리터럴의 목록이 있다. 해당 클래스 파일이 클래스 로더에 의해 메모리에 올라갈 때, 이 리터럴의 목록에 있는 리터럴들이 JVM내에 있는 '상수 저장소(constant pool)'에 저장된다.</strong></p><p><strong>빈 문자열(empty string)</strong><em>길이가 0인 배열이 존재할 수 있다. char형 배열도 길이가 0인 배열을 생성할 수 있고, 이 배열을 내부적으로 가지고 있는 문자열이 바로 빈 문자열이다.</em>*</p><p>'String s = &quot;&quot;;' 과 같은 문장이 있을 때, 참조변수 s가 참조하고 있는 String 인스턴스는 내부에 'new char[0]'과 같이 길이가 0인 char형 배열을 저장하고 있는 것이다.</p><p>그러나 'String s = &quot;&quot;;'과 같은 표현이 가능하다고 해서 'char c = '';'와 같은 표현도 가능한 것은 아니다. char형 변수에는 반드시 하나의 문자를 지정해야한다.</p><p>일반적으로 변수를 선언할 때, 각 타입의 기본값으로 초기화 하지만 String은 참조형 타입의 기본값인 null 보다는 빈 문자열로, char형인 기본값은 '₩u0000' 대신 공백으로 초기화 하는 것이 보통이다. ('₩u0000'은 유니코드의 첫 번째 문자로써 아무런 문자도 지정되지 않은 빈 문자이다.)</p><p><strong>문자 인코딩 변환</strong>getBytes(String charsetName)를 사용하면, 문자열의 문자 인코딩을 다른 인코딩으로 변경할 수 있다. 자바가 UTF-16을 사용하지만, 문자열 리터럴에 포함되는 문자들은 OS의 인코딩을 사용한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] utf8_str = <span class="string">"가"</span>.getBytes(<span class="string">"UTF-8"</span>);<span class="comment">// 문자열을 UTF-8로 분환</span></span><br><span class="line">String str = <span class="keyword">new</span> String(utf8_str, <span class="string">"UTF-8"</span>);<span class="comment">// byte 배열을 문자열로 변환</span></span><br></pre></td></tr></table></figure></p><p>서로 다른 문자 인코딩을 사용하는 컴퓨터 간에 데이터를 주고받을 때는 적절한 문자 인코딩이 필요하다.</p><p>UTF-8은 한글 한 글자를 3 byte로 표현하고, CP949는 2 byte로 표현한다.</p><p><strong>기본형 값을 String으로 변환</strong>기본형을 문자열로 변경하는 방법은 간단하다. 숫자에 빈 문자열&quot;&quot;을 더해주기만 하면 된다. 이 외에도 valueOf()를 사용하는 방법도 있다. 성능은 valueOf()가 더 좋지만, 빈 문자열을 더하는 방법이 간단하고 편하기 때문에 성능향상이 필요한 경우에만 valueOf()를 쓰자.</p><blockquote><p>참조변수에 String을 더하면, 참조변수가 가리키고 있는 인스턴스의 toString()을 호출하여 String을 얻은 다음 결합한다.</p></blockquote><p><strong>String을 기본형 값으로 변환</strong>이전에는 parseInt()와 같은 메서드를 많이 섰는데, 메서드의 이름을 통일하기 위해 valueOf()가 나중에 추가되었다. valueOf(String s)는 메서드 내부에서 그저 parseInt(String s)를 호출할 뿐이므로, 두 메서드는 반환 타입만 다르지 같은 메서드이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(String s)</span><span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(ParseInt(s, <span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="stringbuffer-클래스와-stringbuilder-클래스">StringBuffer 클래스와 StringBuilder 클래스</h3><p>String 클래스는 인스턴스를 생성할 때 지정된 문자열을 변경할 수 없지만 StringBuffer 클래스는 변경이 가능하다. 내부적으로 문자열 편집을 위한 버퍼(buffer)를 가지고 있으며, StringBuffer 인스턴스를 생성할 때 그 크기를 지정할 수 있다.</p><p>StringBuffer 클래스는 String 클래스와 같이 문자열을 저장하기 위한 char형 배열의 참조변수 인스턴스로 선언해 놓고 있다. StringBuffer 인스턴스가 생성될 때, char형 배열이 생성되며 이 때 생성된 char형 배열을 인스턴스변수 value가 참조하게 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuffer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] value;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>StringBuffer의 생성자StringBuffer 클래스의 인스턴스를 생성할 때, 적절한 길이의 char형 배열이 생성되고, 이 배열은 문자열을 저장하고 편집하기 위한 공간(buffer)으로 사용된다.</p><p>StringBuffer 인스턴스를 생성할 때는 생성자 StringBuffer(int length)를 사용해서 StringBuffer 인스턴스에 저장될 문자열의 길이를 고려하여 충분히 여유있는 크기로 지정하는 것이 좋다. StringBuffer 인스턴스를 생성할 때, 버퍼의 크기를 지정해 주지 않으면 16개의 문자를 저장할 수 있는 크기의 버퍼를 생성한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">    shared = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>StringBuffer 인스턴스로 문자열을 다루는 작업을 할 때, 버퍼의 크기가 작업하려는 문자열의 길이보다 작을 때는 내부적으로 버퍼의 크기를 증가시키는 작업이 수행된다.</p><p>배열의 길이는 변경될 수 없으므로 새로운 길이의 배열을 생성한 후에 이전 배열의 값을 복사해야 한다.</p><p><strong>StringBuffer의 비교</strong>String 클래스에서는 equals메서드를 오버라이딩해서 문자열의 내용을 비교하도록 구현되어 있지만, StringBuffer 클래스는 equals메서드를 오버라이딩하지 않아서 StringBuffer클래스의 equals메서드를 사용해도 등가비교연산자(==)로 비교한 것과 같은 결과를 얻는다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line">StringBuffer sb2 = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(sb == sb2);<span class="comment">// false</span></span><br><span class="line">System.out.println(sb.equals(sb2));<span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>반면에 toString()은 오버라이딩되어 있어서 StringBuffer 인스턴스에 toString()을 호출하면, 담고있는 문자열을 String으로 변환한다.</p><p>그래서 StringBuffer 인스턴스에 담긴 문자열을 비교하기 위해서는 StringBuffer 인스턴스에 toString()을 호출해서 String 인스턴스를 얻은 다음, 여기에 equals 메서드를 사용해서 비교해야한다.</p><p><strong>StringBuilder란?</strong>StringBuffer는 멀티쓰레드에 안전(thread safe)하도록 동기화되어 있다. 멀티쓰레드로 작성된 프로그램이 아닌 경우, StringBuffer의 동기화는 불필요하게 성능만 떨어뜨리게 된다.</p><p>그래서 StringBuffer에서 쓰레드의 동기화만 뺀 StringBuilder가 새로 추가되었다.</p><h3 id="래퍼wrapper-클래스">래퍼(wrapper) 클래스</h3><p>경우에 따라 기본형(primitive type) 변수도 어쩔 수 없이 객체로 다뤄야 하는 경우가 있다. 예를 들면, 매개변수로 객체를 요구할 때, 기본형 값이 아닌 객체로 저장해야할 때, 객체 간의 비교가 필요할 때 등등의 경우에는 기본형 값들을 객체로 변환하여 작업을 수행해야 한다.</p><p>이 때 사용되는 것이 <code>래퍼(wrapper)</code>클래스이다. 8개의 기본형을 대표하는 8개의 래퍼클래스가 있는데, 이 클래스들을 이용하면 기본형 값을 객체로 다룰 수 있다.</p><p>래퍼 클래스들은 객체생성 시에 생성자의 인자로 주어진 각 자료형에 알맞은 값을 내부적으로 저장하고 있으며, 이에 관련된 여러 메서드가 정의되어 있다.</p><p>래퍼 클래스들은 모두 equals()가 오버라이딩되어 있어서 주소값이 아닌 객체가 가지고 있는 값을 비교한다. 오토박싱이 된다고 해도 Integer객체에 비교연산자를 사용할 수 없다. 대신 compareTo()를 제공한다.</p><p>그리고 toString()도 오버라이딩되어 있어서 객체가 가지고 있는 값을 문자열로 변환하여 반환한다.</p><h4 id="문자열을-숫자로-변환하기"><strong>문자열을 숫자로 변환하기</strong></h4><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="keyword">new</span> Integer(<span class="string">"100"</span>).intValue();</span><br><span class="line"><span class="keyword">int</span> i2 = Integer.parseInt(<span class="string">"100"</span>);</span><br><span class="line">Integer i3 = Integer.valueOf(<span class="string">"100"</span>);</span><br></pre></td></tr></table></figure></p><p><code>타입.parse타입(String s)</code> 의 반환값이 기본형(primitive type)이고, <code>타입.valueOf()</code>는 반환값이 래퍼 클래스 타입이라는 차이가 있다.</p><blockquote><p>문자열 -&gt; 기본형int i = Integer.parseInt(&quot;100&quot;);</p><p>문자열 -&gt; 래퍼 클래스Integer i = Integer.valueIf(&quot;100&quot;);</p></blockquote><p>JDK 1.5부터 도입된 '오토박싱(autoboxing)' 기능 때문에 반환값이 기본형일 때와 래퍼 클래스일 때의 차이가 없어졌다. 그래서 그냥 구별없이 valueOf()를 쓰는 것도 괜찮은 방법이다. 단, 성능은 valueOf()가 조금 더 느리다.</p><h4 id="오토박싱-amp-언박싱"><strong>오토박싱 &amp; 언박싱</strong></h4><p>JDK 1.5 이전에는 기본형과 참조형 간의 연산이 불가능했기 때문에, 래퍼 클래스로 기본형을 객체로 만들어서 연산해야 했다.</p><p>그러나 이제는 기본형과 참조형 간의 덧셈이 가능하다. 자바 언어의 규칙이 바뀐 것은 아니고, 컴파일러가 자동으로 변환하는 코드를 넣어주기 때문이다.</p><p><strong>기본형 값을 래퍼 클래스의 객체로 자동 변환해주는 것을 '오토박싱'이라고 하고, 반대로 변환하는 것을 '언박싱'이라고 한다.</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">10</span>); <span class="comment">// 오토박싱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value = list.get(<span class="number">0</span>); <span class="comment">// 언박싱</span></span><br></pre></td></tr></table></figure></p><p>ArrayList에 숫자를 저장하거나 꺼낼 때, 기본형 값을 래퍼클래스의 객체로 변환하지 않아도 되므로 편리하다.</p><h2 id="유용한-클래스">유용한 클래스</h2><h3 id="javautilobjects-클래스">java.util.Objects 클래스</h3><p>Object 클래스의 보조 클래스로 Math 클래스처럼 모든 메서드가 'static'이다. 객체의 비교나 널 체크(null check)에 유용하다.</p><p>IsNull()은 해당 객체가 널인지 확인해서 null이면 true를 반환하고 아니면 false를 반환한다. nonNull()은 isNull()과 정확히 반대의 일을 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">(object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nonNull</span><span class="params">(object obj)</span></span></span><br></pre></td></tr></table></figure></p><p>그리고 requireNonNull()은 해당 객체가 널이 아니어야 하는 경우에 사용한다. 만일 객체가 널이면, NullPointerException을 발생시킨다. 두 번째 매개변수로 지정하는 문자열은 예외의 메시지가 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; requireNonNull(T obj)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; requireNonNull(T obj, String message)</span><br></pre></td></tr></table></figure></p><p>Object 클래스에는 두 객체를 비교하는 메서드가 등가비교를 위한 equals()만 있고, 대소비교를 위한 compare()가 없는 것이 좀 아쉬웠다. 그래서인지 Objects에는 compare()가 추가되었다. compare()는 두 비교대상이 같으면 0, 크면 양수, 작으면 음수를 반환한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object a, Object b, Comparator c)</span></span></span><br></pre></td></tr></table></figure></p><p>이 메서드는 a와 b 두 객체를 비교하는데, 두 객체를 비교하는데 사용할 비교 기준이 필요하다. 그 역할을 하는 것이 Comparator이다.</p><p>Objects 클래스의 equals()는 Object 클래스와는 달리, null 검사를 하지 않아도 된다. equals()의 내부에서 a와 b의 null 검사를 하기 때문에 따로 null 검사를 위한 조건식을 넣지 않아도 된다. 실제 메서드의 코드는 다음과 같다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>a와 b가 모두 null인 경우에는 참을 반환한다는 점을 빼고는 특별한 것이 없다. deepEquals() 메서드는 객체를 재귀적으로 비교하기 때문에 다차원 배열의 비교도 가능하다.</p><h3 id="javautilscanner-클래스">java.util.Scanner 클래스</h3><p>Scanner는 화면, 파일, 문자열과 같은 입력소스로부터 문자데이터를 읽어오는데 도움을 줄 목적으로 JDK 1.5부터 추가되었다. Scanner에는 다음과 같은 생성자를 지원하기 때문에 다양한 입력소스로부터 데이터를 읽을 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Scanner(String source)</span><br><span class="line">Scanner(File source)</span><br><span class="line">Scanner(InputStream source)</span><br><span class="line">Scanner(Readable source)</span><br><span class="line">Scanner(ReadableByteChannel source)</span><br><span class="line">Scanner(Path source).. JDK <span class="number">1.7</span>부터 추가</span><br></pre></td></tr></table></figure></p><h3 id="javautilstringtokenizer-클래스">java.util.StringTokenizer 클래스</h3><p>StringTokenizer는 긴 문자열을 지정한 구분자(delimiter)를 기준으로 토큰(token)이라는 여러 개의 문자열로 잘라내는 데 사용된다. StringTokenizer를 이용하는 방법 이외에도 String의 split(String reges)이나 Scanner의 useDelimiter(Spring pattern)를 사용할 수도 있다.</p><p>위의 이 두 가지 방법은 정규식 표현(Regular expression)을 사용해야 하므로 정규식 표현에 익숙하지 않은 경우 StringTokenizer를 사용하는 것이 간단하면서도 명확한 결과를 얻을 수 있다.</p><p>그러나 StirngTokenizer는 구분자로 단 하나의 문자열 밖에 사용하지 못하기 때문에 복잡한 형태의 구분자로 문자열을 나누어야 하는 경우에는 정규식을 사용하는 메서드를 사용해야 한다.</p><p>split()은 빈 문자열도 토큰으로 인식하는 반면 StringTokenizer는 빈 문자열을 토큰으로 인식하지 않기 때문에 인식하는 토큰의 개수가 서로 다른 것을 알 수 있다.</p><p>이 외에도 성능의 차이가 있는데, split()은 데이터를 토큰으로 잘라낸 결과를 배열에 담아서 반환하기 때문에 데이터를 토큰으로 바로바로 잘라서 반환하는 StringTokenizer보다 성능이 떨어질 수밖에 없다. 그러나 데이터의 양이 많은 경우가 아니라면 별 문제가 되지 않으므로 크게 신경 쓸 부분은 아니다.</p><h3 id="javamathbiginteger-클래스">java.math.BigInteger 클래스</h3><p>정수형으로 표현할 수 있는 값의 한계가 있다. 가장 큰 정수형 타입인 long으로 표현할 수 있는 값은 10진수로 19자리 정도이다. 이 값도 상당히 큰 값이지만, 과학적 계산에서는 더 큰값을 다뤄야할 때가 있다. 그럴 때 사용하면 좋은 것이 BigIntenger이다.</p><p>BigInteger는 내부적으로 int배열을 사용해서 값을 다룬다. 그래서 long 타입보다 훨씬 큰 값을 다룰 수 있는 것이다. 대신 성능은 long 타입보다 떨어질 수밖에 없다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> signum; <span class="comment">// 부호. 1(양수), 0, -1(음수) 셋 중의 하나</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] mag;  <span class="comment">// 값</span></span><br></pre></td></tr></table></figure></p><p>BigIntenger는 String처럼 불변(immutable)이다. 그리고 모든 정수형이 그렇듯이 BigInteger 역시 값을 '2의 보수'의 형태로 표현한다.</p><p>위의 코드에서 알 수 있듯이 부호를 따로 저장하고 배열에는 값 자체만 저장한다. 그래서 signum의 값이 -1, 즉 음수인 경우, 2의 보수법에 맞게 mag의 값을 변환해서 처리한다. 그래서 부호만 다른 두 값의 mag의 값을 변환해서 처리한다. 그래서 부호만 다른 두 값의 mag는 같고 signum은 다르다.</p><p>BigInteger는 불변이므로, 반환타입이 BigInteger이란 얘기는 새로운 인스턴스가 반환된다는 뜻이다.</p><p><strong>비트 연산 메서드</strong>워낙 큰 숫자를 다루기 위한 클래스이므로, 성능을 향상시키기 위해 비트단위로 연산을 수행하는 메서드들을 많이 갖고 있다. 따라서 가능하면 산술연산 대신 비트연산으로 처리하도록 노력해야 한다.</p><h3 id="javamathbigdecimal-클래스">java.math.BigDecimal 클래스</h3><p>double 타입으로 표현할 수 있는 값은 상당히 범위가 넓지만, 정밀도가 최대 13자리 밖에 되지 않고 실수형의 특성상 오차를 피할 수 없다. BigDecimal은 실수형과 달리 정수를 이용해서 실수를 표현한다. 실수의 오차는 10진 실수를 2진 실수로 정확히 변환할 수 없는 경우가 있기 때문에 발생하는 것이므로, 오차가 없는 2진 정수로 변환하여 다루는 것이다.</p><h1 id="참고">참고</h1><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788995379431" target="_blank" rel="noopener">Java의 정석 - 1</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;javalang-패키지와-유용한-클래스&quot;&gt;java.lang 패키지와 유용한 클래스&lt;/h1&gt;
&lt;p&gt;java.lang 패키지는 자바프로그래밍에 가장 기본이 되는 클래스들을 포함하고 있다. 그렇기 때문에 java.lang 패키지의 클래스들은 
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://jongmin92.github.io/categories/Programming/Java/"/>
    
    
      <category term="Java" scheme="https://jongmin92.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>자주 보지 않으면 잊게되는 Java 기초 정리</title>
    <link href="https://jongmin92.github.io/2018/04/07/Java/java-basic/"/>
    <id>https://jongmin92.github.io/2018/04/07/Java/java-basic/</id>
    <published>2018-04-07T01:50:00.000Z</published>
    <updated>2018-04-07T01:53:16.512Z</updated>
    
    <content type="html"><![CDATA[<p>매번 공부해도 너무 당연하다는 듯이 넘어가 잊게되거나, 기억해 두면 좋을것 같은 기초적인 문법과 개념들을 간단히 정리해보겠습니다.</p><h1 id="변수">변수</h1><p>덧셈 연산자(+)는 피연산자가 모두 숫자일 때는 두 수를 더하지만, 피연산자 중 어느 한쪽이 String이면 나머지 한 쪽을 먼저 String으로 변환한 다음 두 String을 결합한다.</p><p><strong>참조변수의 출력이나 덧셈연산자를 이용한 참조변수와 문자열의 결합에는 toString()이 자동적으로 호출되어 참조변수를 문자열로 대치한 후 처리한다.</strong></p><h1 id="연산자">연산자</h1><ul><li>x &lt;&lt; 2 + 1 : 쉬프트연산자(&lt;&lt;)는 덧셈연산자보다 우선순위가 낮다. 그래서 해당 식은 'x &lt;&lt; (2 + 1)' 과 같다.</li><li>data &amp; 0xFF == 0 : 논리연산자(&amp;)는 비교연산자(==)보다 우선순위가 낮으므로 비교연산 후에 논리연산이 수행된다. 그래서 해당 식은 'data &amp; (0xFF == 0)' 과 같다.</li><li>x &lt; -1 || x &gt; 3 &amp;&amp; x &lt; 5 : 논리연산자 중에서 AND를 의미하는 '&amp;&amp;'가 OR을 의미하는 '||'보다 우선순위가 높다. 그래서 해당 식은 'x &lt; -1 || (x &gt; 3 &amp;&amp; x &lt; 5)' 과 같다.</li></ul><p><code>산술 변환</code> : 연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것. 이 변환은 이항 연산에서 뿐만 아니라 단항 연산에서도 일어난다. '산술 변환'의 규칙은 다음과 같다.</p><ol><li><strong>두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)</strong><ul><li>long + int -&gt; long + long -&gt; long</li><li>float + int -&gt; float + float -&gt; float</li></ul></li><li><strong>피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.</strong><ul><li>byte + short -&gt; int + int -&gt; int</li><li>char + short -&gt; int + int -&gt; int</li></ul></li></ol><p>첫 번째 규칙은 자동 형변환처럼 피연산자의 값손실을 최소화하기 위한 것이고, 두 번째 규칙은 정수형의 기본 타입인 int가 가장 효율적으로 처리할 수 있는 타입이기 때문에, 그리고 int보다 작은 타입, 예를 들면 char나 short의 표현범위가 좁아서 연산중에 오버플로우(overflow)가 발생할 가능성이 높기 때문에 만들어진 것이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a = <span class="number">1000000</span> * <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">long</span> b = <span class="number">1000000</span> * <span class="number">1000000L</span>;</span><br><span class="line">System.out.println(<span class="string">"a="</span>+a);</span><br><span class="line">System.out.println(<span class="string">"b="</span>+b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">a = -<span class="number">727379968</span></span><br><span class="line">b = <span class="number">1000000000000</span></span><br></pre></td></tr></table></figure></p><p>위의 예제에서 '1000000 * 1000000'의 결과가 1000000000000(2*10의 12승)임에도 불구하고, -727379968라는 결과가 출력되었다. 그 이유는 int 타입과 int 타입의 연산 결과는 int 타입인데, 연산결과가 int 타입의 최대값인 1000000000(2*10의 9승)을 넘으므로 오버플로우(overflow)가 발생했기 때문이다. <strong>이미 오버플로우가 발생한 값을 아무리 long 타입의 변수에 저장해도 소용이 없다.</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">'a'</span>;      <span class="comment">// c1에는 문자 'a'의 코드값은 97이 저장된다.</span></span><br><span class="line"><span class="keyword">char</span> c2 = c1;      <span class="comment">// c1에 저장되어 있는 값이 c2에 저장된다.</span></span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">' '</span>;       <span class="comment">// c3를 공백으로 초기화 한다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = c1 +<span class="number">1</span>;      <span class="comment">// 'a' + 1 -&gt; 97 + 1 -&gt; 98</span></span><br><span class="line"></span><br><span class="line">c3 = (<span class="keyword">char</span>)(c1 + <span class="number">1</span>);</span><br><span class="line">c2++;</span><br><span class="line">c2++;</span><br></pre></td></tr></table></figure></p><p>위의 예제에서 c2++; 대신에 c2=c2+1;을 사용하면 에러가 발생할 것이다. c2+1의 연산결과는 int형이며, 그 결과를 다시 c2에 담으려면 형변환 연산자를 사용하여 char형으로 형변환해야 하기 때문이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = c1 + <span class="number">1</span>;       <span class="comment">// 컴파일 에러 발생 O</span></span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">'a'</span> + <span class="number">1</span>;       <span class="comment">// 컴파일 에러 발생 X</span></span><br></pre></td></tr></table></figure></p><p>'a' + 1은 리터럴 간의 연산이기 때문에 에러가 발생하지 않는다. 상수 또는 리터럴 간의 연산은 실행과정동안 변하는 값이 아니기 때문에, 컴파일 시에 컴파일러가 계산해서 그 결과로 대체함으로써 코드를 보다 효율적으로 만든다. 컴파일러가 미리 덧셈연산을 수행하기 때문에 실행 시에는 덧셈 연산이 수행되지 않는다. 수식에 변수가 들어가 있는 경우에는 컴파일러가 미리 계산을 할 수 없기 때문에 형변환을 해줘야한다. <code>(char c2 = (char) (c1 + 1))</code> 그렇지 않으면 컴파일 에러가 발생한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">0.1f</span>;         <span class="comment">// f에 0.10000000149011612로 저장된다.</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">0.1</span>;      <span class="comment">// d에 0.10000000000000001로 저장된다.</span></span><br></pre></td></tr></table></figure></p><p>float 타입의 값을 double 타입으로 형변환하면, 부호와 지수는 달라지지 않고 그저 기수의 빈자리를 0으로 채울 뿐이므로 0.1f를 double타입으로 형변환해도 그 값은 전혀 달라지지 않는다. 즉, float 타입의 값을 정밀도가 더 높은 double 타입으로 형변환했다고 해서 오차가 적어지는 것이 아니라는 말이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">"abc"</span> == <span class="string">"abc"</span> ? <span class="keyword">true</span></span><br><span class="line">str1 == <span class="string">"abc"</span> ? <span class="keyword">true</span></span><br><span class="line">str2 == <span class="string">"abc"</span> ? <span class="keyword">false</span></span><br><span class="line">str1.equals(<span class="string">"abc"</span>) ? <span class="keyword">true</span></span><br><span class="line">str2.equals(<span class="string">"abc"</span>) ? <span class="keyword">true</span></span><br><span class="line">str2.equals(<span class="string">"ABC"</span>) ? <span class="keyword">false</span></span><br><span class="line">str2.equalsIgnoreCase(<span class="string">"ABC"</span>) ? <span class="keyword">true</span></span><br></pre></td></tr></table></figure></p><p>str2와 &quot;abc&quot;의 내용이 같은데도 '=='로 비교하면, false를 결과로 얻는다. 내용은 같지만 서로 다른 객체이기 때문이다. 그러나 <strong>equals()는 객체가 달라도 내용이 같으면 true를 반환한다. 그래서 문자열을 비교할 때는 항상 equals()를 사용해야 한다.</strong></p><ul><li>효율적인 연산<ul><li>OR 연산 '||'의 경우, 두 피연산자 중 어느 한 쪽만 '참'이어도 전체 연산결과가 '참'이므로 좌측 피연산자가 'true(참)'이면, 우측 피연산자의 값은 평가하지 않는다.</li><li>AND 연산 '&amp;&amp;'의 경우, 어느 한쪽만 '거짓(0)'이어도 전체 연산결과가 '거짓(0)'이므로 좌측 피연산자가 '거짓(0)'이면, 우측 피연산자의 값은 평가하지 않는다.</li></ul></li></ul><p>비트 XOR 연산자 '^'는 두 피연산자의 비트가 다를 때만 1이 된다. 그리고 <strong>같은 값으로 두고 XOR 연산을 수행하면 원래의 값으로 돌아온다는 특징이 있어서 간단한 암호화에 사용된다.</strong></p><p>비트 전환 연산자는 피연산자의 타입이 int보다 작으면 int로 자동 형변환(산술 변환) 후에 연산하기 때문에 연산결과는 32자리의 2진수이다.</p><p>쉬프트 연산자의 좌측 피연산자는 산술변환이 적용되어 int보다 작은 타입은 int타입으로 자동 변환되고 연산결과 역시 int타입이 된다. 그러나 쉬프트 연산자는 다른 이항연산자들과 달리 피연산자의 타입을 일치시킬 필요가 없기 때문에 우측 피연산자에는 산술변환이 적용되지 않는다.</p><p>변수 앞에 키워드 'final'을 붙이면 상수가 된다. 상수는 반드시 선언과 동시에 값을 저장해야하며, 한 번 저장된 값은 바꿀 수 없다.</p><h1 id="조건문과-반복문">조건문과 반복문</h1><p>JDK 1.5부터 배열과 컬렉션에 저장된 요소에 접근할 때 기존보다 편리한 방법으로 처리할 수 있도록 for문의 새로운 문법이 추가되었다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (타입 변수명 : 배열 또는 컬렉션) &#123;</span><br><span class="line">    <span class="comment">// 반복할 문장</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 문장에서 타입은 배열 또는 컬렉션의 요소의 타입이어야 한다. 배열 또는 컬렉션에 저장된 값이 매 반복마다 하나씩 순서대로 읽혀서 변수에 저장된다. 그러나 <strong>향상된 for문은 일반적인 for문과 달리 배열이나 컬렉션에 저장된 요소들을 읽어오는 용도로만 사용 수 있다는 제약이 있다.</strong></p><p>반복문은 그저 같은 문장을 반복해서 수행하는 것이지만, 메서드를 호출하는 것은 반복문 보다 몇 가지 과정, 예를 들면 매개변수 복사와 종료 후 복귀할 주소저장 등, 이 추가로 필요하기 때문에 반복문보다 재귀호출의 수행시간이 더 오래 걸린다.</p><h1 id="배열">배열</h1><p>배열은 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것이다.배열을 선언하는 것은 단지 생성된 배열을 다루기 위한 참조변수를 위한 공간이 만들어질 뿐이고, 배열을 생성해야만 비로소 값을 저장할 수 있는 공간이 만들어지는 것이다.</p><p><strong>Java에서는 배열의 길이가 0일 수도 있다.</strong></p><p>배열이름.length - 자바에서는 JVM이 모든 배열의 길이를 별도로 관리하며, '배열이름.length'를 통해서 배열의 길이에 대한 정보를 얻을 수 있다. <strong>'배열이름.length'는 상수이다.</strong></p><p>자바에서는 다음과 같이 배열을 간단히 초기화 할 수 있는 방법을 제공한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] score1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>&#125;; <span class="comment">// 배열의 생성과 초기화를 동시에</span></span><br><span class="line"><span class="keyword">int</span>[] score2 = &#123;<span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>&#125; <span class="comment">// new int[]를 생략할 수 있음</span></span><br></pre></td></tr></table></figure></p><p>그러나 배열의 선언과 생성을 따로 하는 경우에는 생략할 수 없다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [] score;</span><br><span class="line">score = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>&#125;; <span class="comment">// OK</span></span><br><span class="line">score = &#123;<span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>&#125;; <span class="comment">// 에러. new int[]를 생략할 수 없음</span></span><br></pre></td></tr></table></figure></p><p>만약 score의 값을 바로 출력하면 어떻게 될까? <code>타입@주소</code>의 형식으로 출력된다. '[I'는 1차원 int 배열이라는 의미이고, '@'뒤에 나오는 16진수는 배열의 주소인데 실제 주소가 아닌 내부 주소이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열을 가리키는 참조변수 score의 값을 출력</span></span><br><span class="line">System.out.println(score); <span class="comment">// [I@14318bb와 같은 형식의 문자열이 출력된다.</span></span><br></pre></td></tr></table></figure></p><p><strong>예외적으로 char배열은 println메서드로 출력하면 각 요소가 구분자없이 그대로 출력되는데, 이것은 println메서드가 char배열일 때만 이렇게 동작하도록 작성되었기 때문이다.</strong></p><p><strong>for문 대신 System클래스의 arraycopy()를 사용하면 보다 간단하고  빠르게 배열을 복사할 수 있다.</strong></p><p>자바에서 char배열이 아닌 String클래스를 이용해서 문자열을 처리하는 이유는 String클래스가 char배열에 여러 가지 기능을 추가하여 확장한 것이기 때문이다.char배열과 String클래스의 한 가지 중요한 차이는, String객체(문자열)는 읽을 수만 있을 뿐 내용을 변경할 수 없다. (변경 가능한 문자열을 다루려면, StringBuffer 클래스를 사용하면 된다.)</p><h1 id="jvm의-메모리구조">JVM의 메모리구조</h1><p><strong>JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.</strong></p><ul><li><strong>메서드 영역 (method area)</strong>프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 그 클래스의 클래스변수도 이 영역에 함께 생성된다.</li><li><strong>힙 (heap)</strong>인스턴스가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 즉, 인스턴스 변수들이 생성되는 곳이다.</li><li><strong>호출스택 (call stack or execution stack)</strong>호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되고, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다. 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다.</li></ul><h1 id="클래스">클래스</h1><p><code>인스턴스 메서드</code>는 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드이다. 반면에 인스턴스와 관계없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는) 메서드를 <code>클래스 메서드(static 메서드)</code>로 정의한다.</p><h2 id="가변인자">가변인자</h2><p>기존에는 메서드의 매개변수 개수가 고정적이었으나 JDK1.5부터 동적으로 지정해 줄 수 있게 되었으며, 이 기능을 <code>가변인자</code>라고 한다. 가변인자는 **'타입… 변수명'**과 같은 형식으로 선언한다. PrintStream클래스의 printf()가 대표적인 예이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">printf</span><span class="params">(String format, Object... args)</span></span>; &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>가변인자 외에도 매개변수가 더 있으면, 가변인자를 매개변수 중에서 제일 마지막에 선언해야 한다. 그렇지 않으면, 컴파일 에러가 발생한다.</p><p><strong>가변인자는 내부적으로 배열을 이용한다.</strong> 그래서 가변인자가 선언된 메서드를 호출할 때마다 배열이 새로 생성된다. 가변인자가 편리하지만, 이런 비효율이 숨어있기 때문에 꼭 필요한 경우에만 사용해야한다.</p><p>가변인자를 사용한 메서드를 호출할 때는 인자가 아예 없어도 되고 배열을 사용할 수도 있다. (C언어와 달리 자바에서는 길이가 0인 배열을 생성하는 것이 허용된다.)</p><h2 id="생성자">생성자</h2><p>컴파일러가 자동적으로 기본 생성자를 추가해주는 경우는 '클래스 내에 생성자가 하나도 없을 때' 뿐이다.</p><p>생성자에서 다른 생성자를 호출할 때에는 생성자의 이름으로 클래스이름 대신 <strong>this</strong>를 사용한다. 'this'는 참조변수로 인스턴스 자신을 가리킨다. 또한 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.</p><ul><li>this : 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다. 모든 인스턴스 메서드에 지역변수에 숨겨진 채로 존재한다.</li><li>this(), this(매개변수) : 생성자 같은 클래스의 다른 생성자를 호출할 때 사용한다.</li></ul><h2 id="변수의-초기화">변수의 초기화</h2><p>멤버변수는 초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본갑으로 초기화가 이루어지므로 초기화하지 않고 사용해도 되지만, 지역변수는 사용하기 전에 반드시 초기화해야 한다. (멤버변수(클래스변수와 인스턴스변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.)</p><p>멤버변수의 초기화는 지역변수와 달리 여러 가지 방법이 있다.</p><ul><li>명시적 초기화 : 변수를 선언과 동시에 초기화하는 것</li><li>생성자</li><li>초기화 블럭<ul><li>인스턴스 초기화 블럭 : 인스턴스변수를 초기화 하는데 사용</li><li>클래스 초기화 블럭 : 클래스 변수를 초기화 하는데 사용</li></ul></li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testClass</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; <span class="comment">/* 클래스 초기화 블럭 */</span> &#125;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">/* 인스턴스 초기화 블럭 */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행되며, 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때 마다 수행된다. (생성자보다 인스턴스 초기화 블럭이 먼저 수행된다.)</strong></p><p>인스턴스 변수의 초기화는 주로 생성자를 사용하고, 인스턴스 초기화 블럭은 모든 생성자에서 공통으로 수행돼야 하는 코드를 넣는데 사용한다.</p><ul><li>클래스변수의 초기화 시점 : 클래스가 처음 로딩될 때 단 한번 초기화 된다.</li><li>인스턴스변수의 초기화 시점 : 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.</li><li>클래스변수의 초기화 순서 : 기본값 -&gt; 명시적초기화 -&gt; 클래스 초기화 블럭</li><li>인스턴스변수의 초기화 순서 : 기본값 -&gt; 명시적초기화 -&gt; 인스턴스 초기화 블럭 -&gt; 생성자</li></ul><p><strong>프로그램 실행도중 클래스에 대한 정보가 요구될 때, 클래스에 로딩된다.</strong> 하지만, 해당 클래스가 이미 메모리에 로딩되어 있다면, 또 다시 로딩하지 않는다.</p><p>클래스의 로딩 시기는 JVM의 종류에 따라 좀 다를 수 있는데, 클래스가 필요할 때 바로 메모리에 로딩하도록 설계가 되어있는 것도 있고, 실행효율을 높이기 위해서 사용될 클래스들을 프로그램이 시작될 때 미리 로딩하도록 되어있는 것도 있다.</p><h1 id="상속">상속</h1><p>생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.</p><h2 id="오버라이딩의-조건">오버라이딩의 조건</h2><p>오버라이딩시 접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다.</p><ul><li>접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.접근범위는 public, protected, (default), private이다.</li><li>조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.</li></ul><p>Object 클래스를 제외한 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야 한다. 그렇지 않으면 컴파일러는 생성자의 첫 줄에 'super();'를 자동적으로 추가한다.</p><p>어떤 클래스의 인스턴스를 생성하면, 클래스 상속관계의 최고조상인 Object 클래스까지 거슬러 올라가면서 모든 조상클래스의 생성자가 순서대로 호출된다.</p><h1 id="package와-import">package와 import</h1><h2 id="패키지package">패키지(package)</h2><p>패키지란, 클래스의 묶음이다. 클래스의 실제 이름은 패키지명을 포함한 것이다.</p><p><strong>클래스가 물리적으로 하나의 클래스파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리이다. 디렉토리가 하위 디렉토리를 가질 수 있는 것처럼, 패키지도 다른 패키지를 포함할 수 있으며 점'.'으로 구분한다.</strong></p><p><strong>패키지 선언문은 반드시 소스파일에서 주석과 공백을 제외한 첫 번째 문장이어야 하며, 하나의 소스파일에 단 한번만 선언될 수 있다.</strong></p><p>소스파일에 자신이 속할 패키지를 지정하지 않은 클래스는 자동적으로 '이름 없는 패키지'에 속하게 된다. 결국 패키지를 지정하지 않는 모든 클래스들은 같은 패키지에 속한다.</p><p><code>클래스패스(classpath)</code>는 컴파일러(javac.exe)나 JVM 등이 클래스의 위치를 찾는데 사용되는 경로이다.</p><h2 id="import문">import문</h2><p>클래스의 코드를 작성하기 전에 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스이름에서 패키지명은 생략할 수 있다.</p><p>import문의 역할은 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공하는 것이다.</p><p>import문에서 클래스의 이름 대신 '*'을 사용하는 것이 하위 패키지의 클래스까지 포함하는 것은 아니라는 것이다.</p><p>import문으로 패키지를 지정하지 않으면 위와 같이 모든 클래스이름 앞에 패키지명을 반드시 붙여야 한다. 단, 같은 패키지 내의 클래스들은 import문을 지정하지 않고도 패키지명을 생략할 수 있다.</p><h1 id="제어자">제어자</h1><p>생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다. 그래서 클래스 앞에 final을 더 추가하여 상속할 수 없는 클래스라는 것을 알려야 한다.</p><p>제어자를 조합해서 사용할 때 주의해야 할 사항</p><ul><li>메서드에 static과 abstract를 함께 사용할 수 없다. (static 메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문이다.)</li><li>클래스에 abstract와 final을 동시에 사용할 수 없다.</li></ul><h1 id="참조변수">참조변수</h1><h2 id="형변환">형변환</h2><p>컴파일 시에는 참조변수간의 타입만 체크하기 때문에 실행 시 생성될 인스턴스의 타입에 대해서는 전혀 알지 못한다. 그래서 컴파일 시에는 문제가 없었지만, 실행 시에는 에러가 발생하여 실행이 비정상적으로 종료될 수 있다.</p><p>참조변수가 참좋고 있는 인스턴스의 실제 타입을 알아보기 위해 instance 연산자를 사용한다. 실제 인스턴스와 같은 타입의 instanceof 연산 이외에 조상타입의 instance 연산에도 true를 결과로 얻으며, instanceof의 연산의 결과가 true라는 것은 검사한 타입으로의 형변환을 해도 아무런 문제가 없다는 뜻이다.</p><h2 id="참조변수와-인스턴스의-연결">참조변수와 인스턴스의 연결</h2><p>멤버변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우, 조상 타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고, 자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다. 하지만 중복 정의되지 않은 경우, 조상타입의 참조변수를 사용했을 때와 자손타입의 참조변수를 사용했을 때의 차이는 없다.</p><h1 id="인터페이스">인터페이스</h1><p>인터페이스는 일종의 추상클래스이다. 인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서 <strong>추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다. 오직 추상메서드와 상수만을 멤버로 가질 수 있다.</strong></p><ul><li>모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.</li><li>모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.단, static 메서드와 디폴트 메서드는 예외</li></ul><p>원래는 인터페이스의 모든 메서드는 추상메서드이어야 하는데, JDK1.8부터 인터페이스에 static 메서드와 디폴트 메서드의 추가를 허용하는 방향으로 변경되었다.</p><h2 id="디폴트-메서드">디폴트 메서드</h2><p>조상 클래스에 새로운 메서드를 추가하는 것은 별 일이 아니지만, 인터페이스의 경우에는 보통 큰 일이 아니다. 인터페이스에 메서드를 추가한다는 것은, 추상 메서드를 추가한다는 것이고, 이 인터페이스를 구현한 기존의 모든 클래스들이 새로 추가된 메서드를 구현해야 하기 때문이다.</p><p><strong>디폴트 메서드는 추상 메서드의 기본적인 구현을 제공하는 메서드로, 추상 메서드가 아니기 때문에 디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.</strong></p><p>디폴트 메서드는 메서드 앞에 키워드 default를 붙이며, 추상 메서드와 달리 일반 메서드처럼 몸통{}이 있어야 한다. 디폴트 메서드 역시 접근 제어자가 public 이며, 생략가능하다.</p><h1 id="내부-클래스">내부 클래스</h1><p>내부 클래스는 클래스 내에 선언된 클래스이다. 클래스에 다른 클래스를 선언하는 이유는 간단하다. 두 클래스가 서로 긴밀한 관계에 있기 때문이다.</p><blockquote><p>내부 클래스의 장점</p><ul><li>내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.</li><li>코드의 복잡성을 줄일 수 있다(캡슐화).</li></ul></blockquote><h2 id="내부-클래스의-종류와-특징">내부 클래스의 종류와 특징</h2><p>내부 클래스의 종류는 변수의 선언위치에 따른 종류와 같다. 내부 클래스는 마치 변수를 선언하는 것과 같은 위치에 선언할 수 있으며, 변수의 선언위치에 따라 인스턴스변수, 클래스변수(static 변수), 지역변수로 구분되는 것과 같이 내부 클래스도 선언위치에 따라 다음과 같이 구분된다.</p><ul><li>인스턴스 클래스 (instance class)외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스 멤버처럼 다루어 진다. 주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언된다.</li><li>스태틱 클래스 (static class)외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static 멤버처럼 다루어진다. 주로 외부 클래스의 static 멤버, 특히 static 메서드에서 사용될 목적으로 선언된다.</li><li>지역 클래스 (local class)외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.</li><li>익명 클래스 (anonymous class)클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)</li></ul><p>지역 클래스(LocalInner)는 외부 클래스의 인스턴스멤버와 static 멤버를 모두 사용할 수 있으며, 지역 클래스가 포함된 메서드에 정의된 지역변수도 사용할 수 있다. 단, final이 붙은 지역변수만 접근가능한데 그 이유는 메서드가 수행을 마쳐서 지역변수가 소멸된 시점에도, 지역 클래스의 인스턴스가 소멸된 지역변수를 참조하려는 경우가 발생할 수 있기 때문이다.</p><p>JDK 1.8부터 지역 클래스에서 접근하는 지역 변수 앞에 final을 생략할 수 있게 바뀌었다. 대신 컴파일러가 자동으로 붙여준다. 즉, 편의상 final을 생략할 수 있게 한 것일 뿐 해당 변수의 값이 바뀌는 문장이 있으면 컴파일 에러가 발생한다.</p><p>내부 클래스는 컴파일 했을 때 생성되는 파일명은 <code>외부 클래스명$내부 클래스명.class</code> 형식으로 되어 있다.</p><h2 id="익명-클래스-anonymous-class">익명 클래스 (anonymous class)</h2><p><strong>익명클래스는 특이하게도 다른 내부 클래스들과는 달리 이름이 없다. 클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용될 수 있고 오직 하나의 객체만을 생성할 수 있는 일회용 클래스이다.</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 조상클래스이름() &#123;</span><br><span class="line">    <span class="comment">// 멤버 선언</span></span><br><span class="line">&#125;</span><br><span class="line">또는</span><br><span class="line"><span class="keyword">new</span> 구현인터페이스이름() &#123;</span><br><span class="line"><span class="comment">// 멤버 선언</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이름이 없기 때문에 생성자도 가질 수 없으며, 조상클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용해서 정의하기 때문에 하나의 클래스로 상속받는 동시에 인터페이스를 구현하거나 둘 이상의 인터페이스를 구현할 수 있다. 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.</p><p>익명 클래스는 이름이 없기 때문에 <code>외부 클래스명$숫자.class</code>의 형식으로 클래스파일명이 결정된다.</p><h1 id="예외처리">예외처리</h1><p>프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우가 있다. 이러한 결과를 초래하는 원인을 프로그램 에러 또는 오류라고 한다.</p><p>이를 발생시점에 따라 <code>컴파일 에러</code>와 <code>런타임 에러</code>로 나눌 수 있다.</p><blockquote><p>컴파일 에러 - 컴파일 시에 발생하는 에러</p><p>런타임 에러 - 실행 시에 발생하는 에러</p><p>논리적 에러 - 실행은 되지만, 의도와 다르게 동작하는 것</p></blockquote><p>컴파일은 잘되었어도 실행 중에 에러에 의해서 잘못된 결과를 얻거나 프로그램이 비정상적으로 종료될 수 있다.</p><p>자바에서는 실행 시(runtime) 발생할 수 있는 프로그램 오류를 <code>에러(error)</code>와 <code>예외(exception)</code> 두 가지로 구분하였다.</p><p><strong>에러는 메모리 부족(OutOfMemoryError)이나 스택오버플로우(StackOverflowError)와 같이 일단 발생하면 복구할 수 없는 심각한 오류이고, 예외는 발생하더라도 수습될 수 있는 비교적 덜 심각한 것이다.</strong></p><p>모든 예외의 최고 조상은 Exception 클래스이다.</p><h2 id="예외-처리하기-try-catch-문">예외 처리하기 - try-catch 문</h2><blockquote><p>예외처리의</p><p>정의 - 프로그램 실행 시 발생할 수 있는 예외의 발생에 대비한 코드를 작성하는 것</p><p>목적 - 프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지하는 것</p></blockquote><p>에러와 예외는 모두 실행 시(runtime) 발생하는 오류이다.</p><p>발생한 예외를 처리하지 못하면, 프로그램은 비정상적으로 종료되며, 처리되지 못한 예외(uncaught exception)는 JVM의 '예외처리기(UncaughtExceptionHandler)'가 받아서 예외의 원인을 화면에 출력한다.</p><p>예외를 처리하기 위해서는 try-catch문을 사용한다. 하나의 try 블럭 다음에는 여러 종류의 예외를 처리할 수 있도록 하나 이상의 catch 블럭이 올 수 있으며, 이 중 발생한 예외의 종류와 일치하는 단 한 개의 catch 블럭만 수행된다.</p><p>try 블럭 또는 catch 블럭에 또 다른 try-catch 문이 포함될 수 있다. catch 블럭 내의 코드에서도 예외가 발생할 수 있기 때문이다. catch 블럭 내에 또 하나의 try-catch 문이 포함된 경우, 같은 이름의 참조변수를 사용해서는 안 된다.</p><p>정수는 0으로 나누는 것이 금지되어 있지만, 실수를 0으로 나누는 것은 금지되어있지 않으며 예외가 발생하지 않는다.</p><p><strong>try 블럭에서 예외가 발생하면, 예외가 발생한 위치 이후에 있는 try 블럭의 문장들은 수행되지 않으므로, try 블럭에 포함시킬 코드의 범위를 잘 선택해야 한다.</strong></p><p>예외가 발생한 문장이 try-catch 블럭부터 차례로 내려가면서 catch 블럭의 괄호()내에 선언된 참조변수의 종류와 생성된 예외클래스의 인스턴스에 instanceof 연산자를 이용해서 검사하게 되는데, 검사 결과가 true인 catch 블럭을 만날 때까지 검사는 계속된다.</p><h3 id="printstacktrace와-getmessage">printStackTrace()와 getMessage()</h3><p>예외가 발생했을 때 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨져 있으며, getMessage()와 printStackTrace()를 통해서 이 정보들을 얻을 수 있다.</p><blockquote><p>printStackTrace() - 예외발생 당시의 호출스택(Call Stack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력한다.</p><p>getMessage() - 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.</p></blockquote><p>printStackTrace(PrintStream s) 또는 printStackTrace(PrintWriter s)를 사용하면 발생한 예외에 대한 정보를 파일에 저장할 수도 있다.</p><h3 id="멀티-catch-블럭">멀티 catch 블럭</h3><p>JDK 1.7부터 여러 catch 블럭을 '|' 기호를 이용해서, 하나의 catch 블럭으로 합칠 수 있게되었으며, 이를 '멀티 catch 블럭'이라 한다. (멀티 catch 블럭에 사용되는 '|'는 논리 연산자가 아니라 기호이다.)</p><p>만일 멀티 catch 블럭의 '|' 기호로 연결된 예외 클래스가 조상과 자손의 관계에 있다면 컴파일 에러가 발생한다. (그냥 조상 클래스만 써주는 것과 똑같기 때문이다.)</p><h2 id="예외-발생시키기">예외 발생시키기</h2><p>키워드 throw를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있다.</p><blockquote><ol><li>먼저, 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든 다음</li><li>키워드 throw를 이용해서 예외를 발생시킨다.</li></ol></blockquote><p>Exception 인스턴스를 생성할 때, 생성자에 String을 넣어 주면, 이 String이 Exception 인스턴스에  메시지로 저장된다. 이 메시지는 getMessage()를 이용해서 얻을 수 있다.</p><p>RuntimeException을 발생시키는 코드는 이에 대한 예외 처리를 하지 않았음에도 불구하고 성공적으로 컴파일 된다. RuntimeException 클래스들과 그 자손 클래스에 해당하는 예외는 프로그래머가 실수로 발생하는 것들이기 때문에 예외처리를 강제하지 않는 것이다.</p><p><strong>컴파일러가 예외처리를 확인하지 않는 RuntimeException 클래스들은 <code>unchecked 예외</code>라고 부르고, 예외처리를 확인하는 Exception 클래스들은 <code>checked 예외</code>라고 부른다.</strong></p><p>Error와 그 자손도 unchecked 예외이다. try-catch 블럭으로 처리할 수 없기 때문이다.</p><h2 id="메서드에-예외-선언하기">메서드에 예외 선언하기</h2><p>예외를 처리하는 방법에는 try-catch 문을 사용하는 것 외에, 예외를 메서드에 선언하는 방법이 있다. 메서드에 예외를 선언하려면, 메서드의 선언부에 키워드 throws를 사용해서 메서드 내에서 발생할 수 있는 예외를 적어주기만 하면 된다. (예외를 발생시키는 키워드 throw와 예외를 메서드에 선언할 때 쓰이는 throws를 구별해야 한다.)</p><p>메서드에 예외를 선언할 때 일반적으로 RuntimeException 클래스들은 적지 않는다.</p><p>예외를 메서드의 throws에 명시하는 것은 예외를 처리하는 것이 아니라, 자신(예외가 발생할 가능성이 있는 메서드)을 호출한 메서드에게 예외를 전달하여 예외처리를 떠맡기는 것이다.</p><p>예외를 전달받은 메서드가 또다시 자신을 호출한 메서드에게 전달할 수 있으며, 이런 식으로 계속 호출스택에 있는 메서드들을 따라 전달되다가 제일 마지막에 있는 main 메서드에서도 예외가 처리되지 않으면, main 메서드 마저 종료되어 프로그램이 전체가 종료된다.</p><h2 id="finally-블럭">finally 블럭</h2><p>finally 블럭은 try-catch 문과 함께 예외의 발생여부에 상관없이 실행되어야할 코드를 포함시킬 목적으로 사용된다.</p><p><strong>try 블럭에서 return문이 실행되는 경우에도 finally 블럭의 문장들이 먼저 실행된 후에, 현재 실행 중인 메서드를 종료한다. 마찬가지로 catch 블럭의 문장 수행 중에 return 문을 만나도 finally 블럭의 문장들은 수행된다.</strong></p><h2 id="자원-자동-반환-try-with-resources문">자원 자동 반환 - try-with-resources문</h2><p>JDK 1.7부터 try-with-resources문이라는 try-catch문의 변형이 새로 추가되었다.</p><p>try-with-resources문의 괄호()안에 객체를 생성하는 문장을 넣으면, 이 객체는 따로 close()를 호출하지 않아도 try 블럭을 벗어나는 순간 자동적으로 close()가 호출된다. 그 다음에 catch 블럭 또는 finally 블럭이 수행된다.</p><p>try-with-resources문에 의해 자동으로 객체의 close()가 호출될 수 있으려면, 클래스가 AuthCloseable이라는 인터페이스를 구현한 것이어야만 한다.</p><h1 id="참고">참고</h1><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788995379431" target="_blank" rel="noopener">Java의 정석 - 1</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;매번 공부해도 너무 당연하다는 듯이 넘어가 잊게되거나, 기억해 두면 좋을것 같은 기초적인 문법과 개념들을 간단히 정리해보겠습니다.&lt;/p&gt;
&lt;h1 id=&quot;변수&quot;&gt;변수&lt;/h1&gt;
&lt;p&gt;덧셈 연산자(+)는 피연산자가 모두 숫자일 때는 두 수를 더하지만,
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://jongmin92.github.io/categories/Programming/Java/"/>
    
    
      <category term="Java" scheme="https://jongmin92.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>토비의 스프링 4장 (예외)</title>
    <link href="https://jongmin92.github.io/2018/04/04/Spring/toby-4/"/>
    <id>https://jongmin92.github.io/2018/04/04/Spring/toby-4/</id>
    <published>2018-04-04T13:50:00.000Z</published>
    <updated>2018-04-04T13:52:50.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="예외">예외</h1><p>JdbcTemplate을 대표로 하는 스프링의 데이터 액세스 기능에 담겨 있는 예외처리와 관련된 접근 방법에 대해 알아보자.</p><h2 id="사라진-sqlexception">사라진 SQLException</h2><p>JdbcTemplate을 적용한 코드에서는 SQLException이 사라졌다. 이 SQLException은 어디로 간 것일까?</p><h3 id="초난감-예외처리">초난감 예외처리</h3><p><strong>예외가 발생하면 그것을 catch 블록을 써서 잡아내는 것까지는 좋은데 그리고 아무것도 하지 않고 별문제 없는 것처럼 넘어가 버리는 건 정말 위험한 일이다.</strong> 원치 않는 예외가 발생하는 것보다도 훨씬 더 나쁜 일이다. 왜냐하면 프로그램 실행 중에 어디선가 오류가 있어서 예외가 발생했는데 그것을 무시하고 계속 진행해버리기 때문이다. 결국 발생한 예외로 인해 어떤 기능이 비정상적으로 동작하거나, 메모리나 리소스가 소진되거나, 예상치 못한 다른 문제를 일으킬 것이다.</p><p>예외를 처리할 때 반드시 지켜야할 핵심 원칙은 한 가지다. <strong>모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야 한다.</strong></p><p>SQLException이 발생하는 이유는 SQL에 문법 에러가 있거나 DB에서 처리할 수 없을 정도로 데이터 액세스 로직에 심각한 버그가 있거나, 서버가 죽거나 네트워크가 끊기는 등의 심각한 상황이 벌어졌기 때문이다.</p><p>예외를 처리하는 2가지 나쁜 습관은 어떤 경우에도 용납하지 않아야 한다.</p><ul><li>예외 블랙홀</li><li>무의미하고 무책임한 throws</li></ul><h4 id="예외의-종류와-특징">예외의 종류와 특징</h4><p>예외를 어떻게 다뤄야 할까? 가장 큰 이슈는 <code>체크 예외(checked exception)</code>라고 불리는 명시적인 처리가 필요한 예외를 사용하고 다루는 방법이다. 자바에서 throw를 통해 발생시킬 수 있는 예외는 크게 세 가지가 있다.</p><h4 id="error"><strong>Error</strong></h4><p><strong>첫째는 java.lang.Error 클래스의 서브클래스들이다.</strong> <strong>에러는 시스템에 뭔가 비정상적인 상황이 발생했을 경우에 사용된다.</strong> 그래서 주로 자바 VM에서 발생시키는 것이고 애플리케이션 코드에서 잡으려고 하면 안된다. 시스템 레벨에서 특별한 작업을 하는 게 아니라면 애플리케이션에서는 이런 에러에 대한 처리는 신경 쓰지 않아도 된다.</p><h4 id="exception과-체크-예외">Exception과 체크 예외</h4><p><strong>java.lang.Exception 클래스와 그 서브클래스로 정의되는 예외들은 에러와 달리 개발자들이 만든 애플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용된다.</strong></p><p>Exception 클래스는 다시 <code>체크 예외(checked exception)</code>와 <code>언체크 예외(Unchecked exception)</code>로 구분된다. 전자는 Exception 크래스의 서브클래스이면서 RuntimeException 클래스를 상속하지 않은 것들이고, 후자는 RuntimeException을 상속한 클래스들을 말한다. RuntimeException은 Exception의 서브클래스이므로 Exception의 일종이긴 하지만 자바는 이 RuntimeException과 그 서브클래스는 특별하게 다룬다.</p><p>일반적으로 예외라고 하면 Exception 클래스의 서브클래스 중에서 RuntimeException을 상속하지 않은 것만을 말하는 체크 예외라고 생각해도 된다. <strong>체크 예외가 발생할 수 있는 메소드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 한다.</strong> 사용할 메소드가 체크 예외를 던진다면 이를 catch 문으로 잡든지, 아니면 다시 throws를 정의해서 메소드 밖으로 던져야 한다. 그렇지 않으면 컴파일 에러가 발생한다.</p><h4 id="runtimeexception과-언체크런타임-예외">RuntimeException과 언체크/런타임 예외</h4><p><strong>java.lang.RuntimeException 클래스를 상속한 예외들은 명시적인 예외처리를 강제하지 않기 때문에 언체크 예외라고 불린다. 또는 대표 클래스 이름을 따서 런타임 예외라고도 한다.</strong> 에러와 마찬가지로 이 런타임 예외는 catch 문으로 잡거나 throws로 선언하지 않아도 된다. 물론 명시적으로 잡거나 throw로 선언해줘도 상관없다.</p><p>대표적으로 오브젝트를 할당하지 않은 레퍼런스 변수를 사용하려고 시도했을 때 발생하는 NullPointerException이나, 허용되지 않는 값을 사용해서 메소드를 호출할 때 발생하는 IllegalArgumentException 등이 있다. 이런 예외는 코드에서 미리 조건을 체크하도록 주의 깊게 만든다면 피할 수 있다. <strong>피할 수 있지만 개발자가 부주의해서 발생할 수 있는 경우에 발생하도록 만든 것이 런타임 예외다. 따라서 런타임 예외는 예상하지 못했던 예외상황에서 발생하는 게 아니기 때문에 굳이 catch나 throws를 사용하지 않아도 되도록 만든 것이다.</strong></p><h3 id="예외처리-방법">예외처리 방법</h3><h4 id="예외-복구">예외 복구</h4><p><strong>첫 번째 예외처리 방법은 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것이다.</strong> 예외처리 코드를 강제하는 체크 예외들은 예외를 어떤 식으로든 복구할 가능성이 있는 경우에 사용한다.</p><h4 id="예외처리-회피">예외처리 회피</h4><p><strong>두 번째 방법은 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것이다. throws 문으로 선언해서 예외가 발생하면 알아서 던져지게 하거나 catch 문으로 일단 예외를 잡은 후에 로그를 남기고 다시 예외를 던지는 것이다.</strong> 예외를 자신이 처리하지 않고 회피하는 방법이다.</p><p>JdbcTemplate이 사용하는 콜백 오브젝트는 메소드 선언을 보면 알겠지만 ResultSet이나 PreparedStatement 등을 이용해서 작업하다 발생하는 SQLException을 자신이 처리하지 않고 템플릿으로 던져버린다. 콜백 오브젝트의 메소드는 모두 throws SQLException이 붙어있다. SQLException을 처리하는 일은 콜백 오브젝트의 일이 아니라고 보기 때문이다. 콜백 오브젝트의 메소드는 SQLException에 대한 예외를 회피하고 템플릿 레벨에서 처리하도록 던져준다.</p><p>예외를 회피하는 것은 예외를 복구하는 것처럼 의도가 분명해야 한다.</p><h4 id="예외-전환">예외 전환</h4><p><strong>마지막으로 예외를 처리하는 방법은 예외 전환을 하는 것이다.</strong> 예외 회피와 비슷하게 예외를 복구해서 정상적인 상태로는 만들 수 없기 때문에 예외를 메소드 밖으로 던지는 것이다. <strong>하지만 예외 회피와 달리, 발생한 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던진다는 특징이 있다.</strong></p><p>예외 전환은 보통 두 가지 목적으로 사용된다.</p><p><strong>첫째는 내부에서 발생한 예외를 그대로 던지는 것이 그 예외상황에 대한 적절한 의미를 부여해주지 못하는 경우에, 의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해서다.</strong> API가 발생하는 기술적인 로우레벨을 상황에 적합한 의미를 가진 예외로 변경하는 것이다. 보통 전환하는 예외에 원래 발생한 예외를 담아서 **중첩 예외(nested exception)**로 만드는 것이 좋다. 중첩 예외는 getCause() 메소드를 이용해서 처음 발생한 예외가 무엇인지 확인할 수 있다.</p><p><strong>두번째 전환 방법은 예외를 처리하기 쉽고 단순하게 만들기 위해 포장하는 것이다.</strong> 중첩 예외를 이용해 새로운 예외를 만들고 원인이 되는 예외를 내부에 담아서 던지는 방식은 같다. 하지만 의미를 명확하게 하려고 다른 예외로 전환하는 것이 아니다. <strong>주로 예외처리를 강제하는 체크 예외를 언체크 예외인 런타임 예외로 바꾸는 경우에 사용한다.</strong></p><p>일반적으로 체크 예외를 계속 throws를 사용해 넘기는 건 무의미하다. 메소드 선언은 지저분해지고 아무런 장점이 없다. DAO에서 발생한 SQLException이 웹 컨트롤러 메소드까지 명시적으로 전달된다고 해서 무슨 소용이 있을까? 어차피 복구가 불가능한 예외라면 가능한 한 빨리 런타임 예외로 포장해 던지게 해서 다른 계층의 메소드를 작성할 때 불필요한 throws 선언이 들어가지 않도록 해줘야 한다.</p><p>대부분 서버 환경에서는 애플리케이션 코드에서 처리하지 않고 전달된 예외들을 일괄적으로 다룰 수 있는 기능을 제공한다.</p><h3 id="예외처리-전략">예외처리 전략</h3><h4 id="런타임-예외의-보편화">런타임 예외의 보편화</h4><p>일반적으로는 체크 예외가 일반적인 예외를 다루고, 언체크 예외는 시스템 장애나 프로그램사으이 오류에 사용된다고 했다. 문제는 체크 예외는 복구할 가능성이 조금이라도 있는, 말 그대로 예외적인 상황이기 때문에 자바는 이를 처리하는 catch 블록이나 throws 선언을 강제하고 있다는 점이다.</p><p><strong>독립형 애플리케이션과 달리 서버의 특정 계층에서 예외가 밸생했을 때 작업을 일시 중지하고 사용자와 바로 커뮤니케이션하면서 예외상황을 복구할 수 있는 방법이 없다. 자바의 환경이 서버로 이동하면서 체크 예외의 활용도와 가치는 점점 떨어지고 있다.</strong> 자칫하면 throws Exception으로 점철된 아무런 의미도 없는 메소드들을 낳을 뿐이다. 그래서 대응이 불가능한 체크 예외라면 빨리 런타임 예외로 전환해서 던지는게 낫다.</p><p><strong>자바 초기부터 있었던 JDK의 API와 달리 최근에 등장하는 표준 스펙 또는 오픈소스 프레임워크에서는 API가 발생시키는 예외를 체크 예외 대신 언체크 예외로 정의하는 것이 일반화되고 있다.</strong> 언체크 예외라도 필요하다면 얼마든지 catch 블록으로 잡아서 복구하거나 처리할 수 있다. 하지만 대개는 복구 불가능한 상황이고 보나마나 RuntimeException 등으로 포장해서 던져야 할 테니 아예 API 차원에서 런타임 예외를 던지도록 한 것이다.</p><h4 id="애플리케이션-예외">애플리케이션 예외</h4><p>런타임 예외 중심의 전략은 굳이 이름을 붙이자면 낙관적인 예외처리 기법이라고 할 수 있다. 일단 복구할 수 있는 예외는 없다고 가정하고 예외가 생겨도 어차피 런타임 예외이므로 시스템 레벨에서 알아서 처리해줄 것이고, 꼭 필요한 경우는 런타임 예외라도 잡아서 복구하거나 대응해줄 수 있으니 문제 될 것이 없다는 낙관적인 태도를 기반으로 하고 있다.</p><p>보통 시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적으로 발생시키는 애플리케이션 예외를 가지는 메소드를 설계하는 방법에는 두 가지가 있다.</p><p>첫 번째 방법은 정상적인 처리를 했을 경우와 애플리케이션 자체의 로직에 의해 의도적으로 예외를 발생시키고자 하는 경우에 각각 다른 종류의 리턴 값을 돌려주는 것이다. 하지만 이렇게 리턴 값으로 결과를 확인하고, 예외상황을 체크하면 불편한 점도 있다. 우선 예외 상황에 대한 리턴 값을 명확하게 코드화하고 잘 관리하지 않으면 혼란이 생길 수 있다. 또 한 가지 문제는 결과 값을 확인하는 조건문이 자주 등장한다는 점이다.</p><p>두 번째 방법은 정상적인 흐름을 따르는 코드는 그대로 두고, 애플리케이션 자체의 로직에 의해 의도적으로 예외를 발생시키고자 하는 경우에는 비즈니스적인 의미를 띤 예외를 던지도록 만드는 것이다. 이때 사용하는 예외는 의도적으로 체크 예외로 만든다. 그래서 개발자가 잊지 않고 자주 발생 가능한 예외상황에 대한 로직을 구현하도록 강제해주는 게 좋다.</p><h4 id="sqlexception은-어떻게-됐나">SQLException은 어떻게 됐나?</h4><p>먼저 생각해볼 사항은 SQLException은 과연 복구가 가능한 예외인가이다. 대부분의 SQLException은 복구가 불가능하다. 더군다나 DAO 밖에서 SQLException을 다룰 수 있는 가능성은 거의 없다. 따라서 예외처리 전략을 적용해야 한다. 필요도 없는 기계적인 throws 선언이 등장하도록 방치하지 말고 가능한한 빨리 언체크/런타임 예외로 전환해줘야 한다.</p><p>스프링의 JdbcTemplate은 바로 이 예외처리 전략을 따르고 있다. JdbcTemplate 템플릿과 콜백 안에서 발생하는 모든 SQLException을 런타임 예외인 DataAccessException으로 포장해서 던져준다. 따라서 JdbcTemplate을 사용하는 UserDao 메소드에선 꼭 필요한 경우에만 런타임 예외인 DataAccessException을 잡아서 처리하면 되고 그 외의 경우에는 무시해도 된다.</p><p>그 밖에도 스프링의 API 메소드에 정의되어 있는 대부분의 예외는 런타임 예외다. 따라서 발생 가능한 예외가 있다고 하더라도 이를 처리하도록 강제하지 않는다.</p><h2 id="예외-전환">예외 전환</h2><p>예외를 다른 것으로 바꿔서 던지는 예외 전환의 목적은 두 가지이다. 하나는 런타임 예외로 포장해서 굳이 필요하지 않은 catch/throws를 줄여주는 것이고, 다른 하나는 로우레벨의 예외를 좀 더 의미 있고 추상화된 예외로 바꿔서 던져주는 것이다.</p><p>스프링의 JdbcTemplate이 던지는 DataAccessException은 일단 런타임 예외로 SQLException을 포장해주는 역할을 한다. 그래서 대부분 복구가 불가능한 예외인 SQLException에 대해 애플리케이션 레벨에서는 신경 쓰지 않도록 해주는 것이다. 또한 DataAccessException은 SQLException에 담긴 다루기 힘든 상세한 예외정보를 의미 있고 일관성 있는 예외로 전환해서 추상화해주려는 용돌 쓰이기도 한다.</p><h3 id="jdbc의-한계">JDBC의 한계</h3><p>JDBC는 자바 표준 JDK에서도 가장 많이 사용되는 기능 중의 하나다.</p><h4 id="호환성-없는-sqlexception의-db-에러정보">호환성 없는 SQLException의 DB 에러정보</h4><p><strong>DB마다 SQL 뿐만 아니라 에러의 종류와 원인도 제각각이다. 그래서 JDBC는 데이터 처리 중에 발생하는 다양한 예외를 그냥 SQLException 하나에 모두 담아버린다.</strong> SQLException은 예외가 발생했을 때의 DB 상태를 담은 SQL 상태정보를 부가적으로 제공한다. getSQLState() 메소드로 예외상황에 대한 상태정보를 가져올 수 있다. 이 상태정보는 DB별로 달라지는 에러 코드를 대신할 수 있도록, 스펙에 정의된 SQL 상태 코드를 따르도록 되어있다. 그러나 결국 호환성 없는 에러 코드와 표준을 잘 따르지 않는 상태 코드를 가진 SQLException 만으로 DB에 독립적인 유연한 코드를 작성하는 건 불가능에 가깝다.</p><h4 id="db-에러-코드-매핑을-통한-전환">DB 에러 코드 매핑을 통한 전환</h4><p>SQLException에 담긴 SQL 상태 코드는 신뢰할 만한게 아니므로 더 이상 고려하지 않는다. 차라리 DB 업체별로 만들어 유지해오고 있는 DB 전용 에러 코드가 더 정확한 정보라고 불 수 있다.</p><p><strong>스프링은 DataAccessException이라는 SQLException을 대체할 수 있는 런타임 예외를 정의하고 있을 뿐 아니라 DataAccessException의 서브클래스로 세분화된 예외 클래스들을 정의하고 있다.</strong> 디에터 엑세스 작업 중에 발생 할 수 있는 예외 상황을 수십 가지 예외로 분류하고 이를 추상화해 정의한 다양한 예외 클래스를 제공한다.</p><p><strong>JdbcTemplate은 SQLException을 단지 런타임 예외인 DataAccessException으로 포장하는 것이 아니라 DB의 에러 코드를 DataAccessException 계층구조의 클래스 중 하나로 매핑해준다.</strong> 전환되는 JdbcTemplate에서 던지는 예외는 모두 DataAccessException의 서브클래스 타입이다. <strong>DB별로 미리 준비된 매핑정보를 참고해서 적절한 예외 클래스를 선택하기 때문이 DB가 달라져도 같은 종류의 에러라면 동일한 예외를 받을 수 있다. 데이터 엑세스 기술에 독립적인 추상화된 예외를 제공하는 것이다.</strong></p><p>JdbcTemplate을 이용한다면 JDBC에서 발생하는 DB 관련 예외는 거의 신경 쓰지 않아도 된다.</p><p>JDK 1.6에 포함된 JDBC 4.0부터는 기존에 JDBC의 단일 예외 클래스였던 SQLException을 스프링의 DataAccessException과 비슷한 방식으로 좀 더 세분화해서 정의하고 있다.</p><h3 id="dao-인터페이스와-dataaccessexception-계층구조">DAO 인터페이스와 DataAccessException 계층구조</h3><p>DataAccessException은 JDBC의 SQLException을 전환하는 용도로만 만들어진 건 아니다. JDBC 외의 자바 데이터 엑세스 기술에서 발생하는 예외에도 적용된다.</p><p>DataAccessException은 의미가 같은 예외라면 데이터 액세스 기술의 종류와 상관없이 일관된 예외가 발생하도록 만들어준다. 데이터 액세스 기술에 독립적인 추상화된 예외를 제공하는 것이다.</p><h4 id="dao-인터페이스와-구현의-분리">DAO 인터페이스와 구현의 분리</h4><p>DAO를 굳이 따로 만들어서 사용하는 이유는 무엇일까? 가장 중요한 이유는 데이터 액세스 로직을 담은 코드를 성격이 다른 코드에서 분리해놓기 위해서다.</p><p>대부분의 데이터 액세스 예외는 애플리케이션에서는 복구 불가능하거나 할 필요가 없는 것이다. 그렇다고 모든 예외를 다 무시해야 하는 건 아니다. 중복 키 에러처럼 비즈니스 로직에서 의미 있게 처리할 수 잇는 예외도 있다. 애플리케이션에서는 사용하지 않더라도 시스템 레벨에서 데이터 액세스 예외를 의미 있게 분류할 필요도 있다. 문제는 데이터 액세스 기술이 달라지면 같은 상황에서도 다른 종류의 예외가 던져진다는 점이다.</p><p>따라서 DAO를 사용하는 클라이언트 입장에서는 DAO의 사용 기술에 따라서 예외 처리 방법이 달라져야 한다. 결국 클라이언트가 DAO의 기술에 의존적이 될 수 밖에 없다.</p><h4 id="데이터-액세스-예외-추상화">데이터 액세스 예외 추상화</h4><p>스프링은 자바의 다양한 데이터 액세스 기술을 사용할 때 발생하는 예외들을 추상화해서 DataAccessException 계층구조 안에 정리해놓았다. <strong>스프링의 DataAccessException은 자바의 주요 데이터 액세스 기술에서 발생할 수 있는 대부분의 예외를 추상화하고 있으며 이런 기술에서만 공통적으로 나타나는 예외를 포함해서 데이터 엑세스 기술에서 발상 가능한 대부분의 예외를 계층구조로 분류해놓았다.</strong></p><p>JdbcTemplate과 같이 스프링의 데이터 액세스 지원 기술을 이용해 DAO를 만들면 사용 기술에 독립적인 일관성 있는 예외를 던질 수 있다. 결국 인터페이스 사용, 런타임 예외 전환과 함께 DataAccessException 예외 추상화를 적용하면 데이터 액세스 기술과 구현 방법에 독립적인 이상적인 DAO를 만들 수가 있다.</p><h3 id="dataaccessexception-활용시-주의사항">DataAccessException 활용시 주의사항</h3><p>스프링을 활용하면 DB 종류나 데이터 액세스 기술에 상관없이 키 값이 중복이 되는 상황에서는 동일한 예외가 발생하리라고 기대할 것이다. 하지만 안타깝게도 DuplicateKeyException은 아직까지는 JDBC를 이용하는 경우에만 발생한다. 데이터 액세스 기술을 하이버네이트나 JPA를 사용했을 때도 동일한 예외가 발생할 것으로 기대하지만 실제로 다른 예외가 던져진다. 그 이유는 SQLException에 담긴 DB의 에러 코드를 바로 해석하는 JDBC의 경우와 달리 JPA나 하이버네이트, JDO 등에서는 각 기술이 재정의한 예외를 가져와 스프링이 최종적으로 DataAccessException으로 변환하는데, DB의 에러 코드와 달리 이런 예외들은 세분화되어 있지 않기 때문이다.</p><p><strong>DataAccessException이 기술에 상관없이 어느 정도 추상화된 공통 예외로 변환해주긴 하지만 근본적인 한계 때문에 완벽하다고 기대할 수는 없다. 따라서 사용에 주의를 기울여야 한다.</strong></p><p><strong>스프링은 SQLException을 DataAccessException으로 전환하는 다양한 방법을 제공한다.</strong> 가장 보편적이고 효과적인 방법은 DB 에러 코드를 이용하는 것이다. SQLException을 코드에서 직접 전환하고 싶다면 SQLExceptionTranslator 인터페이스를 구현한 클래스 중에서 <code>SQLErrorCodeSQLExceptionTranslator</code>를 사용하면 된다.</p><h1 id="참고">참고</h1><p><a href="http://www.acornpub.co.kr/book/toby-spring3.1-vol1" target="_blank" rel="noopener">토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;예외&quot;&gt;예외&lt;/h1&gt;
&lt;p&gt;JdbcTemplate을 대표로 하는 스프링의 데이터 액세스 기능에 담겨 있는 예외처리와 관련된 접근 방법에 대해 알아보자.&lt;/p&gt;
&lt;h2 id=&quot;사라진-sqlexception&quot;&gt;사라진 SQLException&lt;
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Spring" scheme="https://jongmin92.github.io/categories/Programming/Spring/"/>
    
    
      <category term="Spring" scheme="https://jongmin92.github.io/tags/Spring/"/>
    
      <category term="Toby" scheme="https://jongmin92.github.io/tags/Toby/"/>
    
      <category term="Exception" scheme="https://jongmin92.github.io/tags/Exception/"/>
    
      <category term="DataAccessException" scheme="https://jongmin92.github.io/tags/DataAccessException/"/>
    
  </entry>
  
  <entry>
    <title>토비의 스프링 3장 (템플릿)</title>
    <link href="https://jongmin92.github.io/2018/04/01/Spring/toby-3/"/>
    <id>https://jongmin92.github.io/2018/04/01/Spring/toby-3/</id>
    <published>2018-04-01T12:00:00.000Z</published>
    <updated>2018-04-01T12:08:11.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="템플릿">템플릿</h1><blockquote><p><strong>개방 폐쇄 원칙 (OCP)</strong></p><p>어떤 부분은 변경을 통해 그 기능이 다양해지고 확장하려는 성질이 있고, 어떤 부분은 고정되어 있고 변하지 않으려는 성질이 있다. 변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조를 만들어주는 것이 개방 폐쇄 원칙이다.</p></blockquote><p><strong><code>템플릿</code>이란 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법이다.</strong></p><p>일반적으로 서버에서는 제한된 개수의 DB 커넥션을 만들어서 재사용 가능한 풀로 관리한다. DB 풀은 매번 getConnection()으로 가져간 커넥션을 명시적으로 close()해서 돌려줘야지만 다시 풀에 넣었다가 다음 커넥션 요청이 있을 때 재사용할 수 있다. 그런데 이런 식으로 <strong>오류가 날 때마다 미처 반횐되지 못한 Connection이 계속 쌓이면 어느 순간에 커넥션 풀에 여유가 없어지고 리소스가 모자란다는 심각한 오류를 내며 서버가 중단될 수 있다.</strong> 그래서 JDBC 코드에서는 어떤 상황에서도 가져온 리소스를 반환하도록 try/catch/finally 구문 사용을 권장하고 있다. (finally는 try 블록을 수행한 후에 예외가 발생하든 정상적으로 처리되든 상관없이 반드시 실행되는 코드를 넣을 때 사용한다.)</p><p>어느 시점에서 예외가 발생했는지에 따라서 close()를 사용할 수 있는 변수가 달라질 수 있기 때문에 finally에서는 반드시 c(Connection)와 ps(PreparedStatment)가 null이 아닌지 먼저 확인한 후에 close() 메소드를 호출해야 한다.</p><h2 id="변하는-것과-변하지-않는-것">변하는 것과 변하지 않는 것</h2><p>이런 코드를 효과적으로 다룰 수 있는 방법은 없을까? <strong>이 문제의 핵심은 변하지 않는, 그러나 많은 곳에서 중복되는 코드와 로직에 따라 자꾸 확장되고 자주 변하는 코드를 잘 분리해내는 작업이다.</strong></p><h3 id="분리와-재사용을-위한-디자인-패턴-적용">분리와 재사용을 위한 디자인 패턴 적용</h3><h4 id="메소드-추출">메소드 추출</h4><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">        c = dataSource.getConnection();</span><br><span class="line"></span><br><span class="line">        ps = makeStatement(c); <span class="comment">// 변하는 부분을 메소드로 추출하고 변하지 않는 부분에서 호출하도록 만들었다.</span></span><br><span class="line"></span><br><span class="line">        ps.executeUpdate();</span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException e)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> PreparedStatement <span class="title">makeStatement</span><span class="params">(Connection c)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    PreparedStatement ps;</span><br><span class="line">    ps = c.prepareStatement(<span class="string">"delete from users"</span>);</span><br><span class="line">    <span class="keyword">return</span> ps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>자주 바뀌는 부분을 메소드로 독립시켰는데 별 이득이 없어 보인다. 왜냐하면 <strong>보통 <code>메소드 추출 리펙토링</code>을 적용하는 경우에는 분리시킨 메소드를 다른 곳에서 재사용할 수 있어야 하는데,</strong> 이건 반대로 분리시키고 남은 메소드가 재사용이 필요한 부분이고, 분리된 메소드는 DAO 로직마다 새롭게 만들어서 확장돼야 하는 부분이기 때문이다. 뭔가 반대로 됐다.</p><h4 id="템플릿-메소드-패턴의-적용">템플릿 메소드 패턴의 적용</h4><p><strong><code>템플릿 메소드 패턴</code>은 상속을 통해 식능을 확장해서 사용하는 부분이다. 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메소드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것이다.</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> PreparedStatement <span class="title">makeStatement</span><span class="params">(Connection c)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoDeleteAll</span> <span class="keyword">extends</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PreparedStatement <span class="title">makeStatement</span><span class="params">(Connection C)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        PreparedStatment ps = c.prepareStatement(<span class="string">"delete from users"</span>);</span><br><span class="line">        <span class="keyword">return</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이제 UserDao 클래스의 기능을 확장하고 싶을 때마다 상속을 통해 자유롭게 확장할 수 있고, 확장 때문에 기존의 상위  DAO 클래스에 불필요한 변화는 생기지 않도록 할 수 있으니 객체지향 설계의 핵심 원리인 개방 폐쇄 원칙(OCP)을 그럭저럭 지키는 구조를 만들어낼 수는 있는것 같다. 그렇지만 아직 문제가 있다. 가장 큰 문제는 DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다는 점이다. 이래서는 장점보다 단점이 더 많아 보인다.</p><p>변하지 않는 코드를 가진 UserDao의 JDBC try/catch/finally 블록과 변하는 PreparedStatement를 담고 있는 서브클래스들이 이미 클래스 리벨에서 컴파일 시점에 이미 그 관계가 결정되어 있다. 따라서 그 관계에 대한 유연성이 떨어진다.</p><h4 id="전략-패턴의-적용">전략 패턴의 적용</h4><p><strong>개방 폐쇠 원칙(OCP)을 잘 지키는 구조이면서도 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어난 것이, 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 <code>전략 패턴</code>이다. 전략 패턴은 OCP 관점에서 보면 확장에 해당하는 변하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임하는 방식이다.</strong></p><p>deleteAll()은 JDBC를 이용해 DB를 업데이트하는 작업이라는 변하지 않는 맥락(context)을 갖는다. deleteAll()의 컨텍스트를 정리해보면 다음과 같다.</p><ul><li>DB 커넥션 가져오기</li><li>PreparedStatement를 만들어줄 외부 기능 호출하기</li><li>전달받은 PreparedStatement 실행하기</li><li>예외가 발생하면 이를 다시 메소드 밖으로 던지기</li><li>모든 경우에 만들어진 PreparedStatement와 Connection을 적절히 닫아주기</li></ul><p>두번째 작업에서 사용하는 PreparedStatement를 만들어주는 외부 기능이 바로 전략 패턴에서 말하는 전략이라고 볼 수 있다. 전략 패턴의 구조를 따라 이 기능을 인터페이스로 만들어두고 인터페이스 이 메소드를 통해 PreparedStatement 생성 전략을 호출해주면 된다. 여기서 눈여겨볼 것은 이 PreparedStatement를 생성하는 전략을 호출할 때는이 컨텍스트 내에서 만들어둔 DB 커넥션을 전달해야 한다는 점이다.</p><p>PreparedStatement를 만드는 전략의 인터페이스는 컨텍스트가 만들어준 Connection을 전달받아서, PreparedStatement를 만들고 만들어진 PreparedStatement 오브젝트를 돌려준다. 이 내용을 인터페이스로 정의하면 다음과 같다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatementStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function">PreparedStatement <span class="title">makePreparedStatement</span><span class="params">(Connection c)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>StatementStrategy 인터페이스를 상속해서 실제 전략 클래스를 만들고 이 전략 클래스를 이용한 전략 패턴을 적용한 코드는 다음과 같다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    c = dataSource.getConnection();</span><br><span class="line"></span><br><span class="line">        StatementStrategy strategy = <span class="keyword">new</span> DeleteAllStatement();</span><br><span class="line">        ps = strategy.makePreparedStatement(c);</span><br><span class="line"></span><br><span class="line">        ps.executeUpdate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>전략 패턴은 필요에 따라 컨텍스트는 그대로 유지되면서(OCP의 폐쇄 원칙) 전략을 바꿔 쓸 수 있다(OCP의 개방 원칙)는 것인데, 이렇게 컨텍스트 안에서 이미 구체적인 전략 클래스인 DeleteAllStatement를 사용하도록 고정되어 있다면 뭔가 이상하다. 컨텍스트가 StatementStrategy 인터페이스 뿐 아니라 특정 구현 클래스인 DeleteAllStatement를 직접 알고 있다는건, 전략 패턴에도 OCP에도 잘 들어맞는다고 볼 수 없기 때문이다.</p><h4 id="di-적용을-위한-클라이언트컨텍스트-분리">DI 적용을 위한 클라이언트/컨텍스트 분리</h4><p><strong>전략 패턴에 따르면 Context가 어떤 전략을 사용하게 할 것인가는 Context를 사용하는 앞단의 Client가 결정하는게 일반적이다. Client가 구체적인 전략의 하나를 선택하고 오브젝트로 만들어서 Context에 전달하는 것이다.</strong></p><p>결국 이 구조에서 전략 오브젝트 생성과 컨텍스트로의 전달을 담당하는 책임을 분리시킨 것이 바로 ObjectFactory이며, 이를 일반화한 것이 앞에서 살펴봤던 의존관계 주입(DI)이었다. <strong>결국 DI란 이러한 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만든 구조라고 볼 수 있다.</strong></p><p>아무튼 여기서 이 패턴 구조를 코드에 적용해보자. 중요한 것은 컨텍스트에 해당하는 JDBC try/catch/finally 코드를 클라이언트 코드인 StatementStrategy를 만드는 부분에서 독립시켜야 한다는 것이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jdbcContextWithStatementStrategy</span><span class="params">(StatementStrategy stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    connection c = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = dataSource.getConnection();</span><br><span class="line"></span><br><span class="line">        ps = stmt.makePreparedStatement(c);</span><br><span class="line"></span><br><span class="line">        ps.executeUpdate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123; <span class="keyword">try</span> &#123; ps.close(); &#125; <span class="keyword">catch</span> (SQLException e) &#123;&#125; &#125;</span><br><span class="line"><span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123; <span class="keyword">try</span> &#123; c.close(); &#125; <span class="keyword">catch</span> (SQLException e) &#123;&#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 메소드는 컨텍스트의 핵심적인 내용을 잘 담고 있다. 클라이언트로부터 StatementStrategy 타입의 전략 오브젝트를 제공받고 JDBC try/catch/finally 구조로 만들어진 컨텍스트 내에서 작업을 수행한다.</p><p>다음은 클라이언트에 해당하는 부분이다. 컨텍스트를 별도의 메소드로 분리했으니 deleteAll() 메소드가 클라이언트가 된다. deleteAll()은 전략 오브젝트를 만들고 컨텍스트를 호출하는 책임을 지고 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    StatementStrategy st = <span class="keyword">new</span> DeleteAllStatement(); <span class="comment">// 선정한 전략 클래스의 오브젝트 생성</span></span><br><span class="line">    jdbcContextWithStatementStrategy(st); <span class="comment">// 컨텍스트 호출. 전략 오브젝트 전달</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>클라이언트가 컨텍스트가 사용할 전략을 정해서 전달하는 면에서 DI 구조라고 이해할 수도 있다.</strong></p><blockquote><p><strong>마이크로 DI</strong></p><p>의존관계 주입(DI)은 다양한 형태로 젹용할 수 있다. DI의 가장 중요한 개념은 제3자의 도움을 통해 두 오브젝트 사이의 유여ㅛㄴ한 관계가 설정되도록 만든다는 것이다. 이 개념만 따른다면 DI를 이루는 오브젝트와 구성요소의 구조나 관계는 다양하게 만들 수 있다.</p><p>일반적으로 DI는 의존관계에 있느 ㄴ두 개의 오브젝트와 이 관계를 다이내믹하게 설정해주는 오브젝트 팩토리(DI 컨테이너), 그리고 이를 사용하는 클라이언트라는 4개의 오브직트 사이에서 일어난다. 하지만 때로는 원시적인 전략패턴 구조를 따라 클라이언트가 오브젝트 팩토리의 책임을 함께 지고 있을 수도 있다.</p><p>이런 경우에는 DI가 매우 작은 단위의 코드와 메소드 사이에서 일어나기도 한다. 이렇게 <strong>DI의 장점을 단순화해서 IoC 컨테이너의 도움 없이 코드 내에서 적용한 경우를 마이크로 DI라고도 한다.</strong> 또는 코드에 의한 의미로 수동 DI라고 부를 수도 있다.</p></blockquote><h2 id="jdbc-전략-패턴의-최적화">JDBC 전략 패턴의 최적화</h2><h3 id="전략과-클라이언트의-동거">전략과 클라이언트의 동거</h3><p>현재 구조에 두 가지 불만이 있다.</p><ul><li>DAO 메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다는 것.</li><li>DAO 메소드에서 StatementStrategy에 전달할 User와 같은 부가적인 정보가 있는 경우, 이를 위해 오브젝트를 전달받는 생성자와 이를 저장해둘 인스턴스 변수를 번거롭게 만들어야 한다는 것.</li></ul><p>이 두가지 문제를 해결할 수 있는 방법을 생각해보자.</p><h4 id="로컬-클래스">로컬 클래스</h4><p>클래스 파일이 많아지는 문제는 간단한 해결 방법이 있다. StatementStrategy 전략 클래스를 매번 독립된 파일로 만들지 말고 UserDao 클래스 안에 내부 클래스로 정의해버리는 것이다. DeleteAllStatement나 AddStatement는 UserDao 밖에서는 사용되지 않는다. 둘 다 UserDao에서만 사용되고, UserDao의 메소드 로직에 강하게 결합되어 있다.</p><blockquote><p><strong>중첩 클래스의 종류</strong></p><p>다른 클래스 내부에 정의되는 클래스를 중첩 클래스(nested class)라고 한다. 중첩 클래스는 독립적으로 오브젝트로 ㅁ나들어질 수 있는 스태틱 클래스(static class)와 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있는 내부 클래스(inner class)로 구분된다.</p><p>내부 클래스는 다시 범위(scope)에 따라 세가지로 구분된다.</p><ul><li>멤버 내부 클래스 : 멤버 필드처럼 오브젝트 레벨에 정의된다.</li><li>로컬 클르스 : 메소드 레벨에 정의된다.</li><li>익명 내부 클래스 : 이름을 갖지 않는 익명 클래스이다. 익명 내부 클래스의 범위는 선언된 위치에 따라서 다르다.</li></ul></blockquote><p>로컬 클래스의 장점은 클래스가 내부 클래스이기 때문에 자신이 선언된 곳의 정보에 접근할 수 있다는 것이다. 내부 메소드는 자신이 정의된 메소드의 로컬 변수에 직접 접근할 수 있기 때문이다. <strong>다만, 내부 클래스에서 외부의 변수를 사용할 때는 외부 변수는 반드시 final로 선언해줘야 한다.</strong></p><p><strong>로컬 클래스로 만들어두니, 메소드마다 추가해야 했던 클래스 파일을 하나 줄일 수 있고 내부 클래스의 특징을 이용해 로컬 변수를 바로 가져다 사용할 수 있다는 장점도 생겼다.</strong></p><h4 id="익명-내부-클래스">익명 내부 클래스</h4><blockquote><p><strong>익명 내부 클래스</strong></p><p>익명 내부 클래스(anonymous inner class)는 이름을 갖지 않는 클래스다. 클래스 선언과 오브젝트 생성이 결합된 상태로 만들어지며, 상속할 클래스나 구현할 인터페이스를 생성자 대신 사용해서 다음과 같은 형태로 만들어 사용한다. 클래스를 재사용할 필요가 없고, 구현한 인터페이스 타입으로만 사용할 경우에 유용하다.</p><p>new 인터페이스이름() { 클래스 본문 };</p></blockquote><p>익명 내부 클래스는 선언과 동시에 오브젝트를 생성한다. 이름이 없기 때문에 클래스 자신의 타입을 가질 수 없고, 구현한 인터페이스 타입의 변수에만 저장할 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StatementStrategy st = <span class="keyword">new</span> StatementStrategy() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">makePreparedStatement</span><span class="params">(Connection c)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">PreparedStatement ps = c.prepareStatement(<span class="string">"insert into users(id, name, password) values(?,?,?)"</span>);</span><br><span class="line">        ps.setString(<span class="number">1</span>, user.getId());</span><br><span class="line">        ps.setString(<span class="number">2</span>, user.getName());</span><br><span class="line">        ps.setString(<span class="number">3</span>, user.getPassword());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>만들어진 익명 내부 클래스의 오브젝트는 딱 한 번만 사용할 테니 굳이 변수에 담아두지 말고 jdbcContextWithStatementStrategy() 메소드의 파라미터에서 바로 생성하는 편이 낫다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> User user)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">jdbcContextWithStatementStrategy(</span><br><span class="line">        <span class="keyword">new</span> StatementStrategy() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">makePreparedStatement</span><span class="params">(Connection c)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                PreparedStatement ps = c.prepareStatement(<span class="string">"insert into users(id, name, password) values(?,?,?)"</span>);</span><br><span class="line">                ps.setString(<span class="number">1</span>, user.getId());</span><br><span class="line">                ps.setString(<span class="number">2</span>, user.getName());</span><br><span class="line">                ps.setString(<span class="number">3</span>, user.getPassword());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ps;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="컨텍스트와-di">컨텍스트와 DI</h2><p>전략 패턴의 구조로 보자면 UserDao의 메소드가 클라이언트이고, 익명 내부 클래스로 만들어지는 것이 개별적인 전략이고, jdbcContextWithStatementStrategy() 메소드는 컨텍스트다. 그런데 JDBC의 일반적인 작업 흐름을 담고 있는 jdbcContextWithStatementStrategy()는 다른 DAO에서도 사용 가능하다. 그러니 jdbcContextWithStatementStrategy()를 UserDao 클래스 밖으로 독립시켜서 모든 DAO가 사용할 수 있게 해야한다.</p><h3 id="클래스-분리">클래스 분리</h3><p>분리해서 만들 클래스의 이름을 JdbcContext라고 하자. JdbcContext에 UserDao에 있던 컨텍스트 메소드를 workWithStatementStrategy()라는 이름으로 옮겨놓는다. 그런데, 이렇게 하면 DataSource가 필요한 것은 UserDao가 아니라 JdbcContext가 돼버린다. DB 커넥션을 필요로 하는 코드는 JdbcContext 안에 있기 때문이다. 따라서 JdbcContext가 DataSource에 의존하고 있으므로 DataSource 타입 빈을 DI 받을 수 있게 해줘야 한다.</p><h3 id="빈-의존관계-변경">빈 의존관계 변경</h3><p>UserDao는 이제 JdbcContext에 의존한다. 그런데 JdbcContext는 인터페이스인 DataSource와는 달리 구체 클래스다. 스프링의 DI는 기본적으로 인터페이스를 사이에 두고 의존 클래스를 바꿔서 사용하도록 하는게 목적이다. 하지만 이 경우 JdbcContext는 그 자체로 독립적인 JDBC 컨텍스트를 제공해주는 서비스 오브젝트로서 의미가 있을 뿐이고 구현 방법이 바뀔 가능성은 없다. 따라서 인터페이스를 구현하지 않고, UserDao와 JdbcContext는 인터페이스를 사이에 두지 않고 DI를 적용하는 특별한 구조가 된다.</p><h3 id="스프링-빈으로-di">스프링 빈으로 DI</h3><p>인터페이스를 사용해서 클래스를 자유롭게 변경할 수 있게 하지는 않았지만,  JdbcContext를 UserDao와 DI 구조로 만들어야 할 이유는 다음과 같다.</p><ol><li>JdbcContext가 스프링 컨테이너의 싱글톤 레지스트리에서 관리되는 싱글톤 빈이 되기 때문이다.</li><li>JdbcContext가 DI를 통해 다른 빈에 의존하고 있기 때문이다. JdbcContext는 dataSource 프로퍼티를 통해 DdbcContext 오브젝트를 주입받도록 되어 있다. DI를 위해서는 주입되는 오브젝트와 주입받는 오브젝트 양쪽 모두 스프링 빈을 등록돼야 한다. 스프링이 생성하고 관리하는 IoC 대상이어야 DI에 참여할 수 있기 때문이다.</li></ol><h2 id="템플릿과-콜백">템플릿과 콜백</h2><p><strong>전략 팬턴은 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고 그중 일부분만 자주 바꿔서 사용해야 하는 경우에 적합한 구조다. 전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식이다. 이런 방식을 스프링에서는 <code>템플릿/콜백 패턴</code>이라고 부른다.</strong> 전략 패턴의 컨텍스트를 템플릿이라 부르고, 익명 내부 클래스로 만들어지는 오브젝트를 콜백이라고 부른다.</p><blockquote><p><strong>템플릿</strong></p><p>템플릿은 어떤 목적을 위해 미리 만들어둔 모양이 있는 틀을 가리킨다. 템플릿 메소드 패턴은 고정된 틀의 로직을 가진 템플릿 메소드를 슈퍼클래스에 두고, 바뀌는 부분을 서브클래스의 메소드에 두는 구조로 이뤄진다.</p><p><strong>콜백</strong></p><p>콜백은 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트를 말한다. 자바에서는 메소드 자체를 파라미터로 전달할 방법이 없기 때문에 메소드가 담긴 오브젝트를 전달해야 한다. 그래서 펑서녈 오브젝트(functional object)라고도 한다.</p></blockquote><h3 id="템플릿콜백의-동작원리">템플릿/콜백의 동작원리</h3><p><strong>템플릿은 고정된 작업 흐름을 가진 코드를 재사용한다는 의미에서 붙인 이름이다. 콜백은 템플릿 안에서 호출되는 것을 목적으로 만들어진 오브젝트를 말한다.</strong></p><h4 id="템플릿콜백의-특징">템플릿/콜백의 특징</h4><p>여러 개의 메소드를 가진 일반적인 인터페이스를 사용할 수 있는 전략 패턴의 전략과 달리 템플릿/콜백 패턴의 콜백은 보통 단일 메소드 인터페이스를 사용한다. 템플릿의 작업 흐름 중 특정 기능을 위해 한 번 호출되는 경우가 일반적이기 때문이다. <strong>콜백은 일반적으로 하나의 메소드를 가진 인터페이스를 구현한 익명 내부 클래스로 만들어진다고 보면된다.</strong></p><p>템플릿/콜백 패턴의 일반적인 작업 흐름은 다음과 같다.</p><ul><li>클라이언트의 역할은 템플릿 안에서 실행될 로직을 담은 콜백 오브젝트를 만들고, 콜백이 참조할 정보를 제공하는 것이다. 만들어진 콜백은 클라이언트가 템플릿의 메소드를 호출할 때 파라미터로 전달된다.</li><li>템플릿은 정해진 작업 흐름을 따라 작업을 진행하다가 내부에서 생성한 참조정보를 가지고 콜백 오브젝트의 메소드를 호출한다. 콜백은 클라이언트 메소드에 있는 정보와 템플릿이 제공한 참조정보를 이용해서 작업을 수행하고 그 결과를 다시 템플릿에 돌려준다.</li><li>템플릿은 콜백이 돌려준 정보를 사용해서 작업을 마저 수행한다. 경우에 따라 최종 결과를 클라이언트에 다시 돌려주기도 한다.</li></ul><p><strong>템플릿/콜백 방식은 전략 패턴과 DI의 장점을 익명 내부 클래스 사용 전략과 결합한 독특한 활용법이라고 이해할 수 있다.</strong> 단순히 전략 패턴으로만 보기엔 독특한 특징이 많으므로 템플릿/콜백을 하나의 고유한 패턴으로 기억해두면 좋다.</p><h3 id="편리한-콜백의-재활용">편리한 콜백의 재활용</h3><p>템플릿/콜백 방식에서 한 가지 아쉬운 점이 있다. DAO 메소드에서 매번 익명 내부 클래스를 사용하기 때문에 상대적으로 코드를 작성하고 읽기가 조금 불편하다는 점이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    executeSql(<span class="string">"delete from users"</span>); <span class="comment">// 변하는 SQL 문장</span></span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeSql</span><span class="params">(<span class="keyword">final</span> String query)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.jdbcContext.workWithStatementStrategy(</span><br><span class="line">        <span class="keyword">new</span> StatementStrategy() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">makePreparedStatement</span><span class="params">(Connection c)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> c.prepareStatement(query);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>바뀌지 않는 모든 부분을 빼내서 executeSql() 메소드로 만들었다. 바뀌는 부분인 SQL 문장만 파라미터로 받아서 사용하게 만들었다. <strong>SQL을 담은 파라미터를 final로 선언해서 익명 내부 클래스인 콜백 안에서 직접 사용할 수 있게 하는 것만 주의하면 된다.</strong></p><p>이렇게 재사용 가능한 콜백을 담고 있는 메소드라면 DAO가 공유할 수 있는 템플릿 클래스 안으로 옮겨도 된다. 그 결과 결국 JdbcContext 안에 클라이언트와 템플릿, 콜백이 모두 함께 공존하면서 동작하는 구조가 됐다.</p><h3 id="템플릿콜백의-응용">템플릿/콜백의 응용</h3><p>고정된 작업 흐름을 갖고 있으면서 여기저기서 자주 반복되는 코드가 있다면, 중복되는 코드를 분리할 방법을 생각해보는 습관을 기르자. 중복된 코드는 먼저 메소드로 분리하는 간단한 시도를 해본다. 그중 일부 작업을 필요에 따라 바꾸어 사용해야 한다면 인터페이스를 사이에 두고 분리해서 전략패턴을 적용하고 DI로 의존관계를 관리하도록 만든다. 그런데 바뀌는 부분이 한 애플리케이션 안에서 동시에 여러 종류가 만들어질 수 있다면 이번엔 템플릿/콜백 패턴을 적용하는 것을 고려해볼 수 있다.</p><p>가장 전형적인 템플릿/콜백 패턴의 후보는 try/catch/finally 블록을 사용하는 코드다.</p><p><strong>템플릿/콜백을 적용할 때는 템플릿과 콜백의 경계를 정하고 템플릿이 콜백에게, 콜백이 템플릿에게 각각 전달하는 내용이 무엇인지 파악하는게 가장 중요하다. 그에 따라 콜백의 인터페이스를 정의해야 하기 때문이다.</strong></p><p>클래스 이름이 Template으로 끝나거나 인터페이스 이름이 Callback으로 끝난다면 템플릿/콜백이 적용된 것이라고 보면 된다.</p><h2 id="정리">정리</h2><ul><li>JDBC와 같은 예외가 발생할 가능성이 있으며 공유 리소스의 반환이 필요한 코드는 반드시 try/catch/finally 블록으로 관리해야 한다.</li><li>일정한 작업 흐름이 반복되면서 그중 일부 기능만 바뀌는 코드가 존재한다면 전략 패턴을 적용한다. 바뀌지 않는 부분을 컨텍스트로, 바뀌는 부분은 전략으로 만들고 인터페이스를 통해 유연하게 전략을 변경할 수 있도록 구성한다.</li><li>클라이언트 메소드 안에 익명 내부 클래스를 사용해서 전략 오브젝트를 구현하면 코드도 간결해지고 메소드의 정보를 직접 사용할 수 있어서 편리하다.</li><li>컨텍스트가 하나 이상의 클라이언트 오브젝트에서 사용된다면 클래스를 분리해서 공유하도록 만든다.</li><li>단일 전략 메소드를 갖는 전략 패턴이면서 익명 내부 클래스를 사용해서 매번 전략을 새로 만들어 사용하고, 컨텍스트 호출과 동시에 전략 DI를 수행하는 방식을 템플릿/콜백 패턴이라고 한다.</li><li>콜백의 코드에도 일정한 패천이 반복된다면 콜백을 템플릿에 넣고 재활용하는 것이 편리하다.</li><li>템플릿과 콜백의 타입이 다양하게 바뀔 수 있다면 제네릭스를 이용한다.</li><li>템플릿은 한 번에 하나 이상의 콜백을 사용할 수도 있고, 하나의 콜백을 여러 번 호출할 수도 있다.</li><li>템플릿/콜백을 설계할 때는 템플릿과 콜백 사이에 주고받는 정보에 관심을 둬야한다.</li></ul><h1 id="참고">참고</h1><p><a href="http://www.acornpub.co.kr/book/toby-spring3.1-vol1" target="_blank" rel="noopener">토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;템플릿&quot;&gt;템플릿&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;개방 폐쇄 원칙 (OCP)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;어떤 부분은 변경을 통해 그 기능이 다양해지고 확장하려는 성질이 있고, 어떤 부분은 고정되어 있고 변하지 않으려는
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Spring" scheme="https://jongmin92.github.io/categories/Programming/Spring/"/>
    
    
      <category term="Spring" scheme="https://jongmin92.github.io/tags/Spring/"/>
    
      <category term="Toby" scheme="https://jongmin92.github.io/tags/Toby/"/>
    
      <category term="Context &amp; DI" scheme="https://jongmin92.github.io/tags/Context-DI/"/>
    
      <category term="Template &amp; Callback" scheme="https://jongmin92.github.io/tags/Template-Callback/"/>
    
  </entry>
  
  <entry>
    <title>PR(Pull Request) merge</title>
    <link href="https://jongmin92.github.io/2018/03/31/Git/pull-request-merge/"/>
    <id>https://jongmin92.github.io/2018/03/31/Git/pull-request-merge/</id>
    <published>2018-03-30T18:00:00.000Z</published>
    <updated>2018-04-01T12:09:29.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="prpull-request-merge">PR(Pull Request) merge</h1><p>보통 upstream의 repository를 fork한 후, origin에서 feature branch를 만들어 작업한 후 작업이 완료되면 upstream branch에 반영하기 위해 pull request를 요청해 merge 합니다. (upstream repository에 push 권한이 있는 사람이 merge를 완료할 수 있습니다.)</p><p>merge conflict가 없다면 pull request를 GitHub에서 merge 할 수 있습니다. 만약, pull request를 merge 할 때, conflict가 있다거나 merge를 하기전에 테스트를 하고 싶다면 command line을 이용해 local에서 pull request를 check out하고 merge할 수 있습니다.</p><p>만약, upstream branch에 merge를 원하지 않는다면 pull request를 merge 하지 않고 종료(close)할 수도 있습니다.</p><p><strong>pull request를 merge 할 때는 (1)Feature branch의 모든 커밋을 유지하거나 (2)모든 커밋을 단일 커밋으로 squash하거나 (3)각각의 커밋을 rebase해서 pull request를 merge 할 수 있습니다.</strong> 3가지 방법에 대해서 알아보겠습니다.</p><h2 id="merging-a-pull-request-on-github">Merging a pull request on GitHub</h2><p>GitHub repository에서 사용할 수 있는 merge option은 다음과 같습니다.</p><ul><li>Create a merge commit</li><li>Squash and merge</li><li>Rebase and merge</li></ul><h3 id="create-a-merge-commit">Create a merge commit</h3><blockquote><p>All commits from this branch will be added to the base branch via a merge commit.</p></blockquote><p><img src="/images/post/2018-03-31/pr1.png" alt=""></p><p><strong>default 옵션인 <code>Create a merge commit</code> 은 feature branch의 모든 커밋을 base branch에 merge 커밋으로 추가합니다.</strong> 해당 pull request는 <strong>—no-ff</strong> 옵션을 사용해 merge됩니다.</p><blockquote><p><strong>—no-ff</strong></p><p>fast-forward(ff)가 가능하지만 fast-forward를 하지 않고, merge 커밋을 생성합니다.</p></blockquote><h3 id="squash-and-merge">Squash and merge</h3><blockquote><p>The 4 commits from this branch will be combined into one commit in the base branch.</p></blockquote><p><img src="/images/post/2018-03-31/pr2.png" alt=""></p><p><strong><code>Squash and merge</code> 옵션을 선택하면, pull request의 커밋들이 하나의 커밋으로 squash(압축)됩니다.</strong> 즉, topic branch에서 contributor가 작업한 모든 커밋은 하나의 커밋으로 결합되어 base branch로 merge됩니다. 해당 pull request는 <strong>--ff</strong> 옵션을 사용해 merge합니다.</p><blockquote><p><strong>—ff</strong></p><p>fast-forward(ff)로 merge가 된다면, 새로운 merge 커밋을 만들지 않습니다.</p></blockquote><p>Squash and merge는 repository에서 git history를 조금 더 간소화되게 만들 수 있습니다. (Create a merge commit 옵션 과 비교해보면 새로운 merge 커밋이 없습니다.)</p><h3 id="rebase-and-merge">Rebase and merge</h3><blockquote><p>The 4 commits from this branch will be released and added to the base branch.</p></blockquote><p><strong><code>Rebase and merge</code> 옵션을 선택하면, pull request의 커밋들을 하나의 커밋으로 병합하지 않고 개별적으로 base branch에 추가됩니다.</strong> 해당 pull request는 <strong>--ff</strong> 옵션을 사용해 merge합니다.</p><blockquote><p>GitHub에서의 Rebase and merge는 git의 rebase와는 조금 다릅니다. GitHub의 Rebase and merge는 항상 committer의 정보를 업데이트하고 새로운 commit SHA를 생성하지만, git의 rebase는 조상 commit 후에 rebase를 할 경우 committer의 정보를 변경하지 않습니다.</p></blockquote><p>만약, conflict로 인해 GitHub에서 자동적으로 Rebase and merge를 할 수 없다면,  local에서 직접 command line을 이용해서 rebase를 하고 merge conflict를 해결해야 합니다. 그 후 pull request의 topic branch에 Force-push를 하면됩니다.</p><h2 id="참고">참고</h2><ul><li><a href="https://help.github.com/articles/about-pull-request-merges/" target="_blank" rel="noopener">About pull request merges</a></li><li><a href="https://help.github.com/articles/merging-a-pull-request/" target="_blank" rel="noopener">Merging a pull request</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;prpull-request-merge&quot;&gt;PR(Pull Request) merge&lt;/h1&gt;
&lt;p&gt;보통 upstream의 repository를 fork한 후, origin에서 feature branch를 만들어 작업한 후 작업이 완료되면 u
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Git" scheme="https://jongmin92.github.io/categories/Programming/Git/"/>
    
    
      <category term="Git" scheme="https://jongmin92.github.io/tags/Git/"/>
    
      <category term="Pull Request" scheme="https://jongmin92.github.io/tags/Pull-Request/"/>
    
      <category term="Create a merge commit" scheme="https://jongmin92.github.io/tags/Create-a-merge-commit/"/>
    
      <category term="Squash and merge" scheme="https://jongmin92.github.io/tags/Squash-and-merge/"/>
    
      <category term="Rebase and merge" scheme="https://jongmin92.github.io/tags/Rebase-and-merge/"/>
    
  </entry>
  
  <entry>
    <title>tail -f 보다 효율적인 less +F에 대해 알아보자</title>
    <link href="https://jongmin92.github.io/2018/03/29/Linux%20&amp;%20Ubuntu/less/"/>
    <id>https://jongmin92.github.io/2018/03/29/Linux &amp; Ubuntu/less/</id>
    <published>2018-03-28T15:30:00.000Z</published>
    <updated>2018-03-28T15:53:17.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stop-using-tail-f">Stop using tail -f</h1><p>얼마전 tail -f를사용하며 스크롤 기능을 사용하고 싶어 검색하던 중 less +F를 알게 되었습니다. less +F에 대해 잘 설명한 글이 있어 번역해보려 합니다. 해당 글은 <a href="https://www.brianstorti.com/stop-using-tail/" target="_blank" rel="noopener">Stop using tail -f (mostly)</a> 에서 볼 수 있습니다.</p><p>파일의 변화를 실시간으로 모니터링하기 위해 여전히 많은 사람들이 <code>tail -f</code>를 사용하고 있습니다. tail-f 보다 <code>less +F</code> 를 사용하는게 조금 더 나은 방법이 될 수 있습니다.</p><p><code>less</code> documentation에서 <code>+F</code>에 대해 잘 설명하고 있습니다.</p><blockquote><p>Scroll forward, and keep trying to read when the end of file is reached. Normally this command would be used when already at the end of the file. It is a way to monitor the tail of a file which is growing while it is being viewed. (The behavior is similar to the “tail -f” command.)</p></blockquote><p><code>tail -f</code> 명령어와 비슷하다고 하는데, 어떤 점에서 더 좋을까요?</p><p>간단하게, less +F를 사용하면 <strong>navigation과 watching 모드 사이를 쉽게 변경할 수 있습니다.</strong> tail -f를 사용하셨던 분들은 아마 file을 실시간으로 모니터링하면서 해당 파일에서 무언가를 검색하거나 위, 아래로 이동하고 싶었던 적이 있을것 입니다. 그럴때마다 tail 명령어를 종료하거나 새로운 shell로 vim을 통해 문제를 해결했을 것입니다. 그러나 less 명령어를 사용하면 더이상 그런 번거로운 수고를 할 필요 없습니다.</p><p><code>production.log</code> 라는 파일을 모니터링한다고 가정해 보겠습니다.</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ less +F production.log</span><br><span class="line"></span><br><span class="line">Important</span><br><span class="line"><span class="built_in">log</span></span><br><span class="line">information</span><br><span class="line">here</span><br><span class="line"></span><br><span class="line">Waiting <span class="keyword">for</span> data... (interrupt to abort)</span><br></pre></td></tr></table></figure></p><p>tail 명령어와 결과가 비슷한것 같지만, <code>Ctrl-c</code>를 눌러 <strong>normal</strong> less 모드로 변경할 수 있습니다. +F 플래그 없이 파일을 오픈한 것과 같은 모드입니다. 그 후, normal less 모드에서 사용할 수 있는 기능들을 똑같이 사용할 수 있습니다. <code>/foo</code>를 검색한다던가, 검색 결과를 <code>n</code> 또는 <code>N</code>을 통해 이동할 수 있습니다. 또한 <code>j</code>와 <code>k</code>를 통해 라인을 이동할 수도 있습니다. 추가적으로 <code>m</code>을 통해 마크도 생성할 수 있습니다.</p><p>필요한 작업을 모두 끝내고 나면, <code>F</code>를 눌러 다시 모니터링 모드로 돌아갈 수 있습니다.</p><h1 id="when-not-to-use-less">When not to use less</h1><p>동시에 여러개의 파일을 모니터링 해야하는 경우에는 <code>tail -f</code>가 조금 더 나을 수 있습니다.</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f *.txt</span><br><span class="line"></span><br><span class="line">==&gt; file1.txt &lt;==</span><br><span class="line">content <span class="keyword">for</span> first file</span><br><span class="line"></span><br><span class="line">==&gt; file2.txt &lt;==</span><br><span class="line">content <span class="keyword">for</span> second file</span><br><span class="line"></span><br><span class="line">==&gt; file3.txt &lt;==</span><br><span class="line">content <span class="keyword">for</span> third file</span><br></pre></td></tr></table></figure></p><p>변경이 발생할 때, 파일 이름과 새로운 내용이 보이기 때문에 매우 편리합니다.</p><p>그러나, <code>less</code>의 경우에는 다음처럼 출력됩니다.</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ less +F *.txt</span><br><span class="line"></span><br><span class="line">content <span class="keyword">for</span> first file</span><br></pre></td></tr></table></figure></p><p>less는 동시에 오직 하나의 파일 내용만 볼 수 있으며, 2번째 파일을 보고 싶을 경우 <code>Ctrl-c</code>로 normal mode로 변환 후 <code>:n</code>을 눌러 다음 buffer로 이동해야 합니다. 그 후 다시 <code>F</code>를 눌러 모니터링 모드로 돌아가면 됩니다.</p><p>필요와 경우에 따라서, <code>less</code>와 <code>tail</code>을 잘 사용하면 조금 더 효율적인 작업을 할 수 있을것 입니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stop-using-tail-f&quot;&gt;Stop using tail -f&lt;/h1&gt;
&lt;p&gt;얼마전 tail -f를사용하며 스크롤 기능을 사용하고 싶어 검색하던 중 less +F를 알게 되었습니다. less +F에 대해 잘 설명한 글이 있어 번역해
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Linux &amp; Ubuntu" scheme="https://jongmin92.github.io/categories/Programming/Linux-Ubuntu/"/>
    
    
      <category term="Linux &amp; Ubuntu" scheme="https://jongmin92.github.io/tags/Linux-Ubuntu/"/>
    
      <category term="File monitoring" scheme="https://jongmin92.github.io/tags/File-monitoring/"/>
    
      <category term="tail -f" scheme="https://jongmin92.github.io/tags/tail-f/"/>
    
      <category term="less +F" scheme="https://jongmin92.github.io/tags/less-F/"/>
    
  </entry>
  
  <entry>
    <title>토비의 스프링 2장 (테스트)</title>
    <link href="https://jongmin92.github.io/2018/03/26/Spring/toby-2/"/>
    <id>https://jongmin92.github.io/2018/03/26/Spring/toby-2/</id>
    <published>2018-03-25T15:50:00.000Z</published>
    <updated>2018-03-28T14:56:32.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="테스트">테스트</h1><p>스프링이 개발자에게 제공하는 가장 중요한 가치는 객체지향과 테스트이다.</p><p>테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다. 또한 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알수 있다. 이를 통해 코드의 결함을 제거해가는 작업, 디버깅을 거치게 되고, 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확신을 얻을 수 있다.</p><p>보통 웹 프로그램에서 사용하는 DAO를 테스트 하는 방법은 다음과 같다. DAO를 만든 뒤 바로 테스트하지 않고, 서비스 계층, MVC 프레젠테이션 계층까지 포함한 모든 입출력 기능을 대충이라도 코드로 다 만든다. 이렇게 만들어진 테스트 용 웹 애플리케이션을 서버에 배치한 뒤, 웹 화면을 띄워 폼을 열고, 값을 입력한 뒤 버튼을 눌러 등록해본다.</p><p>이렇게 웹 화면을 통해 값을 입력하고, 기능을 수행하고, 결과를 확인하는 방법은 가장 흔하게 쓰이는 방법이지만 단점이 너무 많다. <strong>테스트를 하는 중에 에러가 나거나 테스트가 실패했다면, 과연 어디에서 문제가 발생했는지를 찾아내야 하는 수고도 필요하다. 하나의 테스트를 수행하는 데 참여하는 클래스와 코드가 너무 많기 때문이다.</strong></p><p>테스트를 하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다. 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다. <strong><code>관심사의 분리</code>라는 원리가 여기에도 적용된다. 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야한다.</strong></p><p>작은 단위의 코드에 대해 테스트를 수행한 것을 <code>단위 테스트(Unit test)</code>라고 한다. 여기서 말하는 단위란 그 크기와 범위가 어느 정도인지 딱 정해진 건 아니다. 충분히 하나의 관심에 집중해서 효율적으로 텧스트할 만한 범위의 단위라고 보면 된다.</p><p><strong>일반적으로 단위는 작을수록 좋다.</strong> 단위를 넘어서는 다른 코드들은 신경 쓰지 않고, 참여하지도 않고 테스트가 동작할 수 있으면 좋다. 그런 차원에서 통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 보기도 한다.</p><p>단위 테스트를 하는 이유는 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서다. 이때 확인의 대상과 조건이 간단하고 명확할수록 좋다.</p><p><strong>테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다. 그렇게 되면 자주 반복할 수 있다는 장점을 얻을 수 있다.</strong> 테스트 자체가 사람의 수작업을 거치는 방법을 사용하기 보다는 코드로 만들어져서 자동으로 수행될 수 있어야 한다는 건 매우 중요하다. 그런데 애플리케이션을 구성하는 클래스 안에 테스트 코드를 포함시키는 것보다는 별도로 테스트용 클래스를 만들어서 테스트 코드를 넣는 편이 낫다.</p><p>테스트를 이용하면 새로운 기능도 기대한 대로 동작하는지 확인할 수 있을 뿐 아니라, 기존에 만들어뒀던 기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 여전히 잘 동작하는지를 확인할 수도 있다.</p><h2 id="테스트-검증의-자동화">테스트 검증의 자동화</h2><p>모든 테스트는 성공과 실패의 두 가지 결과를 가질 수 있다. 또 테스트의 실패는 테스트가 진행되는 동안에 에러가 발생해서 실패하는 경우와, 테스트 작업 중에 에러가 발생하진 않았지만 그 결과가 기대한 것과 다르게 나오는 경우로 구분해볼 수 있다. 여기서 전자를 <strong>테스트 에러</strong>, 후자를 <strong>테스트 실패</strong>로 구분할 수 있다.</p><p><strong>테스트 중에 에러가 발생하는 것은 쉽게 확인이 가능하다. 콘솔에 에러 메시지와 긴호출 스택 정보가 출력되기 때문이다. 하지만 테스트가 실패하는 것은 별도의 확인 작업과 그 결과가 있어야만 알 수 있다.</strong></p><p>자바에는 단순하면서도 실용적인 테스트를 위한 도구가 여러 가지 존재한다. <strong><code>JUnit</code>은 이름 그대로 자바로 단위 테스트를 만들 때 유용하게 쓸 수 있다.</strong></p><p><strong>JUnit은 프레임워크다.</strong> 프레임워크는 개발자가 만든 클래스에 대한 제어 권한을 넘겨받아서 주도적으로 애플리케이션의 흐름을 제어한다. 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다. 따라서 프레임워크에서 동작하는 코드는 main() 메소드도 필요 없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.</p><p>main() 메소드 테스트는 그런면에서 프레임워크에 적용하기엔 적합하지 않다. 테스트가 main() 메소드로 만들어졌다는 건 제어권을 직접 갖는다는 의미이기 때문이다. 그래서 가장 먼저 할 일은 main() 메소드에 있던 테스트 코드를 일반 메소드로 옮기는 것이다. 새로 만들 테스트 메소드는 JUnit 프레임워크가 요구하는 조건 두가지를 따라야 한다. <strong>첫째는 메소드가 <code>public</code>으로 선언돼야 하는 것이고, 다른 하나는 메소드에 <code>@Test</code>라는 애노테이션을 붙여주는 것이다.</strong></p><p><strong>JUnit은 하나의 클래스 안에 여러 개의 테스트 메소드가 들어가는 것을 허용한다. @Test가 붙어있고 public 접근자가 있으며 리턴 값이 void 형이고 파라미터가 없다는 조건을 지키기만 하면된다.</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> GenericXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="검증-코드-변환">검증 코드 변환</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!user.getName().equals(user2.getName())) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>이 if 문장의 기능을 JUnit이 제공해주는 assertThat이라는 스태틱 메소드를 이용해 다음과 같이 변경할 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertThat(user2.getName(), is(user.getName()));</span><br></pre></td></tr></table></figure></p><p><strong><code>assertThat()</code> 메소드는 첫 번째 파라미터의 값을 뒤에 나오는 <code>매처(matcher)</code>라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어 준다. <code>is()</code>는 매처의 일종으로 equals()로 비교해주는 기능을 가졌다.</strong></p><p><strong>JUni은 예외가 발생하거나 assertThat()에서 실패하지 않고 테스트 메소드의 실행이 완료되면 테스트가 성공했다고 인식한다.</strong></p><h3 id="junit-테스트-실행">JUnit 테스트 실행</h3><p>스프링 컨테이너와 마찬가지로 JUnit 프레임워크도 자바 코드로 만들어진 프로그램이므로 어디선가 한 번은 JUnit 프레임워크를 시작시켜 줘야 한다.</p><p><strong>어디에든 main() 메소드를 하나 추가하고, 그 안에 <code>JUnitCore</code> 클래스의 main 메소드를 호출해주는 간단한 코드를 넣어주면 된다. 메소드 파라미터에는 @Test 테스트 메소드를 가진 클래스의 이름을 넣어준다.</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.jUnitCore;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JUnitCore.main(<span class="string">"Springbook.user.dao.UserDaoTest"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JUnit은 assertThat()을 이용해 검증을 했을 때 기대한 결과가 아니면 이 **<code>AssertionError</code>**를 던진다. 또한 테스트 수행 중에 일반 예외가 발생한 경우에도 마찬가지로 테스트 수행은 중단되고 테스트는 실패한다.</p><h2 id="junit">JUnit</h2><p>JUnit은 사실상 자바의 표준 테스팅 프레임워크라고 불릴만큼 폭넓게 사용되고 있다. <strong>스프링의 핵심 기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다.</strong> 또, 테스트 작성시 자주 필요한 편리한 여러 가지 부가기능도 제공한다. 대부분의 자바 IDE는 JUnit 테스트를 손쉽게 실행할 수 있는 JUnit 테스트 지원 기능을 내장하고 있어서 더욱 편리하게 JUnit 테스트를 만들고 활용할 수 있게 해준다.</p><h3 id="junit-테스트-실행-방법">JUnit 테스트 실행 방법</h3><p>JUnitCore를 이용해 테스트를 실행하고 콘솔에 출력된 메시지를 보고 결과를 확인하는 방법은 가장 간단하긴 하지만 테스트의 수가 많아지면 관리하기가 힘들어진다는 단점이 있다. <strong>가장좋은 JUnit 테스트 실행 방법은 자바 IDE에 내장된 JUnit 테스트 지원 도구를 사용하는 것이다.</strong> IDE를 사용하면 JUnitCore를 이용할 때처럼 main() 메소드를 만들지 않아도 된다.</p><p>JUnit은 한 번에 여러 테스트 클래스를 동시에 실행할 수도 있다. 패키지 아래에 있는 모든 JUnit 테스트를 한 번에 실행할 수도 있고, 소스 폴더나 프로젝트 전체를 선택해서 모든 테스트를 한 번에 실행할 수도 있다. 이런 면에서 JUnitCore를 사용해 테스트를 실행하는 것보다 훨씬 편리하다.</p><p>주의해야 할 점은 여러개의 테스트가 어떤 순서로 실행될지는 알 수 없다. <strong>JUnit은 특정한 테스트 메소드의 실행 순서를 보장해주지 않는다.</strong> 테스트의 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다. 모든 테스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결과를 낼 수 있도록 해야 한다.</p><h4 id="빌드툴">빌드툴</h4><p><strong>프로젝트의 빌드를 위해 <code>ANT</code>나 <code>메이븐(Maven)</code>같은 빌드 툴과 스크립트를 사용하고 있다면, 빌드 툴에서 제공하는 JUnit 플러그인이나 태스크를 이용해 JUnit 테스트를 실행할 수 있다.</strong></p><p>여러 개발자가 만든 코드를 모두 통합해서 테스트를 수행해야 할 때도 있다. 이런 경우에는 서버에서 모든 코드를 가져와 통합하고 빌드한 뒤에 테스트를 수행하는 것이 좋다. 이때는 빌드 스크립트를 이용해 JUnit 테스트를 실행하고 그 결과를 메일 등으로 통보받는 방법을 사용하면 된다.</p><h3 id="포괄적인-테스트">포괄적인 테스트</h3><h4 id="예외조건에-대한-테스트">예외조건에 대한 테스트</h4><p>일반적으로는 테스트 중에 예외가 던져지면 테스트 메소드의 실행은 중단되고 테스트는 실패한다. assertThat()을 통한 검증 실패는 아니고 테스트 에러라고 볼 수 있다. 그런데 이번에는 반대로 테스트 진행 중에 특정 예외가 던져지면 테스트가 성공한 것이고, 예외가 던져지지 않고 정상적으로 작업을 마치면 테스트가 실패했다고 판단해야 한다. <strong>문제는 예외 발생 여부는 메소드를 실행해서 리턴 값을 비교하는 방법으로 확인할 수 없다는 점이다.</strong></p><p>그런데 바로 이런 경우를 위해 JUnit은 예외조건 테스트를 위한 특별한 방법을 제공해준다. @Test 애노테이션의 expected 엘리먼트다. <strong><code>expected</code>는 메소드 실행 중에 발생하리라 기대하는 예외 클래스를 넣어주면 된다.</strong></p><p><strong>@Test에 expected를 추가해놓으면 보통의 테스트와는 반대로, 정상적으로 테스트 메소드를 마치면 테스트가 실패하고, expected에서 지정한 예외가 던져지면 테스트가 성공한다. 예외가 반드시 발생해야 하는 경우를 테스트하고 싶을 때 유용하게 쓸 수 있다.</strong></p><h2 id="테스트가-이끄는-개발">테스트가 이끄는 개발</h2><h3 id="테스트-주도-개발">테스트 주도 개발</h3><p><strong>만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법이 있다. 이를 <code>테스트 주도 개발(TDD)</code>이라고 한다.</strong> 또는 테스트를 코드보다 먼저 작성한다고 해서 <code>테스트 우선 개발(Test First Development)</code>이라고도 한다.</p><p>&quot;실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다&quot;는 것이 TDD의 기본 원칙이다. TDD는 아예 테스트를 먼저 만들고 그 테스트가 성공하도록 하는 코드만 만드는 식으로 진행하기 때문에 테스트를 빼먹지 않고 꼼꼼하게 만들어낼 수 있다. 또한 <strong>TDD를 하면 자연스럽게 단위 테스트를 만들 수 있다.</strong></p><p><strong>TDD의 장점 중 하나는 코드를 만들어 테스트를 실행하는 그 사이의 간격이 매우 짧다는 점이다.</strong> 개발한 코드의 오류는 빨리 발견할수록 좋다. 빨리 발견된 오류는 쉽게 대응이 가능하기 때문이다. 테스트 없이 오랜 시간 동안 코드를 만들고 나서 테스트를 하면, 오류가 발생했을 때 원인을 찾기가 쉽지 않다.</p><h3 id="테스트-코드-개선">테스트 코드 개선</h3><p><strong>JUnit 프레임워크는 테스트 메소드를 실행할 때 부가적으로 해주는 작업이 몇 가지 있다. 그 중에서 테스트를 실행할 때마다 반복되는 준비 작업을 별도의 메소드에 넣게 해주고, 이를 매번 테스트 메소드를 실행하기 전에 먼저 실행시켜주는 기능이다.</strong> 이를 알기위해서는 JUnit 프레임워크가 테스트 메소드를 실행하는 과정을 알아야 한다.</p><p>JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다.</p><ol><li>테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.</li><li>테스트 클래스의 오브젝트를 하나 만든다.</li><li>@Before가 붙은 메소드가 있으면 실행한다.</li><li>@Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.</li><li>@After가 붙은 메소드가 있으면 실행한다.</li><li>나머지 테스트 메소드에 대해 2~5번을 반복한다.</li><li>모든 테스트의 결과를 종합해서 돌려준다.</li></ol><p><strong>JUnit은 @Test가 붙은 메소드를 실행하기 전과 후에 각각 @Before와 @After가 붙은 메소드를 자동으로 실행한다.</strong> 보통 하나의 테스트 클래스 안에 있는 테스트 메소드들은 공통적인 준비작업과 정리 작업이 필요한 경우가 많다. 이런 작업들을 @Before, @After가 붙은 메소드에 넣어두면 JUnit이 자동으로 메소드를 실행해주니 매우 편리하다.</p><p>대신 @Before나 @After 메소드를 테스트 메소드에서 직접 호출하지 않기 때문에 서로 주고받을 정보나 오브젝트가 있다면 인스턴스 변수를 이용해야 한다.</p><p><strong>또 한가지 기억해야 할 사항은 각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다는 것이다.</strong> 한번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메소드를 사용하고 나면 버려진다. 그렇기 때문에 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장할 수 있다. 덕분에 인스턴스 변수도 부담 없이 사용할 수 있다. 어차피 다음 테스트 메소드가 실행될 때는 새로운 오브젝트가 만들어져서 다 초기화될 것이다.</p><blockquote><p>픽스처</p><p><strong>테스트를 수행하는 데 필요한 정보나 오브젝트를 <code>픽스처(fixture)</code>라고 한다.</strong> 일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메소드를 이용해 생성해두면 편리하다.</p></blockquote><h2 id="스프링-테스트-적용">스프링 테스트 적용</h2><p>빈이 많아지고 복잡해지면 애플리케이션 컨텍스트 생성이 적지 않은 시간이 걸린다. <strong>애플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화한다.</strong> 또 한가지 문제는 애플리케이션 컨텍스트가 초기화될 때 어떤 빈은 독자적으로 많은 리스소를 할당하거나 독립적인 스레드를 띄우기도 한다는 것이다. 이런 경우에는 테스트를 마칠 때마다 애플리케이션 컨텍스트 내의 빈이 할당한 리소스 등을 깔끔하게 정리해주지 않으면 다음 테스트에서 새로운 애플리케이션 컨텍스트가 만들어지면서 문제를 일으킬 수도 있다.</p><p>다행히도 애플리케이션 컨텍스트는 초기화되고 나면 내부의 상태가 바뀌는 일은 거의 없다. 빈은 싱글톤으로 만들었기 때문에 상태를 갖지 않는다. 따라서 <strong>애플리케이션 컨텍스트는 한 번만 만들고 여러 테스트가 공유해서 사용해도 된다.</strong> 스프링이 직접 제공하는 애플리케이션 컨텍스트 지원 기능을 사용하면 애플리케이션을 한 번만 만들어 공유해 사용할 수 있다.</p><h3 id="테스트를-위한-애플리케이션-컨텍스트-관리">테스트를 위한 애플리케이션 컨텍스트 관리</h3><p><strong>스프링은 JUnit을 이용하는 테스트 컨택스트 프레임워크를 제공한다. 테스트 컨텍스트의 지원을 받으면 간단한 애노테이션 설정만으로 테스트에서 필요로 하는 애플리케이션 컨텍스트를 만들어서 모든 테스트가 공유하게 할 수 있다.</strong></p><p>먼저 ApplicationContext 타입의 인스턴스 변수를 선언하고 스프링이 제공하는 <code>@Autowired</code> 애노테이션을 붙인다. 마지막으로 클래스 레벨에 <code>@RunWith</code>와 <code>@ContextConfiguration</code> 애노테이션을 추가해준다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(location=<span class="string">"/applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>@RunWith</code>는 JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 어노테이션이다.</strong> SpringJUnit4ClassRunner라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.</p><p><strong><code>@ContextConfiguration</code>은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정한 것이다.</strong></p><p>context 변수에는 어떻게 애플리케이션 컨텍스트가 들어가 있을까? 스프링의 JUnit 확장기능은 테스트가 실행되기 전에 딱 한 번만 애플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해주는 것이다. 일종의 DI라고 볼 수 있는데, 애플리케이션 오브젝트 사이의 관계를 관리하기 위한 DI와는 조금 성격이 다르다.</p><p>이렇게 해서 하나의 테스트 클래스 내의 테스트 메소드는 같은 애플리케이션 컨텍스트를 공유해서 사용할 수 있다.</p><h3 id="테스트-클래스의-컨텍스트-공유">테스트 클래스의 컨텍스트 공유</h3><p>스프링 테스트 컨텍스트 프레임워크의 기능은 하나의 테스트 클래스 안에서 애플리케이션 컨텍스트를 공유해주는 것이 전부가 아니다. <strong>여러 개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다.</strong></p><p><strong>테스트 클래스마다 다른 설정파일을 사용하도록 만들어도 되고, 몇 개의 테스트에서만 다른 설정파일을 사용할 수도 있다. 스프링은 설정파일의 종류만큼 애플리케이션 컨텍스트를 만들고, 같은 설정파일을 지정한 테스트에서는 이를 공유하게 해준다.</strong></p><h3 id="autowired">@Autowired</h3><p><strong><code>@Autowired</code>는 스프링의 DI에 사용되는 특별한 애노테이션이다. @Autowired가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다.</strong> 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다. <strong>일반적으로는 주입을 위해서는 생성자나 수정자 메소드 같은 메소드가 필요하지만, 이 경우에는 메소드가 없어도 주입이 가능하다.</strong> 또 별도의 DI 설정 없이 필드의 타입정보를 이용해 빈을 자동으로 가져올 수 있는데, 이런 방법을 <code>타입에 의한 자동와이어링</code>이라고 한다.</p><p>스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록한다. 따라서 애플리케이션 컨텍스트에는 ApplicationContext 타입의 빈이 존재하는 것이고 DI도 가능하다.</p><p><strong>@Autowired를 이용해 애플리케이션 컨텍스트가 갖고 있는 빈을 DI 받을 수 있다면 굳이 컨텍스트를 가져와 getBean()을 사용하는 것이 아니라, 아예 빈을 직접 DI 받을 수도 있다.</strong> (@Autowired를 지정하기만 하면 어떤 빈이든 다 가져올 수 있다.)</p><p>@Autowired는 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾는다. 단, <strong>@Autowired는 같은 타입의 빈이 두 개 이상 있는 경우에는 타입만으로는 어떤 빈을 가져올지 결정할 수 없다.</strong> 타입으로 가져올 빈 하나를 선택할 수 없는 경우에는 변수의 이름과 같은 이름의 빈이 있는지 확인한다. 변수 이름으로도 빈을 찾을 수 없는 경우에는 예외가 발생한다.</p><p>테스트는 필요하다면 얼마든지 애플리케이션 클래스와 밀접한 관계를 맺고 있어도 상관없다. 개발자가 만드는 테스트는 코드 내부구조와 설정 등을 알고 있고 의도적으로 그 내용을 검증해야 할 필요가 있기 때문이다. 하지만 꼭 필요하지 않다면 테스트에서도 가능한 한 인터페이스를 사용해서 애플리케이션 코드와 느슨하게 연결해두는 편이 좋다.</p><h3 id="di와-테스트">DI와 테스트</h3><p>인터페이스를 통해 DI를 적용해야 하는 이유는 다음과 같다.</p><ul><li>소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문이다.</li><li>클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있기 때문이다.</li><li>테스트 때문이다.</li></ul><blockquote><p>SingleConnectionDataSource</p><p>스프링이 제공하는 가장 빠른 DataSource이다. DB 커넥션을 하나만 만들어두고 계속 사용하기 때문에 매우 빠르다. 다중 사용자 환경에서는 사용할 수 없겠지만 순차적으로 진행되는 테스트에서라면 문제없다.</p></blockquote><p>스프링 테스트 컨텍스트 프레임워크를 적용했다면 애플리케이션 컨텍스트는 테스트 중에 딱 한 개만 만들어지고 모든 테스트에서 공유해서 사용한다. 따라서 애플리케이션 컨텍스트의 구성이나 상태를 테스트 내에서 변경하지 않는 것이 원칙이다. 만약 한 번 변경하면 나머지 모든 테스트를 수행하는 동안 변경된 애플리케이션 컨텍스트가 계속 사용될 것이다. 이는 별로 바람직하지 못하다.</p><p>그럴때는 <code>@DirtiesContext</code>라는 애노테이션을 추가한다. <strong>이 애노테이션은 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려준다. 테스트 컨텍스트는 이 애노테이션이 붙은 테스트 클래스에는 애플리케이션 컨텍스트 공유를 허용하지 않는다. 테스트 메소드를 수행하고 나면 매번 새로운 애플리케이션 컨텍스트를 만들어서 다음 테스트가 사용하게 해준다.</strong> 테스트 중에 변경한 컨텍스트가 뒤의 테스트에 영향을 주지 않게하기 위해서다.</p><p>@DirtiesContext는 클래스에만 적용할 수 있는 건 아니다. <strong>하나의 메소드에서만 컨텍스트 상태를 변경한다면 메소드 레벨에 @DirtiesContext를 붙여주는 편이 낫다.</strong> 해당 메소드의 실행이 끝나고 나면 이후에 진행되는 테스트를 위해 변경된 애플리케이션 컨텍스트는 폐기되고 새로운 애플리케이션 컨텍스트가 만들어진다.</p><h3 id="테스트를-위한-별도의-di-설정">테스트를 위한 별도의 DI 설정</h3><p>테스트 코드에서 빈 오브젝트에 수동으로 DI 하는 방법은 장점보다 단점이 많다. 코드가 많아져 번거롭기도 하고 애플리케이션 컨텍스트도 매번 새로 만들어야 하는 부담이 있다.</p><p>그래서 테스트 전용 설정파일을 따로 만들어 사용하는 방법을 이용한다. 테스트에서는 항상 테스트 전용 설정파일만 사용하게 해주면 된다.</p><p>@ContextConfiguration 애노테이션에 있는 locations 엘리먼트의 값을 새로 만든 테스트용 설정파일로 변경해준다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations=<span class="string">"/test-applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><p><a href="http://www.acornpub.co.kr/book/toby-spring3.1-vol1" target="_blank" rel="noopener">토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;테스트&quot;&gt;테스트&lt;/h1&gt;
&lt;p&gt;스프링이 개발자에게 제공하는 가장 중요한 가치는 객체지향과 테스트이다.&lt;/p&gt;
&lt;p&gt;테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다. 
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Spring" scheme="https://jongmin92.github.io/categories/Programming/Spring/"/>
    
    
      <category term="Spring" scheme="https://jongmin92.github.io/tags/Spring/"/>
    
      <category term="Toby" scheme="https://jongmin92.github.io/tags/Toby/"/>
    
      <category term="JUnit" scheme="https://jongmin92.github.io/tags/JUnit/"/>
    
      <category term="Testing" scheme="https://jongmin92.github.io/tags/Testing/"/>
    
  </entry>
  
  <entry>
    <title>토비의 스프링 1장 (오브젝트와 의존관계)</title>
    <link href="https://jongmin92.github.io/2018/03/25/Spring/toby-1/"/>
    <id>https://jongmin92.github.io/2018/03/25/Spring/toby-1/</id>
    <published>2018-03-25T14:00:00.000Z</published>
    <updated>2018-03-28T14:56:32.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="스프링">스프링</h1><p>스프링은 자바 엔터프라이즈 애플리케이션 개발에 사용되는 프레임워크다. 애플리케이션 프레임워크는 애플리케이션 개발을 빠르고 효율적으로 할 수 있도록 애플리케이션의 바탕이 되는 틀과 공통 프로 그래밍 모델, 기술 API 등을 제공해준다.</p><p>스프링은 스프링 컨테이너 또는 애플리케이션 컨텍스트라고 불리는 스프링 런타임 엔진을 제공한다. 스프링 컨테이너는 설정정보를 참고로 해서 애플리케이션을 구성하는 오브젝트를 생성하고 관리한다.</p><p>스프링은 세 가지 핵심 프로그래밍 모델을 지원한다.</p><ul><li>IOC/DI : 오브젝트의 생명주기와 의존관계에 대한 프로그래밍 모델</li><li>서비스 추상화 : 환경이나 서버, 특정 기술에 종속되지 않고 이식성이 뛰어나며 유연한 애플리케이션을 만들 수 있다.</li><li>AOP : 애플리케이션 코드에 산재해서 나타나는 부가적인 기능을 독립적으로 모듈화하는 프로그래밍 모델</li></ul><blockquote><p>자바빈</p><p>다음과 같은 두 가지 관례를 따라 만들어진 오브젝트를 말한다. 간단히 빈이라고 부르기도 한다.</p><ul><li>디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.</li><li>프로퍼티 : 자자빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 setter와 getter를 이용해 수정 또는 조회할 수 있다.</li></ul></blockquote><p>디자인 패턴 : 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션. 주로 객체지향 설계에 관한 것이고, 대부분 객체지향적 설계 원칙을 이용해 문제를 해결한다.</p><ul><li>템플릿 메소드 패턴상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법이다. 변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에 만들도록 한다. 슈퍼클래스에서는 미리 추상메소드 또는 오버라이드 가능한 메소드를 정의해두고 이를 활용해 코드의 기본 알고리즘을 담고 있는 템플릿 메소드를 만든다.</li><li>팩토리 메소드 패턴슈퍼클래스 코드에서는 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용한다. 이 메소드는 주로 인터페이스 타입으로 오브젝트를 리턴하므로 서브클래스에서 정확히 어떤 클래스의 오브젝트를 만들어 리턴할지는 슈퍼클래스에서는 알지 못한다. 팩토리 메소드와 메소드 패턴의 팩토리 메소드는 의미가 다르므로 혼동하지 않도록 주의해야 한다.</li></ul><p>클래스 사이의 관계와 오브젝트 사이의 관계를 구분할 수 있어야 한다.</p><ul><li>클래스 사이의 관계 : 코드에 다른 클래스의 이름이 나타나기 때문에 만들어지는 것이다.</li><li>오브젝트 사이의 관계 : 코드에서는 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면, 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있다.</li></ul><blockquote><p>개방 폐쇄 원칙 (OCP, Open-Closed Principle)</p><p>클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다. 인터페이스를 사용해 확장 기능을 정의한 대부분의 API는 바로 이 개방 폐쇄 원칙을 따른다.</p><p>개방 폐쇄 원칙은 <strong>높은 응집도와 낮은 결합도</strong>라는 소프트웨어 개발의 고전적인 원리로도 설명이 가능하다.</p></blockquote><blockquote><p>전략 패턴</p><p>개방 폐쇄 원칙의 실현에도 가장 잘 들어맞는 패턴이다. 전략 패턴은 자신의 기능 맥락(context)에서, 필요에 따라 변경이 필요한 알고리즘(독립적인 책임으로 분리가 가능한 기능)을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인패턴이다.</p><p>전략 패턴의 적용방법을 보면 클라이언트의 역할이 잘 설명되어 있다. 컨텍스트를 사용하는 클라이언트는 컨텍스트가 사용할 전략을 컨텍스트의 생성자 등을 통해 제공해주는게 일반적이다.</p></blockquote><p>제어의 역전 (IOC, Inversion Of Control)제어의 역전이라는 건, 간단히 프로그램의 제어 흐름 구조가 뒤바뀌는 것이다. 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 당연히 생성하지도 않는다. 또 자신도 어떻게 만들어지고 어디서 사용되는지를 알 수 없다. 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문이다.</p><p>서블릿이나 JSP, EJB처럼 컨테이너 안에서 동작하는 구조는 간단한 방식이긴 하지만 제어의 역전 개념이 적용되어 있다고 볼 수 있다.</p><p>프레임워크도 제어의 역전 개념 적용된 대표적인 기술이다. 라이브러리와 프레임워크의 차이점에 대해 설명하면, 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다. 단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다. 반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 보통 프레임워크 위에 개발한 클래스를 등록해주고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다.</p><p>제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요하다. 스프링은 IoC를 모든 기능의 기초가 되는 기반기술로 삼고 있으며, IoC를 극한까지 적용하고 있는 프레임워크다.</p><h1 id="스프링의-ioc">스프링의 IoC</h1><h2 id="오브젝트-팩토리를-이용한-스프링-ioc">오브젝트 팩토리를 이용한 스프링 IoC</h2><p>스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 <code>빈(bean)</code>이라고 부른다. 자바빈 또는 엔터프라이즈 자바빈(EJB)에서 말하는 빈과 비슷한 오브젝트 단위의 애플리케이션 컴포넌트를 말한다. 동시에 스프링 빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 가리키는 말이다.</p><p>스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 <code>빈 팩토리(bean factory)</code>라고 부른다. 보통 빈 팩토리보다는 이를 좀 더 확장한 <code>애플리케이션 컨텍스트(applcation context)</code>를 주로 사용한다.</p><p>애플리케이션 컨텍스트는 그 자체로는 애플리케이션 로직을 담당하지는 않지만 IoC 방식을 이용함으로써, 별도의 정보를 참고해서 빈의 생성과 관계설정 등의 제어 작업을 총괄한다.</p><ul><li>**@Configuration **: 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시</li><li><strong>@Bean</strong> : 오브젝트 생성을 담당하는 IoC용 메소드라는 표시</li></ul><p>애플리케이션 컨텍스트는 ApplicationContext 타입의 오브젝트다. ApplicationContext를 구현한 클래스는 여러 가지가 있는데 DaoFactory처럼 <strong>@Configuration이 붙은 자바 코드를 설정정보로 사용하려면 <code>AnnotationConfigApplicationContext</code>를 이용하면 된다.</strong></p><p><code>getBean()</code> 메소드는 ApplicationContext가 관리하는 오브젝트를 요청하는 메소드다. getBean()은 기본적으로 Object 타입으로 리턴하게 되어 있어서 매번 리턴되는 오브젝트에 다시 캐스팅을 해줘야 하는 부담이 있다. 그러나 자바 5 이상의 제네릭 메소드 방식을 사용해 getBean()의 두 번째 파라미터에 리턴 타입을 주면, 지저분한 캐스팅 코드를 사용하지 않아도 된다.</p><p>오브젝트 팩토리에서 사용했던 IoC 원리를 그대로 적용하는데 애플리케이션 컨텍스트를 사용하는 이유는 범용적이고 유연한 방법으로 IoC 기능을 확장하기 위해서다. 애플리케이션 컨텍스트를 사용했을 때 얻을 수 있는 장점은 다음과 같다.</p><ul><li>클라이언트는 구체적인 팩토리 메서드를 알 필요가 없다.</li><li>애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.</li><li>애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.</li></ul><h2 id="스프링-ioc의-용어-정리">스프링 IoC의 용어 정리</h2><ul><li><strong>빈</strong>빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트라는 뜻이다. 주의할 점은 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니라는 사실이다. 그 중에서 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.</li><li><strong>빈 팩토리</strong>스프링의 IoC를 담당하는 핵심 컨테이너를 말한다. 빈을 등록하고, 생성하고, 조회하고 돌려주고, 그 외에 부가적인 빈을 관리하는 기능을 담당한다.</li><li><strong>애플리케이션 컨텍스트</strong>빈 팩토리를 확장한 IoC.컨테이너다. 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다. 애플리케이션 컨텍스트 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용된다.</li><li><strong>설정정보/설정 메타정보</strong>스프링의 설정정보란 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보를 말한다. IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용된다.</li><li><strong>컨테이너 또는 IoC 컨테이너</strong>IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고도 한다. 그냥 컨테이너 또는 스프링 컨테이너라고 할 때는 애플리케이션 컨텍스트를 가리키는 것이라고 보면 된다.</li></ul><h2 id="싱글톤-레지스트리로서의-애플리케이션-컨텍스트">싱글톤 레지스트리로서의 애플리케이션 컨텍스트</h2><blockquote><p><strong>오브젝트의 동일성과 동등성</strong></p><p>자바에서는 두 개의 오브젝트가 같은가라는 말을 주의해서 써야 한다. 자바에서는 두개의 오브젝트가 완전히 같은 동일한 오브젝트라고 말하는 것(<code>동일성</code>)과, 동일한 정보를 담고 있는 오브젝트라고 말하는 것(<code>동등성</code>)은 분명한 차이가 있다. 물론 동일한 오브젝트는 동등하기도 하다.</p><p><strong>동일성은 == 연산자로, 동등성은 equals() 메소드를 이용해 비교한다.</strong></p></blockquote><p>스프링의 애플리케이션 컨텍스트는 기존에 직접 만든 오브젝트 팩토리와는 중요한 차이점이 있다. 스프링은 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다는 것이다. 애플리케이션 컨텍스트는 <strong>싱글톤을 저장하고 관리하는 <code>싱글톤 레지스트리</code>이기도 하다.</strong></p><p>스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다. (디자인 패턴에서 나오는 싱글톤 패턴과 비슷한 개념이지만 그 구현 방법은 확연히 다르다.)</p><h2 id="싱글톤-패턴의-한계">싱글톤 패턴의 한계</h2><p>일반적인 싱글톤 패턴 구현 방식에는 다음과 같은 문제(한계)가 있다.</p><ul><li>private 생성자를 갖고 있기 때문에 상속할 수 없다.</li><li>싱글톤은 테스트하기가 힘들다.</li><li>서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.</li><li>싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.</li></ul><h2 id="싱글톤-레지스트리">싱글톤 레지스트리</h2><p>스프링은 서버환경에서 싱글톤이 만들어져서 서비스 오브젝트 방식으로 사용되는 것은 적극 지지한다. 그러나 자바의 기본적인 싱글톤 패턴의 구현 방식은 여러 가지 단점이 있기 때문에, <strong>스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 그것이 바로 <code>싱글톤 레지스트리</code>다</strong></p><p>싱글톤 레지스트리의 장점은 스태틱 메소드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용하게 해준다는 것이다.</p><p>스프링의 싱글톤 레지스트리 덕분에 싱글톤 방식으로 사용될 애플리케이션 클래스라도 public 생성자를 가질 수 있다.</p><h2 id="싱글톤과-오브젝트의-한계">싱글톤과 오브젝트의 한계</h2><p>싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다. 따라서 상태 관리에 주의를 기울여야 한다. 기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태(stateless) 방식으로 만들어져야 한다.</p><p>무상태 방식으로 만들기 위해서는 메소드 안에서 생성되는 로컬 변수를 사용하면 된다. 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에 싱글톤이라고 해도 여러 스레드 변수의 값을 덮어쓸 일은 없다.</p><p>따라서 스프링의 싱글톤 빈으로 사용되는 클래스를 만들 때는 개별적으로 바뀌는 정보는 로컬 변수로 정의하거나, 파라미터로 주고받으면서 사용하게 해야 한다.</p><p>그러나, 자신이 사용하는 다른 싱글톤 빈을 저장하려는 용도라면 인스턴스 변수를 사용해도 좋다. 스프링이 한 번 초기화해주고 나면 이후에는 수정되지 않기 때문에 멀티스레드 환경에서 사용해도 아무런 문제가 없다.</p><h2 id="스프링-빈의-스코프">스프링 빈의 스코프</h2><p>스프링이 관리하는 오브젝트, 즉 빈이 생성되고, 존재하고, 적용되는 범위를 빈의 <code>스코프(scope)</code>라고 한다. 스프링 빈의 기본 스코프는 싱글톤이다.</p><p>경우에 따라서는 싱글톤 외의 스코프를 가질 수 있다. 그 예로 웹을 통해 새로운 HTTP 요청이 생길 때마다 생성되는 요청(request) 스코프가 있고, 웹의 세션과 스코프가 유사한 세션(session) 스코프도 있다.</p><h1 id="의존관계-주입-di">의존관계 주입 (DI)</h1><p>IoC가 매우 느슨하게 정의돼서 폭넓게 사용되는 용어이기 때문에 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못한다.</p><p>그래서 스프링이 제공하는 IoC 방식을 핵심을 짚어주는 <code>의존관계 주입(Dependency Injection)</code>이라는, 좀 더 의도가 명확한 이름을 사용하기 시작했다.</p><p>스프링이 다른 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 새로운 용어를 사용할 때 분명하게 드러난다.</p><p><strong>DI는 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 다른 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심이다.</strong></p><h2 id="런타임-의존관계-설정">런타임 의존관계 설정</h2><p>모델이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존관계 말고, 런타임 시에 오브젝트 사이에서 만들어지는 의존관계도 있다. 설계 시점의 의존관계가 실체화된 것이다.</p><p>런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트를 <code>의존 오브젝트</code>라고 한다.</p><p><strong>의존관계 주입은 구체적인 의존 오브젝트와 그것을 사용할 주체, 보통 클라이언트라고 부르는 오브젝트를 런타임 시에 연결해주는 작업을 말한다.</strong></p><p>의존관계 주입이란 다음의 세 가지 조건을 충족하는 작업을 말한다.</p><ul><li>클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.</li><li>런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.</li><li>이존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.</li></ul><p>의존관계 주입의 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제3의 존재가 있다는 것이다. 스프링의 애플리케이션 컨텍스트, 빈 팩토리, IoC 컨테이너 등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 제 3의 존재이다.</p><p>DI는 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 수동적으로 주입받은 오브젝트를 사용한다는 점에서 IoC의 개념에 잘 들어맞는다.</p><h2 id="의존관계-검색과-주입">의존관계 검색과 주입</h2><p>스프링이 제공하는 IoC 방법에는 의존관계 주입만 있는 것이 아니다.</p><p>의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하기 때문에 <code>의존관계 검색</code>이라고 불리는 것도 있다. 의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다.</p><p><strong>의존관계 검색은 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성작업은 외부 컨테이너에게 IoC로 맡기지만, 이를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용한다.</strong></p><p>스프링의 IoC와 DI 컨테이너를 적용했다고 하더라도 애플리케이션의 기동 시점에서 적어도 한 번은 의존관계 검색 방식을 사용해 오브젝트를 가져와야 한다. static 메소드인 main()에서는 DI를 이용해 오브젝트를 주입받을 방법이 없기 때문이다.</p><p>의존관계 검색(DL)과 의존관계 주입을 적용할 때 발견할 수 있는 중요한 차이점이 하나 있다. <strong>의존관계 검색 방식에서는 검색하는 오브젝트는 자신이 스프링의 빈일 필요가 없다.</strong></p><p>반면에 의존관계 주입에서는 오브젝트 사이에 DI가 적용되려면 반드시 두 오브젝트 모두 컨테이너가 만드는 빈 오브젝트여야 한다.</p><h1 id="참고">참고</h1><p><a href="http://www.acornpub.co.kr/book/toby-spring3.1-vol1" target="_blank" rel="noopener">토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;스프링&quot;&gt;스프링&lt;/h1&gt;
&lt;p&gt;스프링은 자바 엔터프라이즈 애플리케이션 개발에 사용되는 프레임워크다. 애플리케이션 프레임워크는 애플리케이션 개발을 빠르고 효율적으로 할 수 있도록 애플리케이션의 바탕이 되는 틀과 공통 프로 그래밍 모델, 기
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Spring" scheme="https://jongmin92.github.io/categories/Programming/Spring/"/>
    
    
      <category term="Spring" scheme="https://jongmin92.github.io/tags/Spring/"/>
    
      <category term="IoC" scheme="https://jongmin92.github.io/tags/IoC/"/>
    
      <category term="DI" scheme="https://jongmin92.github.io/tags/DI/"/>
    
      <category term="Toby" scheme="https://jongmin92.github.io/tags/Toby/"/>
    
  </entry>
  
  <entry>
    <title>Spring - MVC</title>
    <link href="https://jongmin92.github.io/2018/03/12/Spring/spring-mvc/"/>
    <id>https://jongmin92.github.io/2018/03/12/Spring/spring-mvc/</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2018-03-28T14:55:32.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dispatcherservlet-이란">DispatcherServlet 이란?</h1><p>Spring MVC는 DispatcherServlet의 등장으로 web.xml의 역할이 축소되었습니다. 이전에는 서블릿을 URL로 활용하기 위해서는 반드시 web.xml에 등록해야 했지만, 이제는 <strong><code>DispatcherServlet</code>이 해당 어플리케이션으로 들어오는 요청을 모두 핸들링 해주기 때문입니다.</strong></p><p>web.xml의 역할이 축소되었지만, <code>&lt;servlet&gt;</code>으로 DispatcherServlet을 등록해줘야 하며, 이 객체의 URL 적용범위 또한 web.xml에 설정해야 합니다. 또한 encoding과 관련된 <code>&lt;filter&gt;</code>나 <code>&lt;listener&gt;</code>를 등록하기 위해서 web.xml은 필요합니다.</p><p>그러나 web.xml에서 중요하게 사용되었던 <code>&lt;servlet&gt;</code> 매핑은 이제 DispatcherServlet이 대신 맡아서 처리하게 되었습니다. <strong>web.xml에 DispatcherServlet의 &lt;url-pattern&gt;을 '/'로 설정함으로써 동시에 이제 <code>모든 요청은 DispatcherServlet으로 전달</code>됩니다.</strong> 물론 DispatcherServlet을 web.xml에 등록해도 계속 서블릿을 web.xml에 매핑해서 사용할 수 있지만, 이런 옛 방식을 버리고 DispatcherServlet을 이용해 웹 개발을 한다면 앞으로 서블릿 파일을 만들 필요도 없어지고 동시에 놀라운 @MVC의 혜택을 얻을 수 있습니다.</p><p>DispatcherServlet을 이용한다는 것은 스프링에서 제공하는 @MVC를 이용하겠단 뜻입니다. @MVC는 그동안 추상적으로 알아오고 발전했던 MVC(Model, View, Controller) 설계 영역을 노골적으로 분할하여 사용자가 무조건 MVC로 어플리케이션을 설계하게끔 유도하는 방식입니다. 즉, @MVC를 이용해 어플리케이션을 개발한다면 MVC 설계의 원칙대로 웹 어플리케이션을 제작할 수 있게 된다는 뜻입니다.</p><p>그럼 간단하게 DispatcherServlet이 담당하는 역할이 무엇인지 알아봅시다. 먼저 DispatcherServlet에 대해 간단히 정의해보자면, <strong>각각 분리하여 만든 <code>Model, View, Controller</code>를 조합하여 브라우저로 출력해주는 역할을 수행합니다.</strong></p><h1 id="spring-mvc-구조">Spring MVC 구조</h1><p><img src="/images/post/2018-03-12/mvc.png" alt=""></p><h2 id="등장-요소">등장 요소</h2><ul><li><strong>DispatcherServlet</strong> : 프런트 컨트롤러 담당, 모든 HTTP 요청을 받아들여 그 밖의 오브젝트 사이의 흐름을 제어, 기본적으로 스프링 MVC의 DispatcherServlet 클래스를 그대로 적용</li><li><strong>HandlerMapping</strong> : 클라이언트의 요청을 바탕으로 어느 컨트롤러를 실행할지 결정</li><li><strong>Model</strong> : 컨트롤러에서 뷰로 넘겨줄 오브젝트를 저장하기 위한 오브젝트, HttpServletRequest와 HttpSession처럼 String 형 키와 오브젝트를 연결해서 오브젝트를 유지</li><li><strong>ViewResolver</strong> : View 이름을 바탕으로 View 오브젝트를 결정</li><li><strong>View</strong> : 뷰에 화명 표시 처리를 의뢰</li><li><strong>비즈니스 로직</strong> : 비즈니스 로직을 실행. 애플리케이션 개발자가 비즈니스 처리 사양에 맞게 작성</li><li><strong>컨트롤러(Controller)</strong> : 클라이언트 요청에 맞는 프레젠테이션 층의 애플리케이션 처리를 실행해야 함. 애플리케이션 개발자가 애플리케이션 처리 사양에 맞게 작성</li><li><strong>뷰 / JSP 등</strong> : 클라이언트에 대해 화면 표시 처리. 자바에서는 JSP 등으로 작성하는 일이 많으며, 애플리케이션 개발자가 화면의 사양에 맞게 작성</li></ul><h2 id="동작-순서">동작 순서</h2><ol><li>DispatcherServlet은 브라우저로부터 요청을 받아들입니다.</li><li>DispatcherServlet은 요청된 URL을 HandlerMapping 오브젝트에 넘기고 호출 대상의 컨트롤러 오브젝트를 얻어 URL에 해당하는 메서드를 실행합니다.</li><li>컨트롤러 오브젝트는 비즈니스 로직으로 처리를 실행하고, 그 결과를 바탕으로 뷰에 전달할 오브젝트를 Model 오브젝트에 저장합니다. 끝으로 컨트롤러 오브젝트는 처리 결과에 맞는 View 이름을 반환합니다.</li><li>DispatcherServlet은 컨트롤러에서 반환된 View 이름을 ViewResolver에 전달해서 View 오브젝트를 얻습니다.</li><li>DispatcherServlet은 View 오브젝트에 화면 표시를 의뢰합니다.</li><li>View 오브젝트는 해당하는 뷰를 호출해서 화면 표시를 의뢰합니다.</li><li>뷰는 Model 오브젝트에서 화면 표시에 필요한 오브젝트를 가져와 화면 표시 처리를 실행합니다.</li></ol><h1 id="참고">참고</h1><ul><li><a href="http://www.hanbit.co.kr/store/books/look.php?p_code=B9146679987" target="_blank" rel="noopener">스프링4 입문 - 한빛미디어</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;dispatcherservlet-이란&quot;&gt;DispatcherServlet 이란?&lt;/h1&gt;
&lt;p&gt;Spring MVC는 DispatcherServlet의 등장으로 web.xml의 역할이 축소되었습니다. 이전에는 서블릿을 URL로 활용하기 위해
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Spring" scheme="https://jongmin92.github.io/categories/Programming/Spring/"/>
    
    
      <category term="Spring" scheme="https://jongmin92.github.io/tags/Spring/"/>
    
      <category term="MVC" scheme="https://jongmin92.github.io/tags/MVC/"/>
    
      <category term="DispatcherServlet" scheme="https://jongmin92.github.io/tags/DispatcherServlet/"/>
    
      <category term="HandlerMapping" scheme="https://jongmin92.github.io/tags/HandlerMapping/"/>
    
      <category term="ViewResolver" scheme="https://jongmin92.github.io/tags/ViewResolver/"/>
    
  </entry>
  
  <entry>
    <title>Spring - RequestBody &amp; ResponseBody</title>
    <link href="https://jongmin92.github.io/2018/03/02/Spring/spring-requestbody-responsebody/"/>
    <id>https://jongmin92.github.io/2018/03/02/Spring/spring-requestbody-responsebody/</id>
    <published>2018-03-02T14:00:00.000Z</published>
    <updated>2018-03-11T15:54:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>웹 서비스와 RESTful한 방식이 시스템을 구성하는 주요 요소로 자리 잡으면서 웹 시스템간에 <strong>XML</strong>이나 <strong>JSON</strong> 등의 형식으로 데이터를 주고 받는 경우가 증가했습니다.</p><p>이에 따라 스프링 MVC도 **클라이언트에서 전송한 XML 데이터나 JSON 또는 기타 데이터를 컨트롤러에서 DOM 객체나 자바 객체로 변환해서 받을 수있는 기능(수신)**을 제공하고 있으며, 비슷하게 **자바 객체를 XML이나 JSON 또는 기타 형식으로 변환해서 전송할 수 있는 기능(송신)**을 제공하고 있습니다.</p><p><strong><code>@RequestBody</code> 어노테이션과 <code>@ResponseBody</code> 어노테이션은 각각 HTTP 요청의 body 부분을 자바 객체로 변환하고 자바 객체를 HTTP 응답 body로 변환</strong>하는데 사용됩니다.</p><h1 id="requestbody">@RequestBody</h1><p>Spring MVC 컨트롤러에서 HTTP 요청의 body 부분을 자바 객체로 mapping할 때 <code>@RequestBody</code> 어노테이션을 사용합니다. @RequestBody 어노테이션의 기능은 다음과 같습니다.</p><ul><li>@ReuqestBody를 사용하지 않는 경우 : query parameter, form data를 객체에 mapping한다.</li><li>@ReuqestBody를 사용하는 경우 : body에 있는 data를 <strong>HttpMessageConverter</strong>를 이용해 선언한 객체에 mapping한다.</li></ul><h1 id="responsebody">@ResponseBody</h1><p>@ResponseBody는 @RequestBody와 비슷한 방식으로 동작합니다. @ResponseBody가 메소드 레벨에서 부여되면 메소드가 리턴하는 오브젝트는 <a href="https://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.html" target="_blank" rel="noopener">ContentNegotiatingViewResolver</a>를 이용해 뷰를 통해 결과를 만들어내는 것이 아닌, message converter를 통해 바로 HTTP 응답의 메시지 본문으로 변환됩니다.</p><p>ContentNegotiatingViewResolver는 등록되어 있는 ViewResolver중에서 controller 메소드의 리턴값을 통해 등록된 ViewResolver 중에서 적합한 형태로 처리해서 반환하는 반면, <strong>@ResponseBody는 @RequestBody가 선택한 형식으로 결과값을 변환하여 반환한다고 보면 됩니다.</strong></p><blockquote><p><strong><code>@RestController</code>는 @Controller와 @ResponseBody를 동시에 사용하는 것과 같습니다.</strong> @Controller를 사용하는 경우에만 @ResponseBody를 추가하면 됩니다.</p></blockquote><h1 id="httpmessageconverter를-이용한-변환-처리">HttpMessageConverter를 이용한 변환 처리</h1><p><a href="https://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/web/servlet/mvc/annotation/AnnotationMethodHandlerAdapter.html" target="_blank" rel="noopener">AnnotationMethodHandlerAdapter</a>에는 <a href="https://docs.spring.io/autorepo/docs/spring/3.2.0.M1/api/org/springframework/http/converter/HttpMessageConverter.html" target="_blank" rel="noopener">HttpMessageConverter</a> 타입의 메시지 변환기인 <code>message converter</code>가 여러 개 등록되어 있습니다. @RequestBody가 붙은 파라미터가 있으면 <strong>HTTP 요청의 미디어 타입과 파라미터의 타입을 먼저 확인하고, message converter 중에서 해당 미디어 타입과 파라미터 타입을 처리할 수 있다면, HTTP 요청의 body 부분을 통째로 변환해서 지정된 메소드 파라미터로 전달</strong>해줍니다.</p><h2 id="httpmessageconverter의-종류">HttpMessageConverter의 종류</h2><p><strong>AnnotationMethodHandlerAdapter 클래스는 @RequestBody 어노테이션이 적용된 파라미터나 @ResponseBody 어노테이션이 적용된 메서드에 대해 HttpMessageConverter를 사용해서 변환을 처리</strong>합니다. 주요 HttpMessageConverter 구현 클래스는 다음과 같습니다.</p><ul><li><strong>ByteArrayHttpMessageConverter</strong> : HTTP 메시지와 byte 배열 사이의 변환을 처리한다. 컨텐츠 타입은 <code>application/octet-stream</code>이다.</li><li><strong>StringHttpMessageConverter</strong> :  HTTP 메시지와 String 사이의 변환을 처리한다. 컨텐츠 타입은 <code>text/plain;charset=ISO-8859-1</code>이다.</li><li><strong>SourceHttpMessageConverter</strong> : HTTP 메시지와 javax.xml.transform.Source 사이 변환을 처리한다. 컨텐츠 타입은 <code>application/xml 또는 text/xml</code>이다.</li><li><strong>FormHttpMessageConverter</strong> : HTML 폼 데이터를 MultiValueMap으로 전달받을 때 사용된다. 지원하는 컨텐츠 타입은 <code>application-x-www-form-urlencorded</code>이다.</li><li><strong>MappingJacksonHttpMessageConverter</strong> : Jackson 라이브러리를 이용해서 JSON HTTP 메시지와 객체 사이의 변환을 처리한다. 컨텐츠 타입은 <code>applicaion/json</code>이다.</li><li><strong>MarshallingHttpMessageConverter</strong> : 스프링의 Marshaller와 unMarshaller를 이용해서 XML HTTP 메시지와 객체 사이의 변환을 처리한다. 컨텐츠 타입은 <code>application/xml</code> 또는 <code>text/xml</code>이다.</li></ul><h1 id="content-type과-accept-header-기반의-변환-처리">Content-Type과 Accept header 기반의 변환 처리</h1><p>AnnotationMethodHandlerAdapter가 HttpMessageConverter를 이용해서 request의 body 데이터를 @RequestBody 어노테이션이 적용된 자바 객체로 변환할 때에는, <strong>HTTP 요청 header의 <code>Content-Type</code>에 명시된 미디어 타입(MIME)을 지원하는 HttpMessageConverter 구현체를 선택</strong>합니다.예를 들어, 요청 미디어 타입이 application/json이고 @RequestBody 어노테이션이 적용된 경우 MappingJacksonHttpMessageConverter가 선택됩니다.</p><p>비슷하게 @ResponseBody 어노테이션을 이용해서 리턴한 객체를 HTTP 응답 객체로 변환할 때에는 <strong>HTTP 요청 header의  <code>Accept</code>에 명시된 미디어 타입(MIME)을 지원하는 HttpMessageConveter 구현체를 선택</strong>합니다.예를 들어, Accept에 명시된 값이 application/json이고 @ResponseBody 어노테이션이 적용된 메서드의 리턴 타입이 자바 객체인 경우 MappingJacksonHttpMessageConverter가 선택됩니다.</p><h1 id="참고">참고</h1><p><a href="http://www.baeldung.com/spring-httpmessageconverter-rest" target="_blank" rel="noopener">Http Message Converters with the Spring Framework</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;웹 서비스와 RESTful한 방식이 시스템을 구성하는 주요 요소로 자리 잡으면서 웹 시스템간에 &lt;strong&gt;XML&lt;/strong&gt;이나 &lt;strong&gt;JSON&lt;/strong&gt; 등의 형식으로 데이터를 주고 받는 경우가 증가했습니다.&lt;/p&gt;
&lt;p&gt;이
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Spring" scheme="https://jongmin92.github.io/categories/Programming/Spring/"/>
    
    
      <category term="Spring" scheme="https://jongmin92.github.io/tags/Spring/"/>
    
      <category term="RequestBody" scheme="https://jongmin92.github.io/tags/RequestBody/"/>
    
      <category term="ResponseBody" scheme="https://jongmin92.github.io/tags/ResponseBody/"/>
    
  </entry>
  
  <entry>
    <title>Spring - AOP</title>
    <link href="https://jongmin92.github.io/2018/02/17/Spring/spring-aop/"/>
    <id>https://jongmin92.github.io/2018/02/17/Spring/spring-aop/</id>
    <published>2018-02-17T10:30:00.000Z</published>
    <updated>2018-02-17T16:08:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="aop의-등장-배경">AOP의 등장 배경</h1><p>몇 년에 걸쳐 객체지향 프로그래밍(Object Oriented Programming, OOP)은 절차적 프로그래밍 방법론을 거의 완벽히 대체하며 프로그래밍 방법론의 새로운 패러다임으로 떠오르게 되었습니다. 객체지향적 방식의 가장 큰 이점 중 하나는 소프트웨어 시스템이 여러 개의 독립된 클래스들의 집합으로 구성된다는 것입니다. 이들 각각의 클래스들은 잘 정의된 고유 작업을 수행하게 되고, 그 역할 또한 명백히 정의되어 있습니다.</p><p>객체지향 어플리케이션에서는 어플리케이션이 목표한 동작을 수행하기 위해 이런 클래스들이 서로 유기적으로 협력합니다. <strong>하지만 시스템의 어떤 기능들은 특정 한 클래스가 도맡아 처리할 수 없습니다. 이들은 시스템 전체에 걸쳐 존재하며 해당 코드들을 여러 클래스들에서 사용합니다.</strong> 이런 현상을 <code>횡단적(cross-cutting)</code>이라 표현합니다. 분산 어플리케이션에서의 동기화(locking) 문제, 예외 처리, 로깅 등이 그 예입니다. 물론 필요한 모든 클래스들에 관련 코드를 집어 넣으면 해결될 문제입니다. 하지만 이런 행위는 각각의 클래스는 잘 정의된(well-defined) 역할만을 수행한다는 기본 원칙에 위배됩니다. 이런 상황이 바로 <code>Aspect Oriented Programming (AOP)</code>가 생겨난 원인이 되었습니다.</p><p>AOP에서는 aspect라는 새로운 프로그램 구조를 정의해 사용합니다. 쉽게 class, interface 등과 같이 특정한 용도의 구조라 생각하면 됩니다. Aspect 내에는 프로그램의 여러 모듈들에 흩어져 있는 기능(하나의 기능이 여러 모듈에 흩어져 있음을 뜻함)을 모아 정의하게 됩니다. <strong>전체적으로, 어플리케이션의 각각의 클래스는 자신에게 주어진 기능만을 수행하고, 추가된 각 <code>aspect</code>들이 횡단적인 행위(기능)들을 모아 처리하며 전체 프로그램을 이루는 형태가 만들어집니다.</strong></p><h1 id="aop가-필요한-사례">AOP가 필요한 사례</h1><p>이해를 돕기 위해 어플리케이션의 여러 스레드들이 하나의 데이터를 공유하는 상황을 가정해봅시다. 공유 데이터는 Data라는 객체(Data 클래스의 인스턴스)로 캡슐화되어 있습니다. 서로 다른 여러 클래스의 인스턴스들이 하나의 Data 객체를 사용하고 있으나, 이 공유 데이터에 접근할 수 있는 객체는 한 번에 하나씩이어야만 합니다. 그렇다면 어떤 형태이건 동기화 메커니즘이 도입되어야 할 것입니다. 즉, 어떤 한 객체가 데이터를 사용중이라면 Data 객체는 잠겨(lock)져야 하며, 사용이 끝났을 때 해제(unlock)되어야 합니다. 전통적인 해결책은 공유 데이터를 사용하는 모든 클래스들이 하나의 공통 부모 클래스(&quot;worker&quot; 라 부르겠습니다)로부터 파생되는 형태로 만드는 것입니다. worker 클래스에는 lock()과 unlock() 메소드를 정의하여 작업의 시작과 끝에 이 메소드를 호출토록 하면 됩니다. 하지만 이런 형태는 다음과 문제들을 파생시킵니다.</p><p>공유 데이터를 사용하는 메소드는 상당히 주의해서 작성되어야 합니다. 동기화 코드를 잘못 삽입하면 데드락(dead-lock)이 발생하거나 데이터 영속성이 깨질 수 있습니다. 또한 메소드 내부는 본래의 기능과 관련 없는 동기화 관련 코드들로 더럽혀질 것입니다.Java와 같은 단일 상속 모델에서는 worker를 만든다는 것이 불가능할 수 있습니다. 어떤 클래스들은 이미 다른 클래스들로부터 확장되었을 수도 있기 때문입니다. 이는 특히 클래스 계층 구조 설계가 마무리된 후, 뒤늦게 동기화의 필요성을 깨달았을 때 흔히 발생합니다. 동기화를 신경 쓰지 않은 범용 클래스 라이브러리를 통해 공유 데이터에 접근하려 하는 경우가 한 예가 될 수 있습니다.앞서 가정한 어플리케이션에서 동기화 개념은 다음과 같은 속성들을 갖습니다.</p><ol><li>동기화는 worker 클래스에 할당된 최우선 작업이 아니다.</li><li>동기화 메커니즘은 worker 클래스의 최우선 작업과 독립적이다.</li><li>한 객체에 대한 동기화 관련 코드가 시스템 전체에 횡단적으로 존재한다. 다수의 클래스와 더 많은 수의 메소드들이 이 동기화 메커니즘에 영향 받는다.</li></ol><p>AOP에서는 이런 형태의 문제를 해결하기 위해 새로운 형태의 접근 방법을 제기하고 있습니다. <strong>AOP는 새로 도입된 프로그램 구조를 통해 시스템에 횡단되어 있는 기능들을 정의해 처리하도록 했습니다.</strong> 이 새로운 구조를 <code>aspect</code>라 부릅니다.</p><p>위의 예시에 Lock이라는 aspect를 도입해보겠습니다. Lock aspect에는 다음과 같은 역할이 할당될 것입니다.</p><ol><li>Data 객체를 사용하는 클래스들을 위해 lock 및 unlock 메커니즘을 제공한다(lock(), unlock()).</li><li>Data 객체를 수정하는 모든 메소드들이 수행 전에 lock()을 호출하고, 수행 후에는 unlock()을 호출함을 보장한다.</li><li>이상의 기능을 Data 객체를 사용하는 클래스의 자바 소스를 변경하지 않고 투명하게 수행한다.</li></ol><h1 id="aspect는-또-어떤-일들을-수행할-수-있을까">Aspect는 또 어떤 일들을 수행할 수 있을까?</h1><p>특정 메소드(ex. 객체 생성 과정 추적) 호출을 로깅할 경우 aspect가 도움이 될 수 있습니다. 기존 방법대로라면 log() 메소드를 만들어 놓은 후, 자바 소스에서 로깅을 원하는 메소드를 찾아 log()를 호출하는 형태를 취해야할 것입니다. 그러나 여기서 AOP를 사용하면 원본 자바 코드를 수정할 필요 없이 원하는 위치에서 원하는 로깅을 수행할 수 있습니다. 이런 작업 모두는 aspect라는 외부 모듈에 의해 수행됩니다.또 다른 예로 예외 처리가 있습니다. Aspect를 이용해 여러 클래스들의 산재된 메소드들에 영향을 주는 catch() 조항(clause)을 정의해 어플리케이션 전체에 걸쳐 지속적이고 일관적으로 예외를 처리할 수 있습니다.</p><h1 id="aop-용어">AOP 용어</h1><ul><li><strong>JoinPoint</strong> : 메소드 호출이나 특정 예외를 던지는 것과 프로그램이 실행되는 지점을 이야기한다.</li><li><strong>Advice</strong> : Logging과 같은 횡단관심사의 경우 거의 모든 클래스에 분산되어 있는 것을 볼 수 있다. 이와 같은 횡단관심사를 여러 영역에 분산해 구현하는 것이 아니라 한 곳에 모아서 구현하는 것을 Advice라고 한다. 즉, JoinPoint에서 실행되는 코드를 말한다.</li><li><strong>Point-cut</strong> : 횡단관심사에 해당하는 기능을 구현한 부분이 Advice라고 했다. 그렇다면 이렇게 구현되어 있는 Advice를 어떤 패턴을 가지는 클래스와 메소드에 적용할지를 결정하는 것이 Point-cut이다. 즉 해당 Advice가 적용되어야 하는 곳을 가리키는 것이 Point-cut이다. Point-cut은 JoinPoin와 Advice의 중간에 있으면서 처리가 JoinPoint에 이르렀을 때 Advice를 호출할지를 결정한다.</li><li><strong>Aspect</strong> : Aspect는 Advice와 Point-cut을 합쳐서 하나의 Aspect라고 칭한다. Advice와 Point-cut을 이용하여 Logging이라는 관심사를 분리하여 독립적으로 구현할 수 있었다. 이처럼 Advice와 Point-cut을 이용하여 원하는 관심사를 구현하는 것을 하나의 Aspect라고 한다. 지금까지 살펴본 Logging은 Logging Aspect가 될 것이다.</li><li><strong>Introduction</strong> : 실행되고 있는 클래스에 새로운 인터페이스를 추가하여 원래의 Object가 가지고 있는 속성, 행위 이외의 다른 일이 가능하도록 하게 된다.</li></ul><p>Spring AOP의 Advice는 여러개의 Advice를 가집니다. Spring에서 지원하고 있는 Advice는 다음과 같습니다.</p><ul><li><strong>Before advice</strong> : JoinPoint 앞에서 수행되는 Advice. 하지만 JoinPoint를 위한 수행 흐름 처리(execution flow proceeding)를 막기위한 능력(만약 예외를 던지지 않는다면)을 가지지는 않는다.</li><li><strong>After returning advice</strong> : JoinPoint가 완전히 정상 종료한 다음 실행되는 Advice. (메소드가 예외를 던지는것 없이 반환된다면 완성된 후에 수행되는 advice.)</li><li><strong>Around advice</strong> : JoinPoint 앞뒤에서 실행되는 Advice. Around advice는 메소드 호출 전후에 사용자 지정 행위를 수행한다.</li><li><strong>Throws advice</strong> : JoinPoint에서 예외가 발생했을 때 실행되는 Advice. Spring은 강력한 타입의 Throws advice를 제공한다. 그래서 Throwable 나 Exception으로 부터 형변환 할 필요가 없는 관심가는 예외(그리고 하위클래스)를 처리하는 코드를 쓸 수 있다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;aop의-등장-배경&quot;&gt;AOP의 등장 배경&lt;/h1&gt;
&lt;p&gt;몇 년에 걸쳐 객체지향 프로그래밍(Object Oriented Programming, OOP)은 절차적 프로그래밍 방법론을 거의 완벽히 대체하며 프로그래밍 방법론의 새로운 패러다임으
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Spring" scheme="https://jongmin92.github.io/categories/Programming/Spring/"/>
    
    
      <category term="Spring" scheme="https://jongmin92.github.io/tags/Spring/"/>
    
      <category term="AOP" scheme="https://jongmin92.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring - IoC &amp; DI</title>
    <link href="https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/"/>
    <id>https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/</id>
    <published>2018-02-11T09:30:00.000Z</published>
    <updated>2018-03-11T16:57:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ioc란">IoC란?</h1><p>IoC 컨테이너 개념을 이해하기 위하여 이와 같은 컨테이너가 왜 등장하게 되었는지를 먼저 이해하는 것이 중요합니다.</p><p>애플리케이션 코드를 작성할 때, 특정 기능이 필요하면 라이브러리 사용하곤 합니다. 이때는 프로그램의 흐름을 제어하는 주체가 애플리케이션 코드입니다. 하지만 <strong>프레임워크(Framework) 기반의 개발에서는 프레임워크 자신이 흐름을 제어하는 주체가 되어, 필요 할 때마다 애플리케이션 코드를 호출하여 사용합니다.</strong></p><p>프레임워크에서 이 제어권을 가지는 것이 바로 <code>컨테이너(Container)</code>입니다. <strong>객체에 대한 제어권이 개발자로부터 컨테이너에게 넘어가면서 객체의 생성부터 생명주기 관리까지의 모든 것을 컨테이너가 맡아서 하게됩니다.</strong> 이를 <strong>일반적인 제어권의 흐름이 바뀌었다고 하여 <code>IoC(Inversion of Control : 제어의 역전)</code>라고 합니다.</strong></p><p>먼저 지금까지 일반적으로 개발하던 방식에 대해서 생각해보아야 합니다. 모든 인스턴스에 대한 생성 권한은 지금까지 모든 개발자들에게 있었습니다. 즉, 작성하는 코드상에서 개발자가 직접 생성했다는 것입니다. EJB나 IoC 컨테이너를 사용하지 않았던 개발자들은 지금까지 이와 같은 방식을 사용했습니다.</p><p>EJB는 각 개발자들이 모든 인스턴스의 생성 권한에 제약을 가하는 첫번째 프레임워크입니다. EJB는 서비스를 위해 생성되는 컴포넌트에 대한 생성 권한을 EJB 컨테이너에게 위임했습니다. 생성된 인스턴스는 EJB 컨테이너가 생명주기를 관리했습니다. EJB가 EJB 컨테이너에 의하여 관리됨으로 인해 큰 장점을 얻을 수 있었습니다. 그러나 장점 이외에 EJB가 가지고 있는 한계에 부딪히게 되었으며, 이 같은 요구사항을 해결하기 위해 EJB의 한계를 극복하기 위한 시도가 발생했습니다.</p><p>그래서 등장한 것이 경량(LightWeight) IoC 컨테이너 입니다. 경량 IoC 컨테이너는 EJB 컨테이너가 가지고 있던 단점을 보완하기 위하여 탄생한 컨테이너 개념입니다. <strong>Spring 프레임워크에서 지원하는 IoC 컨테이너는 우리들이 흔히 개발하고 사용해왔던 일반 <code>POJO(Plain Old Java Object)</code> 클래스들이 지금까지 EJB를 통하여 실행했던 많은 기능들을 서비스 가능하도록 지원합니다.</strong>또한, EJB 컨테이너가 지원하고 있던 Transaction, Object Pooling, 인스턴스 생명주기 관리등의 기능들을 Spring 컨테이너가 지원하며 부가적으로 테스트의 용이성(애플리케이션 품질의 향상), 개발 생산성을 향상 시킬 수 있습니다.</p><h1 id="사용하는-목적">사용하는 목적</h1><p>IoC를 사용하는 목적에 대해서는 지금까지의 클래스호출 방식의 변화를 살펴보면 더 쉽게 이해할 수 있습니다.</p><h2 id="클래스-호출-방식">클래스 호출 방식</h2><p>클래스내에 선언과 구현이 같이 있기 때문에 다양한 형태로 변화가 불가능합니다.<img src="/images/post/2018-02-11/class1.jpg" alt=""></p><h2 id="인터페이스-호출-방식">인터페이스 호출 방식</h2><p>클래스를 인터페이스와 인터페이스를 상속받아 구현하는 클래스로 분리했습니다. 구현클래스 교체가 용이하여 다양한 변화가 가능합니다. 그러나 구현클래스 교체시 호출클래스의 코드에서 수정이 필요합니다. (부분적으로 종속적)<img src="/images/post/2018-02-11/class2.jpg" alt=""></p><h2 id="팩토리-호출-방식">팩토리 호출 방식</h2><p>팩토리 방식은 팩토리가 구현클래스를 생성하기 때문에 호출클래스는 팩토리를 호출 하는 코드로 충분합니다. 구현클래스 변경시 팩토리만 수정하면 되기 때문에 호출클래스에는 영향을 미치지 않습니다. 그러나 호출클래스에서 팩토리를 호출하는 코드가 들어가야 하는 것 또한 팩토리에 의존함을 의미합니다.<img src="/images/post/2018-02-11/class3.jpg" alt=""></p><h2 id="ioc">IoC</h2><p>팩토리 패턴의 장점을 더해 어떠한 것에도 의존하지 않는 형태가 되었습니다. 실행시점에 클래스간의 관계가 형성이 됩니다. 즉, <strong>의존성이 삽입된다는 의미로 IoC를 <code>DI</code>라는 표현으로 사용합니다.</strong><img src="/images/post/2018-02-11/class4.jpg" alt=""></p><h1 id="ioc-용어-정리">IoC 용어 정리</h1><ul><li><code>bean</code> : <strong>스프링에서 제어권을 가지고 직접 만들어 관계를 부여하는 오브젝트</strong>Java Bean, EJB의 Bean과 비슷한 오브젝트 단위의 애플리케이션 컴포넌트이다. 하지만 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 빈은 아니다. 스프링의 빈은 스프링 컨테이너가 생성하고 관계설정, 사용을 제어해주는 오브젝트를 말한다.</li><li><code>bean factory</code> : <strong>스프링의 IoC를 담당하는 핵심 컨테이너</strong>Bean을 등록/생성/조회/반환/관리 한다. 보통 bean factory를 바로 사용하지 않고 이를 확장한 application context를 이용한다. BeanFactory는 bean factory가 구현하는 interface이다. (getBean()등의 메서드가 정의되어 있다.)</li><li><code>application context</code> : <strong>bean factory를 확장한 IoC 컨테이너</strong>Bean의 등록/생성/조회/반환/관리 기능은 bean factory와 같지만, 추가적으로 spring의 각종 부가 서비스를 제공한다. ApplicationContext는 application context가 구현해야 하는 interface이며, BeanFactory를 상속한다.</li><li><code>configuration metadata</code> : <strong>application context 혹은 bean factory가 IoC를 적용하기 위해 사용하는 메타정보</strong>스프링의 설정정보는 컨테이너에 어떤 기능을 세팅하거나 조정하는 경우에도 사용하지만 주로 bean을 생성/구성하는 용도로 사용한다.</li><li><code>container (ioC container)</code> : <strong>IoC 방식으로 bean을 관리한다는 의미에서 bean factory나 application context를 가리킨다.</strong>application context는 그 자체로 ApplicationContext 인터페이스를 구현한 오브젝트를 말하기도 하는데, 하나의 애플리케이션에 보통 여러개의 ApplicationContext 객체가 만들어진다. 이를 통칭해서 spring container라고 부를 수 있다.</li></ul><h1 id="스프링을-사용하지-않을-때-일어날-수-있는-문제">스프링을 사용하지 않을 때 일어날 수 있는 문제</h1><p>스프링의 특징을 알아보기 앞서 스프링을 사용하지 않을 때 어떤 문제가 일어날 수 있는지 알아보겠습니다.</p><ul><li>오브젝트의 생명 주기 문제</li><li>부품화 문제</li><li>기술 은닉과 부적절한 기술 은닉 문제</li></ul><p>이러한 문제를 해결하지 않는 한 웹 애플리케이션은 리소스를 잘 이용하지 못하고, 테스트하기 어려우며, 확장이나 변경 또한 어려울 것입니다. 스프링은 이러한 문제를 해결하기 위해 만들어진 컨테이너라고도 할 수 있습니다.스프링은 위의 문제를 다음과 같이 해결합니다.</p><ul><li>오브젝트의 생명 주기 문제는 DI 컨테이너로 해결</li><li>부품화 문제는 DI 컨테이너로 해결</li><li>기술 은닉과 부적절한 기술 은닉 문제는 AOP로 해결</li></ul><h1 id="di">DI</h1><p><strong>IoC는 직관적이지 못하기 때문에 <code>DI(Dependency Injection)</code>라고도 부릅니다.</strong> DI는 오브젝트를 생성하고 오브젝트끼리의 관계를 생성해 소프트웨어의 부품화 및 설계를 가능하게 합니다. DI를 이용하면 인터페이스 기반의 컴포넌트를 쉽게 구현할 수 있습니다.DI를 우리말로 옮기면 의존 관계의 주입입니다. 쉽게 말하면 오브젝트 사이의 의존 관계를 만드는 것입니다. 어떤 오브젝트의 프로퍼티(인스턴스 변수)에 오브젝트가 이용할 오브젝트를 설정한다는 의미입니다. 이를 학술적으로 말하면, 어떤 오브젝트가 의존(이용)할 오브젝트를 주입 혹은 인젝션(프로퍼티에 설정)한다는 것입니다.DI를 구현하는 컨테이너는 단순한 인젝션 외에도 클래스의 인스턴스화 등의 생명 주기 관리 기능이 있는 경우가 많습니다.</p><p>클래스에서 new 연산자가 사라졌다는 사실이 중요합니다. 클래스에서 new 연산자가 사라짐으로써 개발자가 팩토리 메서드 같은 디자인 패턴을 구사하지 않아도 <strong>DI 컨테이너가 건내주는 인스턴스를 인터페이스로 받아서 인터페이스 기반의 컴포넌트화를 구현할 수 있게 됐습니다.</strong></p><p>DI 컨테이너의 구상 클래스 인스턴스화는(디폴트로는) 1회만 실행합니다. 생성된 인스턴스는 필요한 곳에서 사용합니다. 이렇게 하는 것으로 서비스와 DAO처럼 Singleton으로 만들고 싶은 컴포넌트를 특별히 Singleton으로 만들지 않아도 간단히 실현되게 해줍니다.</p><p><strong>스프링에는 크게 (1)XML로 작성된 Bean 정의 파일을 이용한 DI, (2)어노테이션을 이용한 DI, (3)JavaConfig에 의한 DI가 있습니다. 이번 포스팅에서는 어노테이션을 이용한 DI에 대해 알아보겠습니다.</strong></p><h2 id="autowired와-component">@Autowired와 @Component</h2><p><strong>인스턴스 변수 앞에 <code>@Autowired</code>를 붙이면 DI 컨테이너가 그 인스턴스 변수의 형에 대입할 수 있는 클래스를 <code>@Component</code>가 붙은 클래스 중에서 찾아내 그 인스턴스를 인젝션해줍니다(정확히는 Bean 정의에서 클래스를 스캔할 범위를 정해야 합니다).</strong>인스턴스 변수로의 인젝션은 접근 제어자가 private라도 인젝션 할 수 있으므로 Setter 메서드를 만들 필요는 없습니다. (과거에 캡슐화의 정보 은닉에 반하는 것이 아니냐는 논의가 있었지만, 현재는 편리함에 밀려 그런 논의를 보기 힘들어졌습니다.)</p><p>만약 @Component가 붙은 클래스가 여러 개 있어도 형이 다르면 @Autowired가 붙은 인스턴스 변수에 인젝션되지 않습니다. 이렇게 <strong>형을 보고 인젝션하는 방법을 <code>byType</code>이라고 합니다.</strong></p><h2 id="autowired">@Autowired</h2><p>@Autowired는 인스턴스 변수 앞에 붙이는 것 외에도, 다음과 같이 적당한 메서드 선언 앞에도 붙일 수 있습니다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFoo</span><span class="params">(Foo foo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.foo = foo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFoo</span><span class="params">(Foo foo, Bar bar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.foo = foo;</span><br><span class="line">    <span class="keyword">this</span>.bar = bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>또한 생성자에도 이용할 수 있습니다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Food</span><span class="params">(Bar b)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/post/2018-02-11/interface_2_class.png" alt="">그런데 위의 사진과 같이 인터페이스에 구현 클래스가 2개여서 @Autowired로 인젝션할 수 있는 클래스의 형이 2개 존재한다면 에러가 발생합니다. <strong>인젝션할 수 있는 클래스의 형은 반드시 하나로 해야합니다.</strong> 하지만 이래서는 인터페이스의 구현 클래스를 테스트용 클래스 등 다른 클래스로 바꿀 경우에 불편합니다. 그래서 이를 회피하는 세 가지 방법에 대해 알아보겠습니다.</p><ol><li><p>우선할 디폴트 Bean을 설정하는 @Primary를 @Bean이나 @Component에 부여하는 방법(Bean 정의 파일에서는 &lt;bean primary=&quot;true&quot;&gt;)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductDaoImpl</span> <span class="keyword">implements</span> <span class="title">ProductDao</span> </span>&#123;</span><br><span class="line">...(생략)...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>@Autowired와 병행해서 @Qualifier를 하는 방법단, 이 경우는 @Component에도 이름을 같이 지정해야 한다. 이렇게 인젝션할 클래스를 형이 아닌 이름으로 찾아주는 방법을 byName이라고 한다. (물론 @Component에 같은 이름이 붙은 클래스가 중복되면 오류가 발생한다.)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"productDao"</span>)</span><br><span class="line"><span class="keyword">private</span> ProductDao productDao;</span><br><span class="line"></span><br><span class="line">-----------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"productDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductDaoImpl</span> <span class="keyword">implements</span> <span class="title">ProductDao</span> </span>&#123;</span><br><span class="line">...(생략)...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Bean 정의 파일인 context:component-scan을 이용하는 방법(context:component-scan을 어느 정도 크기의 컴포넌트마다 기술해두고, 만약 어떤 컴포넌트를 테스트용으로 바꾸고자 할 때는 그 컴포넌트 부분의 정의만 테스트용 부품을 스캔하게 수정하는 방법이다.)</p></li></ol><h2 id="확장된-component">확장된 @Component</h2><p>@Component에는 확장된 어노테이션이 있습니다. 웹 애플리케이션 개발에는 @Component를 이용할 것이 아니라 <strong>클래스가 어느 레이어에 배치될지 고려해서 배치될 레이어에 있는 @Component 확장 어노테이션을 사용하는 것이 좋습니다.</strong> 예를 들어 ProductServiceImpl은 @Component가 아니라 @Service로 바꾸는 편이 좋고, ProductDaoImpl 클래스도 @Component가 아니라 @Repository로 바꾸는 편이 좋습니다.</p><ul><li>@Controller : 프레젠테이션 층 스프링 MVC용 어노테이션</li><li>@Service : 비즈니스 로직 층 Service용 어노테이션, @Component와 동일</li><li>@Repository : 데이터 엑세스 층의 DAO용 어노테이션</li><li>@Configuration : Bean 정의를 자바 프로그램에서 실행하는 JavaConfig용 어노테이션</li></ul><p>@Component와 함께 사용하는 어노테이션의 하나로 @Scope가 있습니다. @Scope 뒤에 Value 속성을 지정하면 인스턴스화와 소멸을 제어할 수 있습니다. @Scope를 생략하면 해당 클래스는 싱글턴이 됩니다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"singletone"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductDaoImple</span> <span class="keyword">implements</span> <span class="title">ProductDao</span> </span>&#123;</span><br><span class="line">...(생략)...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>singleton : 인스턴스를 싱글턴으로 함</li><li>prototype : 이용할 때마다 인스턴스화함</li><li>request : Servlet API의 request 스코프인 동안만 인스턴스가 생존함</li><li>session : Servlet API의 session 스코프인 동안만 인스턴스가 생존함</li><li>application : Servlet API의 application 스코프인 동안만 인스턴스가 생존함</li></ul><p>value 속성의 값은 직접 문자열로 넣어도 되지만, 상수가 존재하기 때문에 상수를 사용하는 것이 좋습니다.</p><ul><li>singleton : BeanDefinition.SCOPE_SINGLETON</li><li>prototype : BeanDefinition.SCOPE_PROTOTYPE</li><li>request : WebApplicationContext.SCOPE_REQUEST</li><li>session : WebApplicationContext.SCOPE_SESSION</li><li>application : WebApplicationContext.SCOPE_APPLICATION</li></ul><h2 id="생명-주기-관리">생명 주기 관리</h2><p>스프링 DI 컨테이너에는 인스턴스의 생성과 소멸 타이밍에 호출되는 메서드를 설정할 수 있는 @PosetConstruct와 @PreDestroy라는 2개의 어노테이션이 있습니다.</p><ul><li>@PostConstruct : 초기 처리를 하는 메서드 선언. 메서드 이름은 임의로 지정할 수 있다. 단, 메서드 인수 없이 반환형은 void 형으로 해야한다.</li><li>@PreDestroy : 종료 처리를 하는 메서드 선언. 메서드 이름은 임의로 지정할 수 있다. 단, 메서드 인수 없이 반환형은 void 형으로 해야한다.</li></ul><p>@PostConstruct는 DI 컨테이너에 의해 인스턴스 변수에 무언가 인젝션된 다음에 호출됩니다. 따라서 인젝션 된 값으로 초기 처리를 할 때 사용합니다. (생성자에서도 초기 처리를 할 수 있습니다.)@PreDestroy는 소멸자가 없는 자바에서 종료 처리를 하기 위해 사용합니다.</p><h1 id="참고">참고</h1><ul><li><a href="http://wiki.javajigi.net/pages/viewpage.action?pageId=281" target="_blank" rel="noopener">Spring Core API 및 IoC(DI)</a></li><li><a href="http://www.javajigi.net/pages/viewpage.action?pageId=5614#SpringIoC%EA%B0%9C%EB%85%90%EB%B0%8F%ED%99%9C%EC%9A%A9%EB%B0%A9%EC%95%88-1.IoC%EC%9D%98%EA%B0%9C%EB%85%90" target="_blank" rel="noopener">Spring IoC 개념 및 활용방안</a></li><li><a href="http://www.javajigi.net/pages/viewpage.action?pageId=68" target="_blank" rel="noopener">IoC 컨테이너와 의존성 삽입 패턴</a></li><li><a href="https://okky.kr/article/415474" target="_blank" rel="noopener">자바EE의 역사 및 스프링과의 관계</a></li><li><a href="http://isstory83.tistory.com/91" target="_blank" rel="noopener">Spring - IoC &amp; DI</a></li><li><a href="http://www.hanbit.co.kr/store/books/look.php?p_code=B9146679987" target="_blank" rel="noopener">스프링4 입문 - 한빛미디어</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ioc란&quot;&gt;IoC란?&lt;/h1&gt;
&lt;p&gt;IoC 컨테이너 개념을 이해하기 위하여 이와 같은 컨테이너가 왜 등장하게 되었는지를 먼저 이해하는 것이 중요합니다.&lt;/p&gt;
&lt;p&gt;애플리케이션 코드를 작성할 때, 특정 기능이 필요하면 라이브러리 사용하곤
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Spring" scheme="https://jongmin92.github.io/categories/Programming/Spring/"/>
    
    
      <category term="Spring" scheme="https://jongmin92.github.io/tags/Spring/"/>
    
      <category term="IoC" scheme="https://jongmin92.github.io/tags/IoC/"/>
    
      <category term="DI" scheme="https://jongmin92.github.io/tags/DI/"/>
    
  </entry>
  
  <entry>
    <title>Java와 함께하는 Web</title>
    <link href="https://jongmin92.github.io/2018/02/05/Spring/web-with-java/"/>
    <id>https://jongmin92.github.io/2018/02/05/Spring/web-with-java/</id>
    <published>2018-02-05T06:30:00.000Z</published>
    <updated>2018-02-17T16:05:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="서론">서론</h1><p>Javascript를 이용한 Node.js로 서버프로그래밍을 하다가 최근 <strong>Java를 이용한 Spring Framework를 사용하게 되면서 JavaEE, Servlet, JSP, Tomcat, MVC, WAS와 같은 용어들을 마주하게 되었습니다.</strong> 이번 포스팅을 통해서 Java를 이용한 웹 개발의 히스토리와 여러 용어들을 정리해보고자 합니다.</p><h1 id="시작은-javaee">시작은 JavaEE</h1><p>기존에는 기업용 서버 소프트웨어 개발이라는 것이 C나 C++을 사용해서 다양한 회사의 미들웨어(middleware) 제품들을 사용해서 개발하는 방식이었습니다. 그러나 이 경우 개발자들은 운영체제와 사용하는 미들웨어 제품에 종속될 수 밖에 없는데, <strong>자바의 플랫폼 독립적 특성</strong>을 활용해서 미들웨어에 필요한 공통 API를 제공하면 그런 문제를 해결할 수 있을 것이라는 생각을 했습니다.그래서 서버 개발에 필요한 기능을 모아서 J2EE라는 표준을 만들었습니다. 그리고 이 J2EE는 버전 5.0 이후로 Java EE로 개칭됩니다.</p><p>자바 플랫폼, 엔터프라이즈 에디션(Java Platform, Enterprise Edition; Java EE)은 자바를 이용한 서버측 개발을 위한 플랫폼입니다. Java EE 플랫폼은 PC에서 동작하는 표준 플랫폼인 Java SE에 부가하여, 웹 애플리케이션 서버에서 동작하는 장애복구 및 분산 멀티티어를 제공하는 자바 소프트웨어의 기능을 추가한 서버를 위한 플랫폼입니다. 이러한 Java EE 스펙에 따라 제품으로 구현한 것을 <code>웹 애플리케이션 서버</code> 또는 <code>WAS</code>라 부릅니다.</p><blockquote><p><strong>WAS란?</strong>인터넷 상에서 HTTP를 통해 사용자 컴퓨터나 장치에 애플리케이션을 수행해 주는 미들웨어(소프트웨어 엔진)이다. <strong>웹 애플리케이션 서버는 동적 서버 콘텐츠를 수행하는 것으로 일반적인 웹 서버와 구별이 되며, 주로 데이터베이스 서버와 같이 수행이 된다.</strong><img src="/images/post/2018-02-05/was.png" alt="">&lt; 사용자 요청(웹 브라우저) -&gt; 웹 서버 -&gt; WAS(동적 처리) -&gt; 웹 서버 -&gt; 사용자 응답 메세지(웹 브라우저) &gt;예로, 웹 서버에서 JSP를 요청하면 톰캣에서는 JSP 파일을 서블릿으로 변환하여 컴파일을 수행하고, 서블릿의 수행결과를 웹 서버에서 전달하게 된다.</p></blockquote><p>그렇게 시작된 자바EE는 출발부터 많은 관심을 받았고, 특히 웹 개발을 위해 자바EE 표준에 포함된 **서블릿(Servlet)**과 <strong>JSP</strong>는 당시 막 유행하던 PHP나 ASP와 함께 <code>CGI</code>를 몰아내며 자바 언어가 인기를 얻는데 한 몫을 담당했습니다.</p><blockquote><p><strong>CGI란?</strong> (인용 - http://www.terms.co.kr/CGI.htm)<strong>CGI는 웹서버에 있어 사용자의 요구를 응용프로그램에 전달하고 그 결과를 사용자에게 되돌려주기 위한 표준적인 방법이다.</strong> 사용자가 하이퍼링크를 클릭 하거나 웹사이트의 주소를 입력함으로써 웹 페이지를 요청하면, 서버는 요청된 페이지를 보내준다. 그러나, 사용자가 웹페이지의 양식에 내용을 기재하여 보냈을 때, 그것은 보통 응용프로그램에 의해 처리될 필요가 있다. 웹 서버는 그 양식 정보를 조그만 응용프로그램에 전달하는데, 이 프로그램은 데이터를 처리하고 필요에 따라 확인 메시지를 보내주기도 한다. 이렇게 <strong>서버와 응용 프로그램간에 데이터를 주고받기 위한 방법이나 규약들을 CGI라고 부른다.</strong> 이것은 웹의 HTTP 프로토콜의 일부이다.만약 웹사이트를 만들 때 어떠한 제어를 위해 CGI 프로그램을 사용하기 원하면, HTML 파일 내에 있는 URL 내에 그 프로그램의 이름을 기술하면 된다. 만약 폼을 만들려고 할 때, 이 URL은 FORMS 태그의 일부로서 기술될 수 있는데, 예를 들어 아래와 같이 쓸 수 있을 것이다.이 태그의 결과로서 mybiz.com에 있는 서버는 입력된 데이터를 저장하기 위해 제어권을 &quot;formprog.pl&quot;이라는 CGI 프로그램에 넘기고, 확인 메시지를 되돌려준다 (여기서 .pl은 Perl로 작성된 프로그램이라는 것을 가리키지만, CGI는 다른 언어로도 작성될 수 있다).<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FORM</span> <span class="attr">METHOD</span>=<span class="string">POST</span> <span class="attr">ACTION</span>=<span class="string">http://www.mybiz.com/cgi-local/formprog.pl</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><p>자바EE의 핵심은 EJB(Enterprise Java Beans)라는 기술이었습니다. EJB는 자바EE가 대체하는 미들웨어에서 구동되던 기업의 핵심 서비스를 만들기 위한 분산처리 및 트랜잭션, 보안 등을 지원하는 컴포넌트 모델을 제공하는 기술입니다. 이러한 EJB는 주목을 받으며 널리 쓰이게 되었지만 시간이 지남에 따라 몇 가지 심각한 문제들로 비판을 받게 되었고, 이러한 문제점을 개선하기 위해 Spring Framework가 처음 개발되었습니다. 특히 고가의 풀스택 자바EE 서버가 아닌 톰캣과 같은 일반 서블릿 컨테이너에서도 구동된다는 것이 큰 강점으로 작용했습니다.</p><p>다시 말하면, 이는 Spring을 통해 비싼 자바EE 서버를 구매하지 않아도 EJB보다 훨씬 간편한 방식으로 EJB가 제공하던 선언적 트랜잭션 및 보안 처리, 분산 환경 지원 등 주요 기능을 모두 사용할 수 있게 되었음을 뜻하며, 무엇보다 이제는 더 이상 각 자바EE 서버 제품에 특화된 설정을 따로 공부하거나 서버 제품을 바꿀 때마다 포팅 작업이 필요없이 Spring만 이용하면 톰캣이든 레진(Resin)이든 기존의 풀스택 자바EE 서버이든 관계없이 간단하게 배포가 가능하다는 뜻입니다.</p><h1 id="servlet">Servlet</h1><p><strong><code>Servlet</code>은 Java 기반의 확장된 CGI로서 동일하게 동적인 웹 애플리케이션을 작성할 수 있는 기술입니다.</strong> CGI와 비슷하게 클라이언트의 요청을 받아 해당하는 프로그램을 실행시켜주지만 CGI와는 조금 다른 동작 형태를 보입니다.Servlet은 CGI와 달리 효율적입니다. <strong>CGI의 멀티 프로세스 동작이 아닌 멀티 스레드 방식의 동작으로 서블릿이 생성되면 서버가 종료되지 않는 이상 메모리로 남게 됩니다.</strong> 따라서 이후에 오는 요청에 대해서는 서블릿을 새로 생성하지 않고 동작을 이어갈 수 있기 때문에 시스템 자원(메모리)에서 큰 이점이 있습니다. <strong>그로인해 Servlet은 CGI 보다 적은 시스템 자원으로 많은 요청을 처리할 수 있는 구조를 가지고 있습니다.</strong></p><h2 id="멀티-프로세스-동작-방식">멀티 프로세스 동작 방식</h2><p><img src="/images/post/2018-02-05/multi_process.png" alt="">클라이언트의 요청을 받아 웹 애플리케이션을 직접 실행하는 구조로 <strong>각각의 요청에 대해 프로세스를 생성하고 응답한 뒤 종료하는 형태</strong>이다. 이는 각각의 많은 요청이 들어오는 경우 프로세스를 계속 생성하므로(프로세스를 생성하는 작업은 필요이상의 부담을 주게 된다) 시스템 부하가 커지게 되 안정적인 서비스가 힘들다.</p><h2 id="멀티-스레드-동작-방식">멀티 스레드 동작 방식</h2><p><img src="/images/post/2018-02-05/multi_thread.png" alt=""><strong>클라이언트의 요청을 받으면 웹 애플리케이션을 거치지 않고 <code>웹 컨테이너</code>로 요청이 전달된다. 그리고 웹 컨테이너가 요청을 처리할 스레드를 생성하는 형태이다.</strong> 멀티스레드 방식은 최초 요청 시 웹 애플리케이션을 실행한 후 종료하지 않은 상태에서 같은 요청이 여러 번 오는 경우, 실행되고 있는 웹 애플리케이션의 스레드를 생성해 요청을 처리하는 방법이다. <strong>CGI에서 사용하는 멀티프로세스 방식보다 시스템 부하를 줄여 안정적인 서비스를 제공할 수 있다.</strong></p><blockquote><p><strong>컨테이너란?</strong> (인용 - <a href="http://yayongi.tistory.com/entry/%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C" target="_blank" rel="noopener">컨테이너란?? 무엇일까?</a>)<strong>컨테이너는 Servlet을 실행하고 관리하는 역할을 합니다. 개발자가 해야하는 역할을 대신 함으로써, 개발자가 해야하는 일을 대폭 줄여줍니다.</strong> 컨테이너는 개발자가 웹서버와 통신하기 위하여 소켓을 생성하고, 특정 포트에 리스닝하고, 스트림을 생성하는 등의 복잡한 일들을 대신합니다. 또한 Servlet의 생성부터 소멸까지 일련의 과정을 관리하며, 요청이 들어올 때마다 새로운 자바 스레드를 하나 생성합니다.톰캣을 예로 들면 아파치와 같은 웹서버가 사용자로부터 Servlet에 대한 요청을 받으면 이것을 바로 호출하는 것이 아니라 컨테이너에게 이 요청을 넘겨주고 이 컨테이너는 <code>request와 response 객체를 생성</code>하고 해당하는 <code>Servlet의 스레드를 생성</code>하여 앞의 <code>두 객체를 인자로 넘깁니다.</code>스레드 생성 후 이 <code>스레드의 service() 메소드를 호출</code>하고 처음에 사용자로부터 요청받은 방식이 get인지 post인지에 따라 <code>doGet()과 doPost() 메소드 중 선택 생성</code>합니다. 만약 doPost가 생성되었다고 가정하면, 이 doPost() 메소드는 독 페이지를 생성하고, 이것을 처음 받은 response 객체에 실어서 컨테이너에게 보냅니다. 컨테이너는 <code>이 객체를 HTTPResponse로 변환하여 클라이언트에게 보냅니다.</code> 그런 다음 처음에 생성한 <code>객체 Request와 Response를 소멸</code>시킵니다.</p></blockquote><h2 id="servlet-동작-방식">Servlet 동작 방식</h2><p><img src="/images/post/2018-02-05/servlet.png" alt=""></p><ol><li>사용자가 URL을 클릭하면 HTTP Request를 Servlet Container에 보낸다.</li><li>Servlet Container는 HttpServletRequest, HttpServletResponse 두 객체를 생성한다.</li><li>사용자가 요청한 URL을 분석하여 어느 서블릿에 대한 요청인지 찾는다. (<strong>DD</strong>를 참조하여 분석)</li><li>컨테이너는 서블릿 service() 메소드를 호출하며, POST, GET여부에 따라 doGet() 또는 doPost()가 호출된다.</li><li>doGet() or doPost() 메소드는 동적인 페이지를 생성한 후 HttpServletResponse객체에 응답을 보낸다.</li><li>응답이 완료되면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킨다.</li></ol><blockquote><p><strong>DD (배포서술자, Deployment Descriptor) = web.xml</strong></p></blockquote><ul><li>Servlet, Error Page, Listener, Fillter, 보안 설정등 Web Application의 설정 파일이다.</li><li>URL과 실제 서블릿의 매핑 정보도 담고 있다.</li><li>하나의 웹 어플리케이션에 하나만 존재한다.</li><li>보통 Web Document Root 디렉토리에 WEB-INF 폴더 아래 web.xml 파일로 존재한다.</li></ul><p>한마디로 정리하자면 톰캣과 같은 <code>WAS</code> 가 java 파일을 컴파일해서 Class로 만들고 메모리에 올려 <code>Servlet 객체</code>를 만들게 되고 이 <code>Servlet 객체</code>는 <code>doPost</code>, <code>doGet</code>을 통해 요청에 응답합니다. 초기화 과정을 더 자세히 보면 다음과 같습니다.<img src="/images/post/2018-02-05/servlet_detail.png" alt=""><code>init</code>, <code>Service</code>, <code>destory</code> 이런 콜백이 각 시점에 불리는걸 볼 수 있습니다. <code>init</code>은 Servlet이 메모리에 로드 될때 실행됩니다. <code>destory</code>는 마찬가지로 언로드되기 전에 수행되는 콜백입니다. <code>service</code> 메소드는 HTTP Method 타입에 따라 <code>doGet</code> 혹은 <code>doPost</code>를 호출합니다.기억해야 할 점은, 초기화된 Servlet이 클라이언트의 요청이 있을 때 마다 <code>Thread</code>를 생성해서 병렬적으로 <code>service</code>를 수행한다는 것. 서블릿 객체는 <strong>여러개 생성되지 않습니다.</strong></p><h2 id="servlet-예시-코드">Servlet 예시 코드</h2><p>다음은 Servlet의 예시 코드입니다. 자바 코드 안에 HTML을 넣기 굉장히 불편합니다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span> <span class="keyword">throws</span> ServletException,IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">res.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">PrintWriter out = res.getWriter();</span><br><span class="line"></span><br><span class="line">out.println(<span class="string">"&lt;HTML&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"&lt;BODY&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"Hello World!!"</span>);</span><br><span class="line">out.println(<span class="string">"&lt;/BODY&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"&lt;/HTML&gt;"</span>);</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="jsp">JSP</h1><p>HTML을 넣기 불편한 구조로 인해 JSP가 등장하게 됬습니다. Servlet의 확장된 기술로 브라우저에 표현하기 위한 HTML 코드에 JAVA 코드를 혼용하여 사용할 수 있게 합니다. 이로써 디자인과 로직 개발을 분업화시켜 효율적인 코드를 생산해 낼 수 있게됩니다.</p><h2 id="jsp-동작-방식">JSP 동작 방식</h2><p>JSP 라는 새로운 개발 방법이 나왔지만, 사실 이 <strong><code>JSP</code> 도 내부적으로는 아래 그림 처럼 <code>Tomcat</code>이 <code>Servlet</code>으로 바꾸어서 돌립니다.</strong><img src="/images/post/2018-02-05/jsp.png" alt=""></p><ol><li>클라이언트가 브라우저를 통해 서버에 HTTP 프로토콜로 요청한다.</li><li>서버는 컨테이너에게 처리를 요청하고 컨테이너는 해당 파일을 찾는다.</li><li>찾은 파일을 서블릿으로 변환한다. 만약 이미 변환 되어있는 파일이 있다면 그 파일을 바로 실행⑤한다.</li><li>서블릿 파일을 실행가능한 class파일로 컴파일 한다.</li><li>컴파일된 class파일을 메모리에 적재하고 실행한 결과를 웹서버에 넘겨준다.</li><li>웹서버는 브라우저가 인식할수 있는 정적페이지를 구성하여 클라이언트에게 응답한다.</li></ol><h2 id="jsp-예시-코드">JSP 예시 코드</h2><p>HTML 내부에 Java 코드가 있어 HTML 코드를 작성하기 쉽습니다. 그러나 <strong>로직과 디자인이 한 파일내에 섞여있어 유지보수가 어렵습니다.</strong> 하나가 편한대신, 다른 불편한 점들이 생긴것 입니다. 그래서 이를 해결하기 위해 <code>MVC Model</code>이 등장하였습니다.<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">"java.util.Calendar"</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html; charset=UTF-8"</span>%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  String str=String.format(<span class="string">"%tF"</span>,Calendar.getInstance());</span><br><span class="line">%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    오늘은 &lt;%=str%&gt;&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="mvc-model-1">MVC Model 1</h2><p><img src="/images/post/2018-02-05/mvc_model1.png" alt="">Model1 방식은 사용자로부터 요청을 JSP가 받아(더 정확히는 JSP 에서 사용자가 요청을 합니다.) <code>Java Bean</code>(DTO, DAO)을 호출해 처리합니다.이 방식은 개발 속도가 빠르고 배우기 쉽지만 프레젠테이션 로직과 비즈니스 로직이 혼재하기 때문에 JSP 코드가 복잡해져 유지 보수가 어려워진다는 단점이 있습니다.</p><h2 id="mvc-model-2">MVC Model 2</h2><p><img src="/images/post/2018-02-05/mvc_model2.png" alt="">단순히 JSP만 사용하거나, Servlet만 사용하는 것이 아니라 두개의 장단점을 모두 취해 <code>View</code> 는 <code>JSP</code>로, <code>Controller</code>는 <code>Servlet</code>을 사용한 것이 Model2 입니다. 보여지는 부분은 HTML이 중심이 되는 <code>JSP</code>, 다른 자바 클래스에게 데이터를 넘겨주는 부분은 Java 코드가 중심이 되는 <code>Servlet</code>이 담당하게 됩니다. 그리고 <code>Model</code> 영역 에서는 DTO, DAO를 통해 Mysql 과 같은 데이터베이스에 접근합니다.</p><h1 id="참고">참고</h1><ul><li><a href="https://okky.kr/article/415474" target="_blank" rel="noopener">자바EE의 역사 및 스프링과의 관계</a></li><li><a href="https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%ED%94%8C%EB%9E%AB%ED%8F%BC,_%EC%97%94%ED%84%B0%ED%94%84%EB%9D%BC%EC%9D%B4%EC%A6%88_%EC%97%90%EB%94%94%EC%85%98" target="_blank" rel="noopener">위키백과 - 자바 플랫폼, 엔터프라이즈 에디션</a></li><li><a href="http://dzlove.tistory.com/entry/%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%9E%90%EB%B0%94-%EC%84%9C%EB%B8%94%EB%A6%BF%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%EC%9B%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D" target="_blank" rel="noopener">서블릿-자바-서블릿으로-알아보는-웹-프로그래밍</a></li><li><a href="http://myblog.opendocs.co.kr/archives/427" target="_blank" rel="noopener">Servlet - Concept</a></li><li><a href="http://a07274.tistory.com/314" target="_blank" rel="noopener">Java Servlet 이란? (개념 및 예제)</a></li><li><a href="http://anster.tistory.com/128" target="_blank" rel="noopener">JSP와 Servlet, 왜 같이 쓸까?</a></li><li><a href="http://myblog.opendocs.co.kr/archives/440" target="_blank" rel="noopener">JSP - Concept</a></li><li><a href="http://www.javajigi.net/pages/viewpage.action?pageId=73" target="_blank" rel="noopener">Model1, Model2 개발 방식</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Javascript를 이용한 Node.js로 서버프로그래밍을 하다가 최근 &lt;strong&gt;Java를 이용한 Spring Framework를 사용하게 되면서 JavaEE, Servlet, JSP, Tomcat, M
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
    
      <category term="MVC" scheme="https://jongmin92.github.io/tags/MVC/"/>
    
      <category term="JavaEE" scheme="https://jongmin92.github.io/tags/JavaEE/"/>
    
      <category term="Servlet" scheme="https://jongmin92.github.io/tags/Servlet/"/>
    
      <category term="JSP" scheme="https://jongmin92.github.io/tags/JSP/"/>
    
      <category term="Tomcat" scheme="https://jongmin92.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ에서 SpringBoot 프로젝트 생성하기</title>
    <link href="https://jongmin92.github.io/2018/02/04/Spring/springboot-start/"/>
    <id>https://jongmin92.github.io/2018/02/04/Spring/springboot-start/</id>
    <published>2018-02-04T14:00:00.000Z</published>
    <updated>2018-02-05T06:11:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="서론">서론</h1><p>Spring은 J2EE나 JEE로 알려진 자바 엔터프라이즈 에디션을 경량화하기 위해 시작되었다. 스프링은 무거운 엔터프라이즈 자바 빈(EJB)로 컴포넌트를 개발하지 않았다. 그 대신 의존성 주입(DI)과 관점 지향 프로그래밍(AOP)을 활용해서 EJB의 기능을 평범한 자바 객체(POJO)로 구현할 수 있게 하여 간단하게 엔터프라이즈 자바 개발에 접근할 수 있도록 했다.컴포넌트 코드 작성은 가벼워졌지만, <strong>Spring Framework 기반의 웹 프로젝트를 진행하게되면 최초 개발 구성(설정)하는 부분에 많은 시간이 소모되었다.</strong> 결국 애플리케이션 로직 작성이 아닌 프로젝트 구성 작업에 쓰는 시간이 많이 Gk소모되는 것이다.<strong><code>SpringBoot</code>는 Spring의 복잡한 설정을 최소화하여 빠르게 프로젝트 개발을 시작할 수 있게 해준다.</strong> 이 포스팅에서는 IntelliJ에서 SpringBoot로 웹 프로젝트를 시작하는 방법을 소개하며 SpringBoot의 특징을 소개한다.</p><h1 id="intellij에서-springboot-프로젝트-생성">IntelliJ에서 SpringBoot 프로젝트 생성</h1><p><strong><code>Spring Initializr</code>는 SpringBoot 프로젝트 구조를 만드는 웹 애플리케이션이다.</strong> 기본적인 프로젝트 구조와 코드를 빌드하는 데 필요한 maven이나 gradle 빌드 명세를 만들어준다. 그러므로 Spring Initializr가 만든 프젝트에 애플리케이션 코드만 작성하면 된다.Spring Initializr는 웹 기반 인터페이스, Spring Tool Suite(STS), IntelliJ IDE, SpringBoot CLI로 사용할 수 있다. 그 중 IntelliJ를 사용해 프로젝트를 생성해보자.</p><p>IntelliJ를 시작하여 <strong>Create New Project</strong>를 선택하고 새로운 프로젝트 다이얼로그를 연다. <strong>New Project</strong> 다이얼로그에서 <strong>Spring Initializr</strong> 프로젝트를 선택하고 자바 SDK를 설정한 후 Next 버튼을 누른다.<img src="/images/post/2018-02-04/new_project_1.png" alt=""></p><p>두 번째 화면에서는 프로젝트 이름, 빌드할 때 maven과 gradle 중 어느 것을 사용할지, 자바 버전 등 프로젝트의 기본적인 사항을 물어본다. 프로젝트 정보를 입력하고 Next 버튼을 누른다.<img src="/images/post/2018-02-04/new_project_2.png" alt=""></p><p>세 번째 화면에서는 프로젝트에서 필요한 종류의 의존성을 추가한다. <strong>Web, Thymeleaf, JPA, H2</strong>를 선택한 후 Next 버튼을 누른다.<img src="/images/post/2018-02-04/new_project_3.png" alt=""></p><p>다음으로 프로젝트가 저장되는 경로를 지정한다.<img src="/images/post/2018-02-04/new_project_4.png" alt=""></p><p>Gradle 설정을 지정한다.<img src="/images/post/2018-02-04/new_project_5.png" alt=""></p><h1 id="코드-작성">코드 작성</h1><h2 id="도메인-정의-diaryjava">도메인 정의 (Diary.java)</h2><p><strong>src/main/java/com.example.demo/Diary.java</strong> 파일을 작성한다.일기를 나타내는 엔티티 정의한다. 간단하게 id, title, ocntent 필드를 갖고 있는 <strong>POJO 객체</strong>로 만든다. <code>@Entity</code> 어노테이션을 붙여 클래스를 JPA 엔티티로 지정했고, id 필드에는 <code>@Id</code>와 <code>@GeneratedValue</code> 어노테이션을 붙여 엔티티의 유일성을 식별하고 자동으로 값을 제공하는 필드로 지정했다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Diary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="레파지토리-인터페이스-선언-diarylistrepositoryjava">레파지토리 인터페이스 선언 (DiaryListRepository.java)</h2><p><strong>src/main/java/com.example.demo/DiaryListRepository.java</strong> 파일을 작성한다.<strong>데이터베이스에 Diary 객체를 저장할 수 있는 레파지토리를 선언한다.</strong> 스프링 JPA를 사용하므로 스프링 데이터 JAP의 인터페이스를 상속하여 인터페이스를 만든다. JpaRepository 인터페이스는 타입 매개변수 두 개를 받는다. 첫 번째는 레파지토리가 사용할 도메인 타입, 두번 째는 클래스의 ID 프로퍼티 타입이다. 지정한 유저의 이름으로 도서 목록을 검색하는 findByUser() 메서드를 추가했다.DiaryListRepository는 JpaRepository 인터페이스를 상속받아 18개의 메서드를 구현해야 한다. 그러나 스프링 데이터는 레파지토리를 인터페이스로 정의만 해도 잘 작동할 수 있게 런타임 시에 자동으로 구현해준다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiaryListRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Diary</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Diary&gt; <span class="title">findByUser</span><span class="params">(String user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="일기-목록-애플리케이션의-스프링-mvc-컨트롤러-diarylistcontrollerjava">일기 목록 애플리케이션의 스프링 MVC 컨트롤러 (DiaryListController.java)</h2><p><strong>src/main/java/com.example.demo/DiaryListController.java</strong> 파일을 작성한다.클래스에 <code>@Controller</code> 어노테이션을 추가하면, 자동 컴포넌트 검색으로 DiaryListController를 발견해 자동으로 스프링 애플리케이션 컨텍스트에 빈으로 등록한다. 요청을 처리하는 모든 메서드를 기본 URL 경로인 /로 매핑하기 위해 <code>@RequestMapping</code> 어노테이션을 붙였다.usersDiarys() 메서드는 &quot;diaryList&quot;를 논리적 뷰 이름으로 반환한다. 그러므로 이 뷰도 만들어야 한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiaryListController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String user=<span class="string">"jongmin"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DiaryListRepository diaryListRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiaryListController</span><span class="params">(DiaryListRepository diaryListRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.diaryListRepository = diaryListRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(method= RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">usersDiarys</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        List&lt;Diary&gt; diaryList = diaryListRepository.findByUser(user);</span><br><span class="line">        <span class="keyword">if</span> (diaryList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            model.addAttribute(<span class="string">"diarys"</span>, diaryList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"diaryList"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addToReadingList</span><span class="params">(Diary diary)</span> </span>&#123;</span><br><span class="line">        diary.setUser(user);</span><br><span class="line">        diaryListRepository.save(diary);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="일기-목록을-보여주는-thymeleaf-탬플릿-diarylisthtml">일기 목록을 보여주는 Thymeleaf 탬플릿 (diaryList.html)</h2><p><strong>src/main/resources/template/diaryList.html</strong> 파일을 작성한다.유저의 일기 목록 부분과 일기를 일기 목록에 추가할 때 사용하는 입력 폼을 작성한다.<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span> xmlns:th=<span class="string">"http://www.springframework.org/schema/data/jaxb"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span> /&gt;</span><br><span class="line">  &lt;title&gt;일기 리스트&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;일기 목록&lt;/h2&gt;</span><br><span class="line">&lt;div th:unless=<span class="string">"$&#123;#lists.isEmpty(diarys)&#125;"</span>&gt;</span><br><span class="line">  &lt;dl th:each=<span class="string">"diary : $&#123;diarys&#125;"</span>&gt;</span><br><span class="line">    &lt;dt&gt;</span><br><span class="line">      &lt;span th:if="$&#123;diary.title&#125;" th:text="$&#123;diary.title&#125;"&gt;Title&lt;/span&gt;</span><br><span class="line">    &lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;</span><br><span class="line">      &lt;span th:if="$&#123;diary.content&#125;" th:text="$&#123;diary.content&#125;"&gt;Content&lt;/span&gt;</span><br><span class="line">    &lt;/dd&gt;</span><br><span class="line">  &lt;/dl&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr /&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;일기 작성&lt;/h3&gt;</span><br><span class="line">&lt;form method=<span class="string">"POST"</span> th:action=<span class="string">"@&#123;/&#125;"</span>&gt;</span><br><span class="line">  &lt;label for="title"&gt;Title:&lt;/label&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"title"</span> size=<span class="string">"50"</span> /&gt;&lt;br /&gt;</span><br><span class="line">  &lt;label for="content"&gt;Content:&lt;/label&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"content"</span> size=<span class="string">"100"</span> /&gt;&lt;br /&gt;</span><br><span class="line">  &lt;input type=<span class="string">"submit"</span> value=<span class="string">"추가"</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h1 id="실행-결과">실행 결과</h1><p><img src="/images/post/2018-02-04/result.png" alt=""></p><h1 id="springboot-특징-살펴보기">SpringBoot 특징 살펴보기</h1><p>SpringBoot를 이용해 간단한 애플리케이션을 만들어 보았다. 이 애플리케이션을 바탕으로 SpringBoot의 특징을 알아보자.</p><h2 id="스타터-의존성">스타터 의존성</h2><p>처음 프로젝트를 생성하며 Spring Initializr에서 필요한 Dependencies들(Web, Thymeleaf, JPA, H2)을 쉽게 추가했었다. 만약 이런 <code>스타터 의존성</code>이 없었다면, 애플리케이션을 개발하기도 전에 <strong>build.gradle</strong> 또는 <strong>pom.xml</strong>에서 필요한 Dependencies를 직접 추가해야했을 것이다. (또햔, 여러 의존성들 사이에 잘 호환이 되는지도 확인해야 한다.)</p><p>프로젝트의 <strong>build.gradle</strong> 코드를 잠시 살펴보자.<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line"><span class="keyword">compile</span>(<span class="string">'org.springframework.boot:spring-boot-starter-data-jpa'</span>)</span><br><span class="line"><span class="keyword">compile</span>(<span class="string">'org.springframework.boot:spring-boot-starter-thymeleaf'</span>)</span><br><span class="line"><span class="keyword">compile</span>(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line"><span class="keyword">runtime</span>(<span class="string">'com.h2database:h2'</span>)</span><br><span class="line">testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Spring Initializr에서 체크했던 의존성들이 gradle에 추가되어 있는것을 볼 수 있다. 또한 각 라이브러리의 버전이 명시되어 있지 않은데, 이는 SpringBoot 버전에 따라 스타터 의존성 버전이 결정되기 때문이다. 즉, 사용자는 스타터 의존성만 지정하면 어떤 라이브러리와 어떤 버전을 사용해야 하는지 걱정없이 구성에서 자유로워질 수 있는 것이다.</p><h2 id="자동-구성">자동 구성</h2><p>SpringBoot <code>Auto-configuration</code>은 <strong>스프링 구성을 적용해야 할지 말지를 결정하는 요인들을 판단하는 런타임 과정이다.</strong> 애플리케이션이 시작될 때마다 스프링 부트는 보안, 통합, 데이터 저장, 웹 개발 영역 등을 커버하기 위해 자도성에서 대략 200가지 정도 결정을 내린다. 이 자동 구성 덕분에 필요한 상황이 아니면 명시적으로 구성을 작성하지 않아도 된다.</p><h1 id="참고">참고</h1><ul><li>스프링 부트 코딩 공작소</li><li>http://blog.saltfactory.net/creating-springboot-project-in-intellij/</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Spring은 J2EE나 JEE로 알려진 자바 엔터프라이즈 에디션을 경량화하기 위해 시작되었다. 스프링은 무거운 엔터프라이즈 자바 빈(EJB)로 컴포넌트를 개발하지 않았다. 그 대신 의존성 주입(DI)과 관점 
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Spring" scheme="https://jongmin92.github.io/categories/Programming/Spring/"/>
    
    
      <category term="SpringBoot" scheme="https://jongmin92.github.io/tags/SpringBoot/"/>
    
      <category term="IntelliJ" scheme="https://jongmin92.github.io/tags/IntelliJ/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit2 네트워크 타임아웃 시간 설정하기</title>
    <link href="https://jongmin92.github.io/2018/01/31/Programming/android-customize-network-timeouts/"/>
    <id>https://jongmin92.github.io/2018/01/31/Programming/android-customize-network-timeouts/</id>
    <published>2018-01-31T14:00:00.000Z</published>
    <updated>2018-02-05T01:06:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Retrofit은 기본적인 네트워크 타임아웃 시간 설정을 사용하고 있습니다. 그러나 <strong>여러 상황으로 인해 기본적으로 설정된 타임아웃 시간을 변경할 필요가 생기기도 합니다.</strong>이번 포스팅에서는 3가지의 네트워크 타임아웃 시간 설정에 대해 알아보고 변경해보겠습니다.</p><h2 id="타임아웃-시간-설정">타임아웃 시간 설정</h2><p>Retrofit에서는 기본적으로 다음의 3가지 타임아웃 시간 설정 값을 갖고 있습니다.</p><ul><li>Connection timeout : 10초</li><li>Read timeout : 10초</li><li>Write timeout : 10초</li></ul><h3 id="connection-timeout">Connection Timeout</h3><p><strong>요청을 시작한 후 서버와의 TCP handshake가 완료되기까지 지속되는 시간이다.</strong> 즉, Retrofit이 설정된 연결 시간 제한 내에서 서버에 연결할 수없는 경우 해당 요청을 실패한 것으로 계산한다.따라서 사용자의 인터넷 연결 상태가 좋지 않을때 기본 시간 제한인 10초를 더 높은 값으로 설정하면 좋다.</p><h3 id="read-timeout">Read Timeout</h3><p><strong>읽기 시간 초과는 연결이 설정되면 모든 바이트가 전송되는 속도를 감시한다.</strong> 서버로부터의 응답까지의 시간이 읽기 시간 초과보다 크면 요청이 실패로 계산된다.<code>LongPolling</code>을 위해 변경해 주어야 하는 설정값이다.</p><h3 id="write-timeout">Write Timeout</h3><p><strong>쓰기 타임 아웃은 읽기 타임 아웃의 반대 방향이다. 얼마나 빨리 서버에 바이트를 보낼 수 있는지 확인한다.</strong></p><h2 id="코드">코드</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">        .connectTimeout(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">        .readTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">        .writeTimeout(<span class="number">15</span>, TimeUnit.SECONDS)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">Retrofit.Builder builder = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"http://localhost:3000/"</span>)</span><br><span class="line">        .client(okHttpClient)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create());</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Retrofit은 기본적인 네트워크 타임아웃 시간 설정을 사용하고 있습니다. 그러나 &lt;strong&gt;여러 상황으로 인해 기본적으로 설정된 타임아웃 시간을 변경할 필요가 생기기도 합니다.&lt;/strong&gt;
이번 포스팅에서는 3가지의 네트워크 타임아웃 
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
    
      <category term="Android" scheme="https://jongmin92.github.io/tags/Android/"/>
    
      <category term="Retrofit2" scheme="https://jongmin92.github.io/tags/Retrofit2/"/>
    
      <category term="OkHttp3" scheme="https://jongmin92.github.io/tags/OkHttp3/"/>
    
      <category term="Timeout" scheme="https://jongmin92.github.io/tags/Timeout/"/>
    
      <category term="LongPolling" scheme="https://jongmin92.github.io/tags/LongPolling/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit2 + OkHttp3 사용하기</title>
    <link href="https://jongmin92.github.io/2018/01/29/Programming/android-retrofit2-okhttp3/"/>
    <id>https://jongmin92.github.io/2018/01/29/Programming/android-retrofit2-okhttp3/</id>
    <published>2018-01-29T12:00:00.000Z</published>
    <updated>2018-02-05T01:06:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>신입사원 프로젝트로 간만에 안드로이드 개발을 하게됐습니다. 서버와 통신하기위해 Square에서 만든 Retrofit 라이브러리를 사용했는데, 기존에 사용하던 버전(1.x)과 변경된 부분이 많아 새롭게 사용법을 알아보고자 합니다.Retrofit 테스트는 <a href="https://reqres.in/" target="_blank" rel="noopener">API 테스트 사이트</a>를 통해서 Fake data를 가져오는 실습을 해보겠습니다. 해당 글의 대부분은 <a href="https://www.journaldev.com/13639/retrofit-android-example-tutorial" target="_blank" rel="noopener">Retrofit 2.0 Example</a>을 참고했습니다.</p><h2 id="retrofit2">Retrofit2</h2><p>Retrofit 의외에 다른 라이브러리도 있지만, Retrofit을 사용하기로 한 이유는 성능과 간단한 구현방법 때문입니다. 아래 보시는것과 같이 응답속도가 매우 빠른것으로 나와있습니다. 더 자세한 비교는 <a href="http://instructure.github.io/blog/2013/12/09/volley-vs-retrofit/" target="_blank" rel="noopener">Android Async HTTP Clients: Volley vs Retrofit</a>에서 볼 수 있습니다.</p><p><img src="/images/post/2018-01-29/retrofit_benchmark.png" alt="Retrofit Benchmark"></p><p>Retrofit2는 기본적으로 OkHttp를 네트워킹 계층으로 활용하며 그 위에 구축됩니다.</p><p>Retrofit은 자동적으로 JSON 응답을 사전에 정의된 POJO를 통해 직렬화 할 수 있습니다. JSON을 직렬화 하기 위해서는 먼저 Gson converter가 필요합니다. **<code>build.gradle</code>**에 다음의 dependencies를 추가합니다.<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'com.squareup.retrofit2:retrofit:2.3.0'</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">'com.google.code.gson:gson:2.8.0'</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">'com.squareup.retrofit2:converter-gson:2.1.0'</span></span><br></pre></td></tr></table></figure></p><p>OkHttp는 이미 Retrofit2 모듈의 종속성에 포함되어 있어, 별도의 OkHttp 설정이 필요하다면 다음과 같이 Retrofit2에서 OkHttp 종속성을 제외해야 합니다.<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span>(<span class="string">'com.squareup.retrofit2:retrofit:2.3.0'</span>) &#123;</span><br><span class="line">    <span class="keyword">exclude</span> module: <span class="string">'okhttp'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">compile</span> <span class="string">'com.google.code.gson:gson:2.8.0'</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">'com.squareup.retrofit2:converter-gson:2.1.0'</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">'com.squareup.okhttp3:okhttp:3.9.1'</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">'com.squareup.okhttp3:logging-interceptor:3.9.1'</span></span><br><span class="line"><span class="comment">// logging-interceptor는 반환된 모든 응답에 대해 로그 문자열을 생성합니다.</span></span><br></pre></td></tr></table></figure></p><p>네트워크 사용을 위해서 **<code>AndroidManifest.xml</code>**에서 Internet Permission을 추가합니다.<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="okhttp-interceptors">OkHttp Interceptors</h2><p>**<code>Interceptor</code>**는 OkHttp에 있는 강력한 메커니즘으로 호출을 모니터, 재 작성 및 재 시도를 할 수 있습니다. Interceptor는 크게 두 가지 카테고리로 분류할 수 있습니다.</p><ul><li><strong>Application Interceptors</strong> : Application Interceptor를 등록하려면 <code>OkHttpClient.Builder</code>에서 <code>addInterceptor()</code>를 호출해야 합니다.</li><li><strong>Network Interceptors</strong> : Network Interceptor를 등록하려면 <code>addInterceptor()</code> 대신 <code>addNetworkInterceptor()</code>를 추가해야 합니다.</li></ul><h2 id="retrofit-interface-설정">Retrofit Interface 설정</h2><h3 id="apiclientjava">APIClient.java</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.journaldev.retrofitintro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> okhttp3.OkHttpClient;</span><br><span class="line"><span class="keyword">import</span> okhttp3.logging.HttpLoggingInterceptor;</span><br><span class="line"><span class="keyword">import</span> retrofit2.Retrofit;</span><br><span class="line"><span class="keyword">import</span> retrofit2.converter.gson.GsonConverterFactory;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Retrofit retrofit = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Retrofit <span class="title">getClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpLoggingInterceptor interceptor = <span class="keyword">new</span> HttpLoggingInterceptor();</span><br><span class="line">        interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);</span><br><span class="line">        OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder().addInterceptor(interceptor).build();</span><br><span class="line"></span><br><span class="line">        retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(<span class="string">"https://reqres.in/"</span>)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .client(client)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retrofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>getClient()</code> 메서드는 Retrofit 인터페이스를 설정할 때마다 호출됩니다. Retrofit은 **<code>@GET, @POST, @PUT, @DELETE, @PATCH or @HEAD</code>**와 같은 <strong>annotation</strong>을 통해 HTTP method를 이용합니다.</p><h3 id="apiinterfacejava">APIInterface.java</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.journaldev.retrofitintro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.journaldev.retrofitintro.pojo.MultipleResource;</span><br><span class="line"><span class="keyword">import</span> com.journaldev.retrofitintro.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.journaldev.retrofitintro.pojo.UserList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> retrofit2.Call;</span><br><span class="line"><span class="keyword">import</span> retrofit2.http.Body;</span><br><span class="line"><span class="keyword">import</span> retrofit2.http.Field;</span><br><span class="line"><span class="keyword">import</span> retrofit2.http.FormUrlEncoded;</span><br><span class="line"><span class="keyword">import</span> retrofit2.http.GET;</span><br><span class="line"><span class="keyword">import</span> retrofit2.http.POST;</span><br><span class="line"><span class="keyword">import</span> retrofit2.http.Query;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">APIInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"api/unknown"</span>)</span><br><span class="line">    <span class="function">Call&lt;MultipleResource&gt; <span class="title">doGetListResources</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST</span>(<span class="string">"api/users"</span>)</span><br><span class="line">    <span class="function">Call&lt;User&gt; <span class="title">createUser</span><span class="params">(@Body User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"api/users?"</span>)</span><br><span class="line">    <span class="function">Call&lt;UserList&gt; <span class="title">doGetUserList</span><span class="params">(@Query(<span class="string">"page"</span>)</span> String page)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FormUrlEncoded</span></span><br><span class="line">    <span class="meta">@POST</span>(<span class="string">"api/users?"</span>)</span><br><span class="line">    <span class="function">Call&lt;UserList&gt; <span class="title">doCreateUserWithField</span><span class="params">(@Field(<span class="string">"name"</span>)</span> String name, @<span class="title">Field</span><span class="params">(<span class="string">"job"</span>)</span> String job)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 클래스에서 Annotation을 통해 테스트 HTTP request를 작성했습니다. 해당 API로 <a href="https://reqres.in/" target="_blank" rel="noopener">이곳</a>을 통해 테스트 할 것입니다.</p><p><code>@GET(&quot;api/unknown&quot;)</code>은  <code>doGetListResources()</code>를 호출합니다.<code>doGetListResources()</code>은 메서드 이름입니다. <code>MultipleResource.java</code>는 응답 객체의 Model POJO 클래스로서 Response parameter를 각각의 변수에 매핑하는 데 사용됩니다. 이러한 POJO 클래스는 메소드 리턴 유형으로 동작합니다.</p><h3 id="multipleresourcesjava">MultipleResources.java</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.journaldev.retrofitintro.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.gson.annotations.SerializedName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"page"</span>)</span><br><span class="line">    <span class="keyword">public</span> Integer page;</span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"per_page"</span>)</span><br><span class="line">    <span class="keyword">public</span> Integer perPage;</span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"total"</span>)</span><br><span class="line">    <span class="keyword">public</span> Integer total;</span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"total_pages"</span>)</span><br><span class="line">    <span class="keyword">public</span> Integer totalPages;</span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"data"</span>)</span><br><span class="line">    <span class="keyword">public</span> List&lt;Datum&gt; data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Datum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SerializedName</span>(<span class="string">"id"</span>)</span><br><span class="line">        <span class="keyword">public</span> Integer id;</span><br><span class="line">        <span class="meta">@SerializedName</span>(<span class="string">"name"</span>)</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">        <span class="meta">@SerializedName</span>(<span class="string">"year"</span>)</span><br><span class="line">        <span class="keyword">public</span> Integer year;</span><br><span class="line">        <span class="meta">@SerializedName</span>(<span class="string">"pantone_value"</span>)</span><br><span class="line">        <span class="keyword">public</span> String pantoneValue;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>@SerializedName</code> 어노테이션은 JSON 응답에서 각각의 필드를 구분하기 위해 사용합니다.</p><p><strong># Tip)</strong> <a href="http://www.jsonschema2pojo.org/" target="_blank" rel="noopener">jsonschema2pojo</a> 에서 json 응답의 구조를 바탕으로 해당 응답에 대한 POJO 클래스를 쉽게 만들 수 있습니다.</p><p><img src="/images/post/2018-01-29/jsonschema2pojo.png" alt="Json Schema -&amp;gt; POJO"></p><p>POJO 클래스는 Retrofit Call 클래스로 래핑됩니다. (JSONArray는 POJO 클래스의 객체 목록으로 직렬화됩니다.)</p><p><strong>Method Parameters</strong> : 메서드 내에서 전달할 수 있는 다양한 매개 변수 옵션이 있습니다.</p><ul><li><strong>@Body</strong> - request body로 Java 객체를 전달합니다.</li><li><strong>@Url</strong> - 동적인 URL이 필요할때 사용합니다.</li><li><strong>@Query</strong> - 쿼리를 추가할 수 있으며, 쿼리를 URL 인코딩하려면 다음과 같이 작성합니다.@Query(value = &quot;auth_token&quot;,encoded = true) String auth_token</li><li><strong>@Field</strong> - POST에서만 동작하며 form-urlencoded로 데이터를 전송합니다. 이 메소드에는 @FormUrlEncoded 어노테이션이 추가되어야 합니다.</li></ul><h2 id="android-retrofit-예제-프로젝트-구조">Android Retrofit 예제 프로젝트 구조</h2><p><img src="/images/post/2018-01-29/android-retrofit-project-structure.png" alt="Android Retrofit 예제 프로젝트 구조"></p><p>pojo 패키지는 <strong>APIInterface.java</strong> 클래스에 정의된 각각의 API 요청 응답에 대한 4가지 모델 클래스를 정의하고 있습니다.</p><h3 id="userjava">User.java</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.journaldev.retrofitintro.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.gson.annotations.SerializedName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"job"</span>)</span><br><span class="line">    <span class="keyword">public</span> String job;</span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"createdAt"</span>)</span><br><span class="line">    <span class="keyword">public</span> String createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String job)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.job = job;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 클래스는 <strong>createUser()</strong> 메서드에 대한 응답을 위해 사용합니다.</p><h3 id="userlistjava">UserList.java</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.journaldev.retrofitintro.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.gson.annotations.SerializedName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"page"</span>)</span><br><span class="line">    <span class="keyword">public</span> Integer page;</span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"per_page"</span>)</span><br><span class="line">    <span class="keyword">public</span> Integer perPage;</span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"total"</span>)</span><br><span class="line">    <span class="keyword">public</span> Integer total;</span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"total_pages"</span>)</span><br><span class="line">    <span class="keyword">public</span> Integer totalPages;</span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"data"</span>)</span><br><span class="line">    <span class="keyword">public</span> List&lt;Datum&gt; data = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Datum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SerializedName</span>(<span class="string">"id"</span>)</span><br><span class="line">        <span class="keyword">public</span> Integer id;</span><br><span class="line">        <span class="meta">@SerializedName</span>(<span class="string">"first_name"</span>)</span><br><span class="line">        <span class="keyword">public</span> String first_name;</span><br><span class="line">        <span class="meta">@SerializedName</span>(<span class="string">"last_name"</span>)</span><br><span class="line">        <span class="keyword">public</span> String last_name;</span><br><span class="line">        <span class="meta">@SerializedName</span>(<span class="string">"avatar"</span>)</span><br><span class="line">        <span class="keyword">public</span> String avatar;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="createuserresponsejava">CreateUserResponse.java</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.journaldev.retrofitintro.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.gson.annotations.SerializedName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateUserResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"job"</span>)</span><br><span class="line">    <span class="keyword">public</span> String job;</span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"createdAt"</span>)</span><br><span class="line">    <span class="keyword">public</span> String createdAt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mainactivityjava">MainActivity.java</h3><p>**<code>MainActivity.java</code>**는 Interface 클래스에 정의된 각각의 API를 호출하고 그 결과를 Toast와 TextView를 통해 표시하고 있습니다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.journaldev.retrofitintro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.journaldev.retrofitintro.pojo.CreateUserResponse;</span><br><span class="line"><span class="keyword">import</span> com.journaldev.retrofitintro.pojo.MultipleResource;</span><br><span class="line"><span class="keyword">import</span> com.journaldev.retrofitintro.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.journaldev.retrofitintro.pojo.UserList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> retrofit2.Call;</span><br><span class="line"><span class="keyword">import</span> retrofit2.Callback;</span><br><span class="line"><span class="keyword">import</span> retrofit2.Response;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TextView responseText;</span><br><span class="line">    APIInterface apiInterface;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        responseText = (TextView) findViewById(R.id.responseText);</span><br><span class="line">        apiInterface = APIClient.getClient().create(APIInterface.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         GET List Resources</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        Call&lt;MultipleResource&gt; call = apiInterface.doGetListResources();</span><br><span class="line">        call.enqueue(<span class="keyword">new</span> Callback&lt;MultipleResource&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;MultipleResource&gt; call, Response&lt;MultipleResource&gt; response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                Log.d(<span class="string">"TAG"</span>,response.code()+<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">                String displayResponse = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">                MultipleResource resource = response.body();</span><br><span class="line">                Integer text = resource.page;</span><br><span class="line">                Integer total = resource.total;</span><br><span class="line">                Integer totalPages = resource.totalPages;</span><br><span class="line">                List&lt;MultipleResource.Datum&gt; datumList = resource.data;</span><br><span class="line"></span><br><span class="line">                displayResponse += text + <span class="string">" Page\n"</span> + total + <span class="string">" Total\n"</span> + totalPages + <span class="string">" Total Pages\n"</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (MultipleResource.Datum datum : datumList) &#123;</span><br><span class="line">                    displayResponse += datum.id + <span class="string">" "</span> + datum.name + <span class="string">" "</span> + datum.pantoneValue + <span class="string">" "</span> + datum.year + <span class="string">"\n"</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                responseText.setText(displayResponse);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;MultipleResource&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">                call.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         Create new user</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"morpheus"</span>, <span class="string">"leader"</span>);</span><br><span class="line">        Call&lt;User&gt; call1 = apiInterface.createUser(user);</span><br><span class="line">        call1.enqueue(<span class="keyword">new</span> Callback&lt;User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;</span><br><span class="line">                User user1 = response.body();</span><br><span class="line"></span><br><span class="line">                Toast.makeText(getApplicationContext(), user1.name + <span class="string">" "</span> + user1.job + <span class="string">" "</span> + user1.id + <span class="string">" "</span> + user1.createdAt, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;User&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">                call.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         GET List Users</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        Call&lt;UserList&gt; call2 = apiInterface.doGetUserList(<span class="string">"2"</span>);</span><br><span class="line">        call2.enqueue(<span class="keyword">new</span> Callback&lt;UserList&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;UserList&gt; call, Response&lt;UserList&gt; response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                UserList userList = response.body();</span><br><span class="line">                Integer text = userList.page;</span><br><span class="line">                Integer total = userList.total;</span><br><span class="line">                Integer totalPages = userList.totalPages;</span><br><span class="line">                List&lt;UserList.Datum&gt; datumList = userList.data;</span><br><span class="line">                Toast.makeText(getApplicationContext(), text + <span class="string">" page\n"</span> + total + <span class="string">" total\n"</span> + totalPages + <span class="string">" totalPages\n"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (UserList.Datum datum : datumList) &#123;</span><br><span class="line">                    Toast.makeText(getApplicationContext(), <span class="string">"id : "</span> + datum.id + <span class="string">" name: "</span> + datum.first_name + <span class="string">" "</span> + datum.last_name + <span class="string">" avatar: "</span> + datum.avatar, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;UserList&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">                call.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         POST name and job Url encoded.</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        Call&lt;UserList&gt; call3 = apiInterface.doCreateUserWithField(<span class="string">"morpheus"</span>,<span class="string">"leader"</span>);</span><br><span class="line">        call3.enqueue(<span class="keyword">new</span> Callback&lt;UserList&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;UserList&gt; call, Response&lt;UserList&gt; response)</span> </span>&#123;</span><br><span class="line">                UserList userList = response.body();</span><br><span class="line">                Integer text = userList.page;</span><br><span class="line">                Integer total = userList.total;</span><br><span class="line">                Integer totalPages = userList.totalPages;</span><br><span class="line">                List&lt;UserList.Datum&gt; datumList = userList.data;</span><br><span class="line">                Toast.makeText(getApplicationContext(), text + <span class="string">" page\n"</span> + total + <span class="string">" total\n"</span> + totalPages + <span class="string">" totalPages\n"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (UserList.Datum datum : datumList) &#123;</span><br><span class="line">                    Toast.makeText(getApplicationContext(), <span class="string">"id : "</span> + datum.id + <span class="string">" name: "</span> + datum.first_name + <span class="string">" "</span> + datum.last_name + <span class="string">" avatar: "</span> + datum.avatar, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;UserList&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">                call.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>apiInterface = APIClient.getClient().create(APIInterface.class);</code>는 APIClient를 인스턴스화 하기위해 사용됩니다.API 응답에 Model 클래스를 매핑하기 위해서는 다음과 같이 사용합니다.<code>MultipleResource resource = response.body();</code></p><p>이제 앱을 실행하면 각 API를 호출하고 이에 따라 토스트 메시지를 표시합니다.</p><h2 id="참고">참고</h2><ul><li><a href="http://instructure.github.io/blog/2013/12/09/volley-vs-retrofit/" target="_blank" rel="noopener">Volley vs Retrofit</a></li><li><a href="https://www.journaldev.com/13629/okhttp-android-example-tutorial" target="_blank" rel="noopener">OkHttp Example</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;신입사원 프로젝트로 간만에 안드로이드 개발을 하게됐습니다. 서버와 통신하기위해 Square에서 만든 Retrofit 라이브러리를 사용했는데, 기존에 사용하던 버전(1.x)과 변경된 부분이 많아 새롭게 사용법을 알아보고자 합니다.
Retrofit 
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
    
      <category term="Android" scheme="https://jongmin92.github.io/tags/Android/"/>
    
      <category term="Retrofit2" scheme="https://jongmin92.github.io/tags/Retrofit2/"/>
    
      <category term="OkHttp3" scheme="https://jongmin92.github.io/tags/OkHttp3/"/>
    
  </entry>
  
  <entry>
    <title>OAuth 2.0과 네이버로 로그인</title>
    <link href="https://jongmin92.github.io/2018/01/20/Programming/android-naver-login/"/>
    <id>https://jongmin92.github.io/2018/01/20/Programming/android-naver-login/</id>
    <published>2018-01-20T06:30:00.000Z</published>
    <updated>2018-02-05T01:06:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>안드로이드에서 <strong>&lt;네이버 아이디로 로그인&gt;</strong> 기능을 구현하며 <strong>OAuth 2.0</strong>에 대해 알아보고, 라이브러리를 적용하는 방법에 대해 알아보겠습니다.</p><h2 id="oauth-20">OAuth 2.0</h2><p>OAuth는 **<code>인증(Authentication)과 허가(Authorization)</code>**을 위한 표준 프로토콜로, 사용자가 Facebook이나 트위터 같은 인터넷 서비스의 기능을 다른 애플리케이션(데스크톱, 웹, 모바일 등)에서도 사용할 수 있게 한 것입니다.</p><p>Facebook이나 트위터의 기능을 이용하기 위해 사용자가 반드시 Facebook이나 트위터에 로그인해야 하는 것이 아니라, 별도의 인증 절차를 거치면 다른 서비스에서 Facebook과 트위터의 기능을 이용할 수 있게 됩니다. 이런 방식은 Facebook이나 트위터 같은 서비스 제공자뿐만 아니라 사용자와 여러 인터넷 서비스 업체 모두에 이익이 되는 생태계를 구축하는데 기여했습니다.이 방식에서 사용하는 **인증 절차가 <code>OAuth</code>**입니다.</p><p>OAuth를 이용하면 이 인증을 공유하는 애플리케이션끼리는 별도의 인증이 필요없습니다. 따라서 여러 애플리케이션을 통합하여 사용하는 것이 가능하게 됩니다.</p><p><strong>OAuth 2.0은 authorization(허가, 승인)을 위한 산업 표준 프로토콜</strong>입니다. OAuth 2.0 전에 OAuth 1.0이 만들어져 사용되었지만 웹, 데스크탑, 모바일 등의 어플리케이션의 authorization flow(권한 흐름)을 보다 단순화 하는데 초점이 맞춰졌습니다.(OAuth 1.0에서는 Acess Token을 받으면 계속 사용이 가능했습니다. 그러나 OAuth 2.0에서는 보안 강화를 위해 Access Token의 Life-time을 지정할 수 있게됐고, Life-time이 만료되면 Refresh Token을 통해 Access Token을 재발급을 받아야 합니다.)</p><h2 id="주의사항">주의사항</h2><p><strong><code>로그인과 OAuth는 반드시 분리해서 이해해야 합니다.</code></strong> 아래의 예시를 통해 그 이유를 생각해봅시다.</p><blockquote><p>사원증을 이용해 출입할 수 있는 회사를 생각해 보자. 그런데 외부 손님이 그 회사에 방문할 일이 있다. 회사 사원이 건물에 출입하는 것이 로그인이라면 OAuth는 방문증을 수령한 후 회사에 출입하는 것에 비유할 수 있다. 방문증이란 사전에 정해진 곳만 다닐 수 있도록 하는 것이니, '방문증'을 가진 사람이 출입할 수 있는 곳과 '사원증'을 가진 사람이 출입할 수 있는 곳은 다르다. 역시 직접 서비스에 로그인한 사용자와 OAuth를 이용해 권한을 인증받은 사용자는 할 수 있는 일이 다르다.</p></blockquote><h2 id="구성요소">구성요소</h2><ul><li>사용자(Resource Owner) : Service Provider에 계정을 가지고 있으면서, Client를 이용하려는 사용자</li><li>소비자(Client) : OAuth 인증을 사용해 Service Provider의 기능을 사용하려는 애플리케이션이나 웹 서비스</li><li>API 서버(Resource Server) : OAuth를 사용하는 Open API를 제공하는 서비스</li><li>권한 (Authroization Server) : OAuth 인증 서버</li><li>접근 토큰(Access Token) : 인증 후 Client가 Resource Server의 자원에 접근하기 위한 키를 포함한 값</li><li>갱신 토큰(Refresh Token) : 유효기간이 지난 Access Token을 갱신하기 위해 사용되는 값</li></ul><h2 id="인증과정">인증과정</h2><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fnn3785mw7j31460ro435.jpg" alt="OAuth 2.0 과정"></p><hr><h2 id="네이버-아이디로-로그인">네이버 아이디로 로그인</h2><p><strong><code>&lt;네이버 아이디로 로그인&gt;</code>은 OAuth 2.0 기반의 사용자 인증 기능을 제공해 네이버가 아닌 다른 서비스에서 네이버의 사용자 인증 기능을 이용할 수 있게 하는 서비스입니다.</strong> 별도의 아이디나 비밀번호를 기억할 필요 없이 네이버 아이디로 간편하고 안전하게 서비스에 로그인할 수 있어, 가입이 귀찮거나 가입한 계정이 생각나지 않아 서비스를 이탈하는 사용자를 잡을 수 있습니다.</p><p>&lt;네이버 아이디로 로그인&gt;을 통해 로그인하는 기본 절차는 다음과 같습니다.</p><ol><li>로그인 (네이버 앱이 설치되어 있다면 네이버 앱의 간편 로그인 기능으로 로그인, 네이버 앱이 설치되지 않았다면 애플리케이션에서 인앱 브라우저가 실행되고 네이버 로그인 화면으로 이동한다.)</li><li>사용자가 네이버 아이디로 로그인하면 사용자 정보에 동의하는 화면으로 이동한다.</li><li>사용자가 정보 제공에 동의하면 <strong>콜백 URL로 애플리케이션에 <code>접근 토큰(access token)</code>이 발급된다.</strong> 발급받은 접근 토큰을 이용해 OAuth 2.0을 지원하는 네이버의 오픈 API를 사용하거나 사용자의 정보를 얻어 올 수 있다.</li></ol><h2 id="특징">특징</h2><p>네이버 아이디로 로그인한 사용자의 이름, 메일 주소, 별명, 프로필 사진, 생일, 연령대, 성별 등을 API로 간단하게 조회할 수 있습니다.</p><h2 id="적용-칠자">적용 칠자</h2><ol><li>애플리케이션 등록네이버 아이디로 로그인을 적용하기 위해 애플리케이션을 등록하고 <strong>클라이언트 아이디와 클라이언트 시크릿 키</strong>를 발급받는다.</li><li>애플리케이션 개발네이버 아이디로 로그인을 이용하기 위한 정보를 확인하고 등록한 환경에 맞는 개발가이드를 참고해 애플리케이션을 개발한다.<a href="https://developers.naver.com/docs/login/android/" target="_blank" rel="noopener">- Android 튜토리얼 참고</a></li><li>서비스 적용개발을 완료하면 서비스에 네이버 아이디로 로그인을 적용한다.</li></ol><h2 id="결과">결과</h2><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fnn43ymkojj30u01hcdhh.jpg" alt="네이버 아이디로 로그인 전"><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fnn449h4vyj30u01hcdif.jpg" alt="네이버 아이디로 로그인 후"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;안드로이드에서 &lt;strong&gt;&amp;lt;네이버 아이디로 로그인&amp;gt;&lt;/strong&gt; 기능을 구현하며 &lt;strong&gt;OAuth 2.0&lt;/strong&gt;에 대해 알아보고, 라이브러리를 적용하는 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;oauth
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
    
      <category term="Android" scheme="https://jongmin92.github.io/tags/Android/"/>
    
      <category term="OAuth" scheme="https://jongmin92.github.io/tags/OAuth/"/>
    
      <category term="OAuth 2.0" scheme="https://jongmin92.github.io/tags/OAuth-2-0/"/>
    
      <category term="Naver Login" scheme="https://jongmin92.github.io/tags/Naver-Login/"/>
    
  </entry>
  
  <entry>
    <title>신입 개발자의 취준 후기</title>
    <link href="https://jongmin92.github.io/2017/12/14/Etc/prepare-for-employment/"/>
    <id>https://jongmin92.github.io/2017/12/14/Etc/prepare-for-employment/</id>
    <published>2017-12-14T07:00:00.000Z</published>
    <updated>2018-02-05T01:06:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>8월을 마지막으로 1년 2개월의 스타트업 생활을 마치고, 이번 하반기 신입 채용과정을 거쳐 3곳에 합격했습니다. 퇴사 후 부랴부랴 취업준비를 시작했는데, 이번 포스팅에서는 취업준비를 하며 <strong><code>어떤 식으로 전공 지식과 직무 면접을 준비했는지 다뤄보겠습니다!</code></strong></p><h3 id="자료구조와-알고리즘">자료구조와 알고리즘</h3><p>제일 먼저 준비했던 과목은 자료구조와 알고리즘이었습니다. 제 경우 자료구조와 알고리즘이 다른 전공에 비해 많이 부족해서 가장 먼저 공부를 시작했습니다.대부분 기업이 서류 통과 후 바로 <code>온라인 코딩 테스트</code> 과정이 있기 때문에, 처음부터 차근차근 이론을 공부하고 문제를 푸는것은 시간상 불가능하다고 생각했습니다. 그래서 <a href="https://code.plus/course/19" target="_blank" rel="noopener">코드플러스 - SW 역량 테스트 대비</a> 강의를 통해 자주 출제되는 알고리즘들의 유형을 빠르게 익히고 비슷한 문제를 풀어보는 연습을 했습니다.</p><p><strong>저는 대표적인 유형의 알고리즘 같은 경우는 코드를 외울 정도로 자주 봤습니다. 사람마다 다르겠지만 제 경우에는 어느정도 문제의 틀이나 해법을 외워두니 비슷한 유형의 문제는 빠르게 풀 수 있었습니다.</strong> 처음 코딩 테스트를 준비하시는 분이라면 저처럼 대표적인 유형의 해법 정도는 외워두는게 도움이 많이 될 것 같다고 생각합니다. (당연히 이해를 바탕으로 외워야 합니다.)</p><p>자료구조와 알고리즘의 경우 온라인 코딩 테스트를 통과하더라도 다음 절차인 <code>(직무)면접</code>에서도 빠지지 않고 등장하는 과목입니다. <strong>저도 온라인 코딩 테스트를 통과한 후에는 방향을 바꿔서 문제를 많이 풀기보다는 자료구조의 공부에 조금 더 초점을 맞췄습니다.</strong> 이 과정에서는 <a href="http://www.kocw.net/home/search/kemView.do?kemId=1148815" target="_blank" rel="noopener">부경대학교 권오흠 교수님 - 알고리즘</a> 강의가 큰 도움이 됐습니다.</p><h3 id="운영체제">운영체제</h3><p>운영체제의 경우 학부생 때 가장 재밌게 공부했던 과목중 하나이다 보니 어느정도 자신있었습니다. <a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323&amp;ar=pop" target="_blank" rel="noopener">이화여자대학교 반효경 교수님 - 운영체제</a> 강의를 듣고 <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=4392911" target="_blank" rel="noopener">운영 체제와 정보기술의 원리</a> 책을 통해서 복습하며 빠르게 개념을 다잡았습니다.</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmge157ht0j305k086glq.jpg" alt=""></p><p>운영체제 과목의 경우 학부생 때 공부했을 때와는 다른 느낌이었습니다. 특히 <strong>스레드와 프로세스, 경쟁 상태 부분은 제가 주로 사용하는 Node.js의 특징을 이해하는데 큰 도움이 되었습니다.</strong> 단순히 개념공부로 끝나는 것이 아닌 실제 이러한 개념이 어떤 환경에서 어떻게 사용되고 있는지 그리고 그로 인해 어떠한 장단점이 있는지를 연관지어 생각해볼 수 있었습니다.</p><h3 id="데이터베이스">데이터베이스</h3><p>데이터베이스는 <strong>아키텍처 구성(다중화), 트랜잭션과 동시성 제어</strong>에 중점을 맞춰 공부했습니다. 당연히 기본적인 개념은 숙지하였고, 제가 했던 프로젝트라던가 어떤 서비스를 구축함에 있어 어떻게 아키텍처를 구성해야 하는지 고민해본것이 면접에 가서 도움이 많이 되었습니다.위와 같은 내용을 공부함에 있어 <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=11154846" target="_blank" rel="noopener">데이터베이스 첫걸음</a>이라는 책이 큰 도움이 되었습니다.</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmm0o8hoguj30cz0goq6f.jpg" alt=""></p><h3 id="그-외-전산학">그 외 전산학</h3><p>저는 <a href="https://github.com/JaeYeopHan/Interview_Question_for_Beginner" target="_blank" rel="noopener">Tech Interview For Beginner</a>를 통해서 위의 전공들 뿐만 아니라 그 외 과목들에서 필요한 부분을 공부했습니다. 예비 개발자들의 기술 면접 준비를 위한 자료를 정리해놓은 Repository로서 신입 개발자로 취업을 준비하시는 분이라면 많은 도움을 받으실 수 있을 것입니다.</p><h3 id="나만의-강점">나만의 강점</h3><p>제가 이번 하반기에 3곳에 최종합격 할 수 있었던 저만의 강점을 생각해 본다면 크게 두가지인것 같습니다.<strong><code>첫 번째로 개인 블로그와, 개인 프로젝트입니다.</code></strong> 저는 면접을 보며 개발에 대한 애착 혹은 자기 자기계발에 관련된 질문에는 항상 블로그와 개인 프로젝트를 통해 어필했습니다. 어떤 행동이나 습관으로 끝나는 것이 아닌 그로인한 결과물을 갖고 어필을 했던것이 큰 도움이 되었습니다.<strong><code>두 번째는 서비스를 직접 개발하고 운영해보았다는 점입니다.</code></strong> 1년 2개월 동안 스타트업에서 동료들과 함께 서비스를 기획하고 개발하고 운영했던 경험이 가장 큰 도움이 되었습니다. 단순히 학교 과제나 동아리 활동에서 결과물을 내는 것이 아니라, <strong>실제 사용자에게 서비스를 하기 위한 개발은 여러가지 면에서 차이가 있다고 느꼈습니다.</strong> 그런 면에서 항상 고민하고 선배 개발자 분과 이야기를 자주 나눴습니다. 제가 생각하고 고민한 방법에 대해 말씀드리고 그로 인해 다시 생길 수 있는 문제점을 생각해보고 개선해 나가는... 이런 과정들이 면접에 가서 가장 큰 도움이 되었습니다. 실제 면접에 가도 면접관 분들은 지원자가 했던 프로젝트에 대해 물어보시면서 추가적으로 어떤 문제점을 추가로 주고, 이를 면접자가 자신의 전산지식을 바탕으로 해결해가는 과정을 많이 보시는것 같습니다.</p><h3 id="마지막으로-드리고싶은-말씀">마지막으로 드리고싶은 말씀</h3><p>간혹 제 주변 친구들 혹은 지인들이 물어봅니다. 신입 개발자로 취업하기 위해서는 어떤것을 준비해야 하는지, 내가 지금 프로젝트를 더 해야하는지, 영어 점수를 더 올려야 하는지...<strong>저는 먼저, 꼭 기본적인 전산학에 대한 공부부터 하시기를 추천드립니다. 결국에는 내가 프로젝트를 하고 그 프로젝트를 자소서에 적더라도, 면접에 가서는 면접관님들은 프로젝트로부터 기본적인 전산학에 관련된 내용을 요구합니다. 그렇기 때문에 꼭 기본적인 전산학 공부를 탄탄히 하시길 바랍니다. 그 후에는 자신이 했던 프로젝트로부터 관련된 전산학 내용을 꼭 정리해보셨으면 좋겠습니다.</strong> (예를 들어, Node.js를 사용했다면 Node.js의 특징인 비동기 방식에 대해 운영체제 관점에서 설명할 수 있어야 합니다.)이 부분만 잘 되었다면 면접에서 어려운 질문을 받더라도, 면접관님과 대화를 하면서 문제에 접근하고 조금씩은 풀어갈 수 있는 능력이 생길거라고 생각합니다.</p><h3 id="주두다지-서버개발자-양성-교육-프로그램">(주)두다지 서버개발자 양성 교육 프로그램</h3><p>두다지의 **<code>서버개발자 양성 교육 프로그램</code>**은 제가 스타트업에 있을때 많은 도움을 받았던 선배 개발자분께서 기획하고 진행하시는 프로그램입니다. 프로그램을 운영하고 계시는 홍석환 멘토님은 제가 대학생일때 멘토 멘티로 만나 스타트업에서의 생활, 그리고 취업을 준비하면서도 계속해서 많은 도움을 주셨습니다.<strong>스스로 다시 한 번 전산학 내용을 정리할 수 있는 시간을 가지며 기본을 탄탄히 하고, 학생때는 단순히 학점만을 위해 공부하며 키워온 제 전산학 지식을 쌓아왔다면 실제 실무에서는 어떻게 사용되는지, 필요로 하는지 다양한 경험을 통해 체감할 수 있게 해주셨습니다.</strong>제가 과거에 멘티로서 선배 개발자분께 배웠던 과정은 <a href="https://sites.google.com/view/dudaji/study" target="_blank" rel="noopener">교육 과정</a>에서 확인해 볼 수 있습니다. 교육 과정의 더 자세한 내용과 과정을 수료한 멘티들의 후기도 <a href="https://sites.google.com/view/dudaji/meetup" target="_blank" rel="noopener">이곳</a>에서 확인할 수 있습니다.제가 생각하는 신입개발자에게 필요한 것은 단순히 전산지식을 얼마나 많이 아느냐가 아니라, 내가 앞으로 개발하면서 그동안 공부 했던 전산지식을 바탕으로 얼마나 잘 이해하며 활용할 수 있는지 그 능력이 필요하다고 생각합니다. 두다지 교육 프로그램은 그 능력을 키울 수 있도록 방향을 잡아줄 것입니다. 관심이 있으신분은 주저하지 마시고 꼭 연락을 드려보세요!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;8월을 마지막으로 1년 2개월의 스타트업 생활을 마치고, 이번 하반기 신입 채용과정을 거쳐 3곳에 합격했습니다. 퇴사 후 부랴부랴 취업준비를 시작했는데, 이번 포스팅에서는 취업준비를 하며 &lt;strong&gt;&lt;code&gt;어떤 식으로 전공 지식과 직무 면
      
    
    </summary>
    
    
      <category term="신입 개발자" scheme="https://jongmin92.github.io/tags/%EC%8B%A0%EC%9E%85-%EA%B0%9C%EB%B0%9C%EC%9E%90/"/>
    
      <category term="취업 준비" scheme="https://jongmin92.github.io/tags/%EC%B7%A8%EC%97%85-%EC%A4%80%EB%B9%84/"/>
    
  </entry>
  
  <entry>
    <title>힙 응용 - 우선순위 큐 (Priority queue)</title>
    <link href="https://jongmin92.github.io/2017/11/20/Algorithm/Concept/priority-queue/"/>
    <id>https://jongmin92.github.io/2017/11/20/Algorithm/Concept/priority-queue/</id>
    <published>2017-11-20T09:00:00.000Z</published>
    <updated>2018-02-05T01:06:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="우선순위-큐-priority-queue-란">우선순위 큐 (Priority queue) 란?</h3><p>큐는 여러개의 데이터를 넣을 수 있는 자료구조 입니다. 데이터가 넣고 뺄때는 <strong>First In First Out(FIFO) 구조</strong>를 가집니다.</p><p><strong><code>우선순위 큐</code>는 이러한 큐의 한종류로써 <code>최대 우선순위 큐</code>와 <code>최소 우선순위 큐</code>로 나뉩니다.</strong></p><h3 id="최대-우선순위-큐">최대 우선순위 큐</h3><p>최대 우선순위 큐는 다음의 두가지 연산을 지원하는 자료구조 입니다. (최소 우선순위 큐는 EXTRACT-MAX 대신 EXTRACT-MIN을 지원하는 자료구조입니다.)</p><ol><li><strong>INSERT(x)</strong> : 새로운 원소 x를 삽입</li><li><strong>EXTRACT_MAX()</strong> : 최대값을 삭제하고 반환</li></ol><p>MAX HEAP을 이용해서 최대 우선순위 큐를 구현할 수 있습니다.</p><h3 id="insert">INSERT</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1flon6ap26oj31780syn7m.jpg" alt="INSERT 과정"></p><p>위의 그림은 MAX HEAP의 형태로 저장되어 있는 우선순위 큐 입니다. 현재 heap은</p><ol><li>complete binary tree</li><li>max heap property조건을 만족하기 때문에 이를 유지하면서 INSERT 연산을 하기 위해서는 고려할 사항들이 있습니다.</li></ol><p>INSERT는 새로운 노드를 추가해야하는데 <strong>complete binary tree</strong> 를 만족하기 위해서는 가장 마지막 레벨의 leaf에 추가 될 수 밖에 없습니다. 그리고 새로운 노드가 추가된 후 <strong>max heap property</strong>를 만족하기 위해서는 max-heapify 연산이 필요합니다.INSERT의 의사 코드는 다음과 같습니다.</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MAX-HEAP-INSERT(A, key)&#123;</span><br><span class="line">    heap_size = heap_size + <span class="number">1</span>;</span><br><span class="line">    A[heap_size] = key;</span><br><span class="line">    i = heap_size;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">1</span> <span class="keyword">and</span> A[PARENT(i)] &lt; A[i])&#123;</span><br><span class="line">        exchange A[i] <span class="keyword">and</span> A[PARENT(i)];</span><br><span class="line">        i = PARENT(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 코드에서 A는 heap의 사이즈를 1증가 시키고, 그 자리에 새로운 key값을 넣습니다. i는 새로 추가된 노드의 인덱스입니다.그 후 while 문에서 i &gt; 1 (root 노드가 아니라는 의미) 이며, A[PARENT(i)] &lt; A[i] (부모 노드에 저장된 값보다 크다는 의미) 라면 부모 노드와 값을 교환합니다.</p><p>즉, 루트 노드가 될 때까지 혹은 자신의 부모 노드보다 작을 때 까지 계속해서 교환연산을 진행합니다. 따라서 시간 복잡도는 트리의 높이에 비례하게 되고, heap은 complete binary tree이므로 <code>O(nlogn)</code>입니다.</p><h3 id="extract_max">EXTRACT_MAX</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1flonkg61l9j314a0ro7cl.jpg" alt="EXTRACT_MAX 과정"></p><p>위의 그림은 EXTRACT_MAX 과정을 나타내고 있습니다. heap은 complete binary tree 성질을 유지하기 위해서 아무 노드나 삭제하는 것이 아니라 마지막 노드를 삭제하게 됩니다. 이때 루트 노드와 마지막 노드의 자리를 변경해 마지막 노드를 삭제 후 max-heapify를 통해 다시 max heap property를 만족하도록 만들 수 있습니다.HEAP-EXTRACT-MAX의 의사 코드는 다음과 같습니다.</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HEAP-EXTRACT-MAX(A)&#123;</span><br><span class="line">    <span class="keyword">if</span> heap-size[A] &lt; <span class="number">1</span></span><br><span class="line">        then error <span class="string">"heap underflow"</span></span><br><span class="line">    max &lt;- A[<span class="number">1</span>]</span><br><span class="line">    A[<span class="number">1</span>] &lt;- A[heap-size[A]]</span><br><span class="line">    heap-size[A] &lt;- heap-size[A] - <span class="number">1</span></span><br><span class="line">    MAX-HEAPIFY(A, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="c로-구현하기">C++로 구현하기</h3><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heap_insert</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, tmp;</span><br><span class="line"></span><br><span class="line">    size = size + <span class="number">1</span>;</span><br><span class="line">    a[size] = key;</span><br><span class="line"></span><br><span class="line">    i = size;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">1</span> &amp;&amp; a[i / <span class="number">2</span>] &lt; a[i]) &#123;</span><br><span class="line">        tmp = a[i / <span class="number">2</span>];</span><br><span class="line">        a[i / <span class="number">2</span>] = a[i];</span><br><span class="line">        a[i] = tmp;</span><br><span class="line">        i = i / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">heap_extract_max</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"heap underflow\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = a[<span class="number">1</span>];</span><br><span class="line">    a[<span class="number">1</span>] = a[size];</span><br><span class="line">    max_heapify(a, size<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>출처 : 2015 봄학기 알고리즘 - 부경대 권오흠 교수님</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;우선순위-큐-priority-queue-란&quot;&gt;우선순위 큐 (Priority queue) 란?&lt;/h3&gt;
&lt;p&gt;큐는 여러개의 데이터를 넣을 수 있는 자료구조 입니다. 데이터가 넣고 뺄때는 &lt;strong&gt;First In First Out(FI
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://jongmin92.github.io/categories/Algorithm/"/>
    
      <category term="Concept" scheme="https://jongmin92.github.io/categories/Algorithm/Concept/"/>
    
    
      <category term="Algorithm" scheme="https://jongmin92.github.io/tags/Algorithm/"/>
    
      <category term="Sort" scheme="https://jongmin92.github.io/tags/Sort/"/>
    
      <category term="Heap sort" scheme="https://jongmin92.github.io/tags/Heap-sort/"/>
    
      <category term="Priority queue" scheme="https://jongmin92.github.io/tags/Priority-queue/"/>
    
  </entry>
  
  <entry>
    <title>힙 정렬 (Heap sort) - 2</title>
    <link href="https://jongmin92.github.io/2017/11/19/Algorithm/Concept/heap-sort-2/"/>
    <id>https://jongmin92.github.io/2017/11/19/Algorithm/Concept/heap-sort-2/</id>
    <published>2017-11-19T07:35:00.000Z</published>
    <updated>2018-02-05T01:06:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>저번 포스팅에서는 힙(Heap)과 max-heapify에 대해 알아보았습니다. 이번 포스팅에서는 직접 1차원 배열을 heap 구조로 변경한 후 힙 정렬을 해보겠습니다.</p><h3 id="1차원-배열을-힙heap-으로-만들기">1차원 배열을 힙(Heap) 으로 만들기</h3><p>먼저 의사 코드는 다음과 같습니다.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BUILD-MAX-HEAP</span><br><span class="line">    heap-size[A]&lt;-length[A]</span><br><span class="line">    <span class="keyword">for</span> i &lt;- |length[A]/<span class="number">2</span>| downto <span class="number">1</span></span><br><span class="line">        <span class="keyword">do</span> MAX-HEAPIFY(A,i)</span><br></pre></td></tr></table></figure></p><p>i가 A 배열의 길이 / 2 부터 시작하는 이유는 리프 노드에서는 max-heapify 과정이 필요 없기 때문입니다.</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1flnftndkvwj31260yodqt.jpg" alt="BUILD-MAX-HEAP 과정"></p><p>힙을 만드는데의 시간 복잡도는 다음과 같습니다.MAX-HEAPIFY 연산의 시간 복잡도는 log(n) 입니다. 그런데 for 문이 n/2 돌기 때문에 n/2*log(n)이며 빅 오로 표기하면 O(n*log(n))이 됩니다.이는 루트 노드만 고려하여 상당히 러프하게 계산한 것이기 때문에, 정확하게 계산한다면 시간 복잡도는 **<code>O(n)</code>**이 됩니다.</p><h3 id="힙-정렬heap-sort-하기">힙 정렬(Heap sort) 하기</h3><p>힙 정렬은 다음과 같은 순서로 실행됩니다.</p><ol><li>주어진 데이터를 힙으로 만든다</li><li>힙에서 최대값(루트 노드)을 가장 마지막 값과 바꾼다.</li><li>힙의 크기가 1 줄어든 것으로 간주한다. 즉, 마지막 값은 힙의 일부가 아닌것으로 간주한다.</li><li>루트 노드에 대해서 HEAPIFY(1)한다.</li><li>2~4번을 반복한다.</li></ol><p>데이터를 힙으로 만들면 인덱스 1의 값이 가장 최대값 이므로 마지막 값과 바꿉니다.그리고 마지막값은 정렬된 값으로 간주하고 더 이상 신경쓰지 않아도 됩니다.그렇게 줄여나간다면 결국 정렬된 상태의 배열이 완성됩니다.</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1flnhnyssc1j31bi10sqec.jpg" alt="힙 정렬 과정"></p><p>힙 정렬의 의사 코드는 다음과 같습니다.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HEAPSORT(A)</span><br><span class="line">    BUILD-MAX-HEAP(A)             <span class="comment">// O(n)</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;-heap-size downto <span class="number">2</span> <span class="keyword">do</span> <span class="comment">// n-1 times</span></span><br><span class="line">        exchange A[<span class="number">1</span>] &lt;-&gt; A[i]    <span class="comment">// O(1)</span></span><br><span class="line">        heap_size &lt;- heap_size <span class="number">-1</span> <span class="comment">// O(1)</span></span><br><span class="line">        MAX-HEAPIFY(A,<span class="number">1</span>)          <span class="comment">// O(log(n))</span></span><br></pre></td></tr></table></figure></p><p>총 시간 복잡도는 **<code>nlogn</code>**이 됩니다.</p><h3 id="c로-힙-정렬-구현하기">C++로 힙 정렬 구현하기</h3><p>다음과 같이 C++로 힙 정렬을 구현할 수 있습니다.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITEM_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = idx * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> right = (idx * <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> largest = idx;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 왼쪽 자식 노드와 비교</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; size &amp;&amp; a[left] &gt; a[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 오른쪽 자식 노드와 비교</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; size &amp;&amp; a[right] &gt; a[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 부모 노드보다 자식 노드가 큰 경우 교환</span></span><br><span class="line">    <span class="keyword">if</span> (largest != idx) &#123;</span><br><span class="line">        tmp = a[largest];</span><br><span class="line">        a[largest] = a[idx];</span><br><span class="line">        a[idx] = tmp;</span><br><span class="line">        <span class="comment">// 재귀 호출</span></span><br><span class="line">        max_heapify(a, size, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_max_heap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        max_heapify(a, size, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    build_max_heap(a, size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count = size - <span class="number">1</span>; count &gt; <span class="number">0</span>; count--) &#123;</span><br><span class="line">        <span class="comment">// 루트 노드를 가장 마지막 노드와 교환</span></span><br><span class="line">        tmp = a[count];</span><br><span class="line">        a[count] = a[<span class="number">1</span>];</span><br><span class="line">        a[<span class="number">1</span>] = tmp;</span><br><span class="line">        <span class="comment">// 힙 구조 유지</span></span><br><span class="line">        max_heapify(a, count, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[ITEM_SIZE] = &#123; <span class="number">0</span>, &#125;; <span class="comment">// 루트 노드는 1번 인덱스 부터 시작</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ITEM_SIZE; i++) &#123;</span><br><span class="line">        a[i] = (rand() % (ITEM_SIZE * <span class="number">10</span>)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_arr(a, ITEM_SIZE);</span><br><span class="line">    heap_sort(a, ITEM_SIZE);</span><br><span class="line">    print_arr(a, ITEM_SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>출처 : 2015 봄학기 알고리즘 - 부경대 권오흠 교수님</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;저번 포스팅에서는 힙(Heap)과 max-heapify에 대해 알아보았습니다. 이번 포스팅에서는 직접 1차원 배열을 heap 구조로 변경한 후 힙 정렬을 해보겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;1차원-배열을-힙heap-으로-만들기&quot;&gt;1차원 배열을 힙
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://jongmin92.github.io/categories/Algorithm/"/>
    
      <category term="Concept" scheme="https://jongmin92.github.io/categories/Algorithm/Concept/"/>
    
    
      <category term="Algorithm" scheme="https://jongmin92.github.io/tags/Algorithm/"/>
    
      <category term="Sort" scheme="https://jongmin92.github.io/tags/Sort/"/>
    
      <category term="Heap sort" scheme="https://jongmin92.github.io/tags/Heap-sort/"/>
    
  </entry>
  
</feed>

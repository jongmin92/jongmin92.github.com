<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>92Hz</title>
  <icon>https://www.gravatar.com/avatar/8b7f06e12e9f3c555a0587f51748ac7f</icon>
  <subtitle>To Be A Lean Developer!</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://jongmin92.github.io/"/>
  <updated>2019-03-09T15:43:30.030Z</updated>
  <id>https://jongmin92.github.io/</id>
  
  <author>
    <name>KimJongMin</name>
    <email>kdhx92@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[번역] Java Reactor Pattern</title>
    <link href="https://jongmin92.github.io/2019/03/05/Java/java-reactor-pattern/"/>
    <id>https://jongmin92.github.io/2019/03/05/Java/java-reactor-pattern/</id>
    <published>2019-03-05T14:00:00.000Z</published>
    <updated>2019-03-09T15:43:30.030Z</updated>
    
    <content type="html"><![CDATA[<p>해당 글은 아래의 Reactor Pattern Explained 시리즈를 번역하였습니다.</p><ul><li><a href="http://jeewanthad.blogspot.com/2013/02/reactor-pattern-explained-part-1.html" target="_blank" rel="noopener">Reactor Pattern Explained - Part 1</a></li><li><a href="http://jeewanthad.blogspot.com/2013/02/reactor-pattern-explained-part-2.html" target="_blank" rel="noopener">Reactor Pattern Explained - Part 2</a></li><li><a href="http://jeewanthad.blogspot.com/2013/03/reacter-pattern-explained-part-3.html" target="_blank" rel="noopener">Reactor Pattern Explained - Part 3</a></li></ul><h1 id="part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h1><p>서버가 동시에 요청(이벤트)을 받을 때, 보통 요청을 처리하기 위한 이벤트 리스너를 각 스레드마다 할당해 처리하곤 합니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket ss = <span class="keyword">new</span> ServerSocket(PORT);</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted())</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Handler(ss.accept())).start();</span><br><span class="line">            <span class="comment">// or, single-threaded, or a thread pool</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Socket socket;</span><br><span class="line">    Handler(Socket s) &#123; socket = s; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[MAX_INPUT];</span><br><span class="line">            socket.getInputStream().read(input);</span><br><span class="line">            <span class="keyword">byte</span>[] output = process(input);</span><br><span class="line">            socket.getOutputStream().write(output);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] process(<span class="keyword">byte</span>[] cmd) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>요청마다 처리를 위해 이벤트 리스너를 별도의 스레드로 만들어 사용하는 것의 단점은 <code>컨텍스트 전환(context switching)의 오버 헤드</code>가 크다는 것입니다. 최악의 경우, 데이터를 자주 읽거나 쓰지 않는 이벤트 리스너를 처리하는 일부 스레드는 유용한 작업을 하지 않고 주기적으로 컨텍스트를 전환할 것입니다. 스케줄러가 이러한 스레드를 CPU에 디스패치(dispatch) 할 때마다 I/O 이벤트가 발생할 때까지 스레드는 차단되어 I/O 이벤트를 기다리는 데 소비되는 모든 시간이 낭비됩니다.</p><p>위의 코드에서 <code>ss.accept()</code>는 클라이언트가 연결될 때까지 서버 스레드를 차단하는 블로킹 호출입니다. 서버 스레드는 <code>ss.accept()</code> 호출이 반환 될 때까지 이벤트 리스너를 위한 새로운 스레드의 <code>start()</code> 메서드를 호출 할 수 없습니다. 불필요한 컨텍스트 전환으로 인한 CPU 시간 낭비를 줄이기 위해 non-blocking I/O 개념이 탄생했습니다.</p><p><strong><code>Reactor Pattern</code></strong>은 이 문제를 해결하기 위한 <strong>이벤트 처리(event handling) 디자인 패턴</strong>입니다. 하나의 Reactor가 계속 이벤트를 찾고 이벤트가 발생(trigger)하면 해당 이벤트 처리기(event handler)에게 이를 알립니다.</p><p>자바는 non-blocking 시스템을 설계하는 데 사용할 수 있는 <strong>표준 API (java.nio)</strong>를 제공합니다. 클라이언트가 서버로 이름(데이터)을 보내면 서버는 Hello 메시지로 응답하는 간단한 예제를 통해 Reactor 패턴에 대해서 알아보겠습니다.</p><p>Reactor 패턴의 아키텍처에는 두 가지 중요한 참여자가 있습니다.</p><ol><li><strong><code>Reactor</code></strong><br>: Reactor는 별도의 스레드에서 실행되며 발생한 I/O 이벤트는 dispatching되어 해당 이벤트 처리기로 보내 처리합니다.</li><li><strong><code>Handlers</code></strong><br>: Handler는 Reactor로부터 I/O 이벤트를 받아 실제 작업을 수행합니다.</li></ol><p>java.nio 패키지를 이용해서 Reactor 패턴을 구현할 것이기 때문에 nio 패키지에 속한 몇가지 class에 대한 이해가 필요합니다.</p><ul><li><strong><code>Channels</code></strong><br>: 소켓을 통해 non-blocking read를 할 수 있도록 지원하는 connection.</li><li><strong><code>Buffers</code></strong><br>: 채널에 의해 직접 read되거나 write될 수 있는 배열과 같은 객체.</li><li><strong><code>Selectors</code></strong><br>: Selector 는 어느 channel set 이 IO event 를 가지고 있는지를 알려준다. Selector.select() 는 I/O 이벤트가 발생한 채널 set을 return한다. return할 channel이 없다면 계속 기다리게(block) 된다. 이 block된 것을 바로 return 시켜주는 것이 Selector.wakeup()이다.<br>Selector.selectedKeys()는 Selection Key 를 return 해 준다. Reactor는 이 Selection Key를 보고 어떤 handler로 넘겨줄 지를 결정한다.</li><li><strong><code>Selection Keys</code></strong><br>: Selector와 Channel간의 관계를 표현해주는 객체이다. Selector가 제공한 Selection Key를 이용해 Reactor는 채널에서 발생하는 I/O 이벤트로 수행할 작업을 선택할 수 있다. ServerSocketChannel에 selector를 등록하면 key를 준다. 이 key가 SelectionKey 이다.</li></ul><p><img src="/images/post/2019-03-05/reactor_pattern_1.png" alt="Reactor pattern"></p><p><strong>Selector는 계속해서 I/O 이벤트가 발생하기를 대기합니다. Reactor가 Selector.select() 메소드를 호출하면 Selector는 등록된 채널에 대해서 발생한 이벤트 정보가 들어있는 SelectionKey Set을 반환합니다.</strong> (SelectionKey는 해당 채널과 Selector와의 관계에 대한 모든 정보를 갖고 있습니다. 또한 Handler에 대한 정보도 갖고 있습니다.)</p><p>Selector에 등록된 하나의 ServerSocketChannel이 있습니다. ServerSocketChannel은 클라이언트에서 들어오는 연결 요청으로부터 이벤트를 수신해야합니다. 클라이언트가 연결을 요청할 때, ServerSocketChhannel은 I/O 이벤트를 받아 클라이언트에 SocketChannel을 할당해야 합니다. SelectionKey0은 ServerSocketChannel을 가지고 무엇을 해야하는지에 대한 이벤트 정보를 갖고 있습니다. SocketChhannel을 만들기 위해서는 Reactor가 SelectionKey0의 이벤트를 Acceptor에 전달해 Acceptor가 클라이언트와의 연결 요청을 수락하고 SocketChannel을 만들도록 해야합니다.</p><p>Acceptor가 클라이언트1의 연결을 수락하면 클라이언트1에 대한 SocketChannel이 생성됩니다. 이 SocketChannel역시 Selector에 등록되고 해당 채널에서 이벤트가 발생하면 해당 이벤트에 대한 정보를 포함한 SelectionKey1을 반환합니다. 이 SelectionKey1을 이용해서 해당 채널로부터 데이터를 읽고 쓸 수 있습니다. 따라서 SelectionKey1은 읽기와 쓰기를 처리하는 Handler1 객체에 바인딩 됩니다.</p><p>이후로 Reactor가 Selector.selector()를 호출했을 때 반환된 SelectionKey Set에 SelectionKey1이 있으면 SocketChannel1이 이벤트와 함께 트리거됨을 의미합니다. 이제 SelectionKey1을 보면, Reactor는 Handler1이 SelectionKey1에 바인딩되어 있으므로 Handler1에 이벤트를 전달해야한다는 것을 알고 있습니다. 반환 된 SelectionKey Set에 SelectionKey0이 있으면 ServerSocketChannel이 다른 클라이언트에서 이벤트를 수신했으며 SelectionKey0을 보고 Reactor는 해당 이벤트를 다시 Acceptor에 전달해야 함을 알고 있습니다. 이벤트가 Acceptor에 전달되면 클라이언트2에 대해 SocketChannel2를 만들고 SelectionKey2로 Selector로 SocketChannel2를 등록합니다.</p><p><img src="/images/post/2019-03-05/selection_key_table.png" alt="Selection Key table"></p><p>따라서 이 시나리오에서는 3가지 유형의 이벤트에 관심이 있습니다.</p><ol><li>accept 해야하는 ServerSocketChannel에서 트리거되는 연결 요청 이벤트.</li><li>클라이언트로 부터 송신된 데이터를 수신할 수 있을 때, SocketChannel로부터 트리거 되는 이벤트.</li><li>서버에서 클라이언트로 데이터를 송신할 때, 송신할 수 있는 준비가 되면 SocketChannel로부터 트리거 되는 이벤트.</li></ol><p>그럼 스레드 풀은 이 작업과 어떤 관련이 있을까요? non-blocking 아키텍처의 장점은 클라이언트의 모든 요청을 처리하는 동시에 단일 스레드에서 실행되도록 서버를 작성할 수 있다는 것입니다. 서버를 설계하는 데 동시성 개념을 적용하지 않으면 이벤트에 대한 반응성이 떨어집니다. 단일 스레드일 때는 reactor가 이벤트를 handler에 전달해 처리될 때 까지는 다른 이벤트에 응답할 수 없기 때문입니다. 왜냐하면 하나의 스레드를 사용하여 모든 이벤트를 처리하기 때문입니다.</p><p>위의 아키텍처에 동시성을 추가해서 시스템의 응답 속도를 향상시킬 수 있습니다. <strong>Reactor가 이벤트를 Handler에 전달하고 새로운 Thread에서 Handler를 이용해 이벤트를 처리하면 Reacgtor는 계속해서 다른 이벤트에 응답할 수 있습니다.</strong> 또한 스레드 풀을 이용하면 시스템의 스레드 수를 제한하면서 더 효율적으로 사용할 수 있을 것 입니다.</p><h1 id="part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h1><p>간단한 Reactor 패턴의 예시를 살펴보겠습니다. 클라이언트는 서버로 이름을 넣은 메시지를 전송하고 서버는 클라이언트에 Hello 메시지로 응답합니다. 스레드 풀은 Part3에서 살펴보겠습니다.</p><p>클라이언트는 java.nio를 사용하여 Socket을 생성하지 않고 java.net.Socket을 사용합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    String hostIp;</span><br><span class="line">    <span class="keyword">int</span> hostPort;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(String hostIp, <span class="keyword">int</span> hostPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hostIp = hostIp;</span><br><span class="line">        <span class="keyword">this</span>.hostPort = hostPort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket clientSocket = <span class="keyword">null</span>;</span><br><span class="line">        PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientSocket = <span class="keyword">new</span> Socket(hostIp, hostPort);</span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Unknown host: "</span> + hostIp);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Couldn't connect to: "</span> + hostIp);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BufferedReader stdIn = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String userInput;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Client connected to host : "</span> + hostIp + <span class="string">" port: "</span> + hostPort);</span><br><span class="line">        System.out.println(<span class="string">"Type (\"Bye\" to quit)"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Tell what your name is to the Server....."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((userInput = stdIn.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            out.println(userInput);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Break when client says Bye.</span></span><br><span class="line">            <span class="keyword">if</span> (userInput.equalsIgnoreCase(<span class="string">"Bye"</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Server says: "</span> + in.readLine());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">        stdIn.close();</span><br><span class="line">        clientSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Client client = <span class="keyword">new</span> Client(<span class="string">"127.0.0.1"</span>, <span class="number">9900</span>);</span><br><span class="line">        client.runClient();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>서버는 Reactor 패턴을 이용해 구현합니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reactor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Selector selector;</span><br><span class="line">    <span class="keyword">final</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isWithThreadPool;</span><br><span class="line"></span><br><span class="line">    Reactor(<span class="keyword">int</span> port, <span class="keyword">boolean</span> isWithThreadPool) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.isWithThreadPool = isWithThreadPool;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        SelectionKey selectionKey0 = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        selectionKey0.attach(<span class="keyword">new</span> Acceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Server listening to port: "</span> + serverSocketChannel.socket().getLocalPort());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                selector.select();</span><br><span class="line">                Set selected = selector.selectedKeys();</span><br><span class="line">                Iterator it = selected.iterator();</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    dispatch((SelectionKey) (it.next()));</span><br><span class="line">                &#125;</span><br><span class="line">                selected.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey k)</span> </span>&#123;</span><br><span class="line">        Runnable r = (Runnable) (k.attachment());</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isWithThreadPool)</span><br><span class="line">                        <span class="keyword">new</span> HandlerWithThreadPool(selector, socketChannel);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">new</span> Handler(selector, socketChannel);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"Connection Accepted by Reactor"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Reactor는 Runnable을 구현하고 있으며, run() 메서드에서는 while 루프를 돌며 selector.select()를 호출하여 처리할 수 있는 이벤트 정보가 담긴 SelectionKey Set을 가져옵니다. SelectionKey에 바인드 되어있는 Handler를 가져와 dispatch합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey;</span><br><span class="line">    ByteBuffer input = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READING = <span class="number">0</span>, SENDING = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> state = READING;</span><br><span class="line">    String clientName = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    Handler(Selector selector, SocketChannel c) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        socketChannel = c;</span><br><span class="line">        c.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        selectionKey = socketChannel.register(selector, <span class="number">0</span>);</span><br><span class="line">        selectionKey.attach(<span class="keyword">this</span>);</span><br><span class="line">        selectionKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        selector.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (state == READING) &#123;</span><br><span class="line">                read();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SENDING) &#123;</span><br><span class="line">                send();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> readCount = socketChannel.read(input);</span><br><span class="line">        <span class="keyword">if</span> (readCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            readProcess(readCount);</span><br><span class="line">        &#125;</span><br><span class="line">        state = SENDING;</span><br><span class="line">        <span class="comment">// Interested in writing</span></span><br><span class="line">        selectionKey.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Processing of the read message. This only prints the message to stdOut.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> readCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">readProcess</span><span class="params">(<span class="keyword">int</span> readCount)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        input.flip();</span><br><span class="line">        <span class="keyword">byte</span>[] subStringBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[readCount];</span><br><span class="line">        <span class="keyword">byte</span>[] array = input.array();</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, subStringBytes, <span class="number">0</span>, readCount);</span><br><span class="line">        <span class="comment">// Assuming ASCII (bad assumption but simplifies the example)</span></span><br><span class="line">        sb.append(<span class="keyword">new</span> String(subStringBytes));</span><br><span class="line">        input.clear();</span><br><span class="line">        clientName = sb.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Saying hello to "</span> + clientName);</span><br><span class="line">        ByteBuffer output = ByteBuffer.wrap((<span class="string">"Hello "</span> + clientName + <span class="string">"\n"</span>).getBytes());</span><br><span class="line">        socketChannel.write(output);</span><br><span class="line">        selectionKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        state = READING;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler에는 READING, SENDING 2가지 상태가 있습니다. 채널은 한 번에 하나의 작업만 지원하기 때문에 동시에 처리할 수 없습니다. Handler가 SelectionKey에 어떻게 attach 되는지와 관심있는 연산이 OP_READ로 설정되는 부분에 유의해야합니다. Selector는 Read 이벤트가 발생할 때만 SelectionKey를 select해야 합니다. READ 프로세스가 완료되면 Handler는 상태를 SENDING으로 변경하고 관심 대상 연산을 OP_WRITE로 변경합니다. 이제 Selector는 채널이 데이터를 전송할 준비가 되었을 때 SelectionKey를 select 합니다. Write 이벤트가 Handler에 dispatch될 때, 상태가 SENDING이므로 Hello 메시지를 출력 버퍼에 씁니다. 전송이 완료되면 관심있는 작업을 OP_READ로 다시 변경하면서 Handler의 상태가 READING으로 변경됩니다.</p><p>결과적으로 서버는 단일 스레드에서 실행되지만 서버에 연결하는 클라이언트 수에 상관없이 응답합니다.</p><h1 id="part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h1><p>이번 파트에서는 Handler의 스레드 풀에 대해서 설명합니다. HandlerWithThreadPool은 Handler 클래스의 확장 버전입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerWithThreadPool</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROCESSING = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerWithThreadPool</span><span class="params">(Selector sel, SocketChannel c)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(sel, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> readCount = socketChannel.read(input);</span><br><span class="line">        <span class="keyword">if</span> (readCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            state = PROCESSING;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> Processer(readCount));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We are interested in writing back to the client soon after read processing is done.</span></span><br><span class="line">        selectionKey.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start processing in a new Processer Thread and Hand off to the reactor thread.</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">processAndHandOff</span><span class="params">(<span class="keyword">int</span> readCount)</span> </span>&#123;</span><br><span class="line">        readProcess(readCount);</span><br><span class="line">        <span class="comment">// Read processing done. Now the server is ready to send a message to the client.</span></span><br><span class="line">        state = SENDING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Processer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> readCount;</span><br><span class="line">        Processer(<span class="keyword">int</span> readCount) &#123;</span><br><span class="line">            <span class="keyword">this</span>.readCount =  readCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            processAndHandOff(readCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PROCESSING이 새로 도입되었으며 read() 메서드가 override 되었습니다. 이제 Read 이벤트가 Handler에 dispatch되면 데이터를 읽지만 상태를 SENDING으로 변경하지는 않습니다. 메시지를 처리하고 스레드 풀의 다른 스레드에서 실행하고 관련 작업을 OP_WRITE로 설정하는 Processer를 생성합니다. 이 시점에서 채널에 Write 준비가 되어 있더라도 Handler는 아직 PROCESSING 상태이기 때문에 write하지 않습니다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p><a href="http://i5on9i.blogspot.com/2013/11/reactor-pattern.html" target="_blank" rel="noopener">Reactor Pattern 에 대해 알아보자</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;해당 글은 아래의 Reactor Pattern Explained 시리즈를 번역하였습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://jeewanthad.blogspot.com/2013/02/reactor-pattern-explained-
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://jongmin92.github.io/categories/Programming/Java/"/>
    
    
      <category term="nio" scheme="https://jongmin92.github.io/tags/nio/"/>
    
      <category term="select" scheme="https://jongmin92.github.io/tags/select/"/>
    
      <category term="multiplexing" scheme="https://jongmin92.github.io/tags/multiplexing/"/>
    
      <category term="non-blocking io" scheme="https://jongmin92.github.io/tags/non-blocking-io/"/>
    
      <category term="reactor" scheme="https://jongmin92.github.io/tags/reactor/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO와 멀티플렉싱 기반의 다중 접속 서버</title>
    <link href="https://jongmin92.github.io/2019/03/03/Java/java-nio/"/>
    <id>https://jongmin92.github.io/2019/03/03/Java/java-nio/</id>
    <published>2019-03-03T04:00:00.000Z</published>
    <updated>2019-03-09T04:50:29.892Z</updated>
    
    <content type="html"><![CDATA[<p>자바 NIO에 대한 소개와 NIO와 함께 도입된 자바에서 I/O 멀티플렉싱(multiplexing)을 구현한 selector에 대해 알아봅니다. I/O 멀티플렉싱(multiplexing)에 대한 개념에 대해 아직 잘 이해하지 못하고 있다면 먼저 <a href="https://jongmin92.github.io/2019/02/28/Java/java-with-non-blocking-io/"><strong>&lt;멀티플렉싱 기반의 다중 접속 서버로 가기까지&gt;</strong></a> 포스팅을 읽어주세요.</p><h1 id="overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p><strong>자바 NIO (New IO)는 기존의 자바 IO API를 대체하기 위해 자바 1.4부터 도입이 되었습니다.</strong> 새롭게 변화된 부분에 대해서 간략히 요약해보면 다음과 같습니다. </p><ul><li><strong><code>Channels and Buffers</code></strong><br>기존 IO API에서는 byte streams character streams 사용했지만, NIO에서는 channels(채널)과 buffers(버퍼)를 사용합니다. 데이터는 항상 채널에서 버퍼로 읽히거나 버퍼에서 채널로 쓰여집니다.</li><li><strong><code>Non-blocking IO</code></strong><br>자바 NIO에서는 non-blocking IO를 사용할 수 있습니다. 예를 들면, 하나의 스레드는 버퍼에 데이터를 읽도록 채널에 요청할 수 있습니다. 채널이 버퍼로 데이터를 읽는 동안 스레드는 다른 작업을 수행할 수 있습니다. 데이터가 채널에서 버퍼로 읽어지면, 스레드는 해당 버퍼를 이용한 processing(처리)를 계속 할 수 있습니다. 데이터를 채널에 쓰는 경우도 non-blocking이 가능합니다.</li><li><strong><code>Selectors</code></strong><br>자바 NIO에는 “selectors” 개념을 포함하고 있습니다. selector는 여러개의 채널에서 이벤트(연결이 생성됨, 데이터가 도착함)를 모니터링할 수 있는 객체입니다. 그래서 하나의 스레드에서 여러 채널에 대해 모니터링이 가능합니다.</li></ul><p>자바 NIO는 다음과 같은 핵심 컴포넌트로 구성되어있습니다.</p><ul><li><strong>Channels</strong></li><li><strong>Buffers</strong></li><li><strong>Selectors</strong></li></ul><p>실제로는 더 많은 클래스와 컴포넌트가 있지만 채널, 버퍼, 셀렉터가 API의 핵심을 구성합니다.</p><h1 id="channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h1><p><strong>일반적으로 NIO의 모든 IO는 채널로 시작합니다. 채널 데이터를 버퍼로 읽을 수 있고, 버퍼에서 채널로 데이터를 쓸 수 있습니다.</strong><br><img src="/images/post/2019-03-03/channel_buffer.png" alt="channel and buffer"></p><p>채널은 스트림(stream)과 유사하지만 몇가지 차이점이 있습니다.</p><ul><li>채널을 통해서는 읽고 쓸 수 있지만, 스트림은 일반적으로 단방향(읽기 혹은 쓰기)으로만 가능합니다.</li><li>채널은 비동기적(asynchronously)으로 읽고 쓸 수 있습니다.</li><li>채널은 항상 버퍼에서 부터 읽거나 버퍼로 씁니다.</li></ul><p>채널에는 여러가지 타입이 있습니다. 다음은 자바 NIO에 기본적으로 구현되어 있는 목록입니다.</p><ul><li>Channels<ul><li>FileChannel<br>: 파일에 데이터를 읽고 쓴다.</li><li>DatagramChannel<br>: UDP를 이용해 네트워크를 통해 데이터를 읽고 쓴다.</li><li><strong>SocketChannel</strong><br>: TCP를 이용해 네트워크를 통해 데이터를 읽고 쓴다.</li><li><strong>ServerSocketChannel</strong><br>: 들어오는 TCP 연결을 수신(listening)할 수 있다. 들어오는 연결마다 SocketChannel이 만들어진다.</li></ul></li></ul><h1 id="buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h1><p><strong>NIO의 버퍼는 채널과 상호작용할 때 사용됩니다. 데이터는 채널에서 버퍼로 읽혀지거나, 버퍼에서 읽혀 채널로 쓰여집니다.</strong></p><p>버퍼에는 여러가지 타입이 있습니다. 다음은 자바 NIO에 기본적으로 구현되어 있는 목록입니다.</p><ul><li>Buffers<ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul></li></ul><p>일반적으로 버퍼를 사용하여 데이터를 읽고 쓰는 것은 4단계 프로세스를 가집니다.</p><ol><li>버퍼에 데이터 쓰기</li><li>buffer.flip() 호출</li><li>버퍼에서 데이터 읽기</li><li>buffer.clear() 혹은 buffer.compact() 호출</li></ol><p>버퍼에 데이터를 쓸 때 버퍼는 쓰여진 데이터의 양을 기록합니다. 만약 데이터를 읽어야한다면 flip() 메서드를 호출해서 버퍼를 쓰기 모드에서 읽기 모드로 전환해야 합니다. 읽기 모드에서 버퍼를 사용하면 버퍼에 쓰여진 모든 데이터를 읽을 수 있습니다.<br>모든 데이터를 읽은 후에는 버퍼를 지우고 다시 쓸 준비를 해야합니다. clear() 혹은 compact()를 호출함으로써 전체 버퍼를 지울 수 있습니다. (clear() 메서드는 버퍼 전체를 지우고, compact() 메서드는 이미 읽은 데이터만 지웁니다.)</p><h1 id="selectors"><a href="#Selectors" class="headerlink" title="Selectors"></a>Selectors</h1><p><strong>셀렉터를 사용하면 하나의 스레드가 여러 채널을 처리(handle)할 수 있습니다.</strong><br><img src="/images/post/2019-03-03/selector.png" alt="selector"><br>셀렉터는 사용을 위해 하나 이상의 채널을 셀렉터에 등록하고 <strong>select()</strong> 메서드를 호출해 등록 된 채널 중 이벤트 준비가 완료된 하나 이상의 채널이 생길 때까지 봉쇄(block)됩니다. 메서드가 반환(return)되면 스레드는 채널에 준비 완료된 이벤트를 처리할 수 있습니다. 즉, 하나의 스레드에서 여러 채널을 관리할 수 있으므로 여러 네트워크 연결을 관리할 수 있습니다. (SocketChannel, ServerSocketChannel)</p><h2 id="selector-생성"><a href="#Selector-생성" class="headerlink" title="Selector 생성"></a>Selector 생성</h2><p><strong><code>Selector.open()</code> 메서드를 통해 셀렉터를 생성할 수 있습니다.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure></p><h2 id="channels-등록"><a href="#Channels-등록" class="headerlink" title="Channels 등록"></a>Channels 등록</h2><p><strong>생성한 셀렉터에 채널을 등록하기 위해서는 다음과 같이 채널의 <code>register()</code> 메서드를 호출합니다.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure></p><p>셀렉터에 채널을 등록하기 위해서는 반드시 해당 채널이 non-blocking 모드로 변환되어야 합니다. (FileChannel은 non-blocking 모드로 변경이 불가능하기 때문에 셀렉터에 등록이 불가능합니다.)</p><p><strong>register() 메서드의 두 번째 매개 변수는 셀렉터를 통해 채널에서 발생하는 이벤트 중 확인(알림)하고자 하는 이벤트의 집합을 의미합니다.<br>이벤트에는 4가지 종류가 있으며, 이 4가지 이벤트는 <code>SelectionKey</code> 상수로 표시됩니다.</strong></p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><p>둘 이상의 이벤트 상수는 다음과 같이 사용 가능합니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE</span><br></pre></td></tr></table></figure></p><h2 id="selectionkey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h2><p>register() 메서드를 이용해 채널을 셀렉터에 등록하면 SelectionKey 객체가 반환됩니다. 이 SelectionKey 객체에는 몇 가지 속성들이 있습니다.</p><ul><li>The interest set</li><li>The ready set</li><li>The Channel</li><li>The Selector</li><li>An attached object (optional)</li></ul><h3 id="interest-set"><a href="#interest-Set" class="headerlink" title="interest Set"></a>interest Set</h3><p>interest set은 셀렉터에 등록된 채널이 확인하고자 하는 이벤트 집합(세트)입니다. 다음과 같이 SelectionKey를 이용해 해당 interest set을 확인할 수 있습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure></p><h3 id="ready-set"><a href="#Ready-Set" class="headerlink" title="Ready Set"></a>Ready Set</h3><p>ready set은 셀렉터에 등록된 채널에서 준비되어 처리(handle) 가능한 이벤트의 집합입니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readySet = SelectionKey.readyOps();</span><br></pre></td></tr></table></figure></p><p>위와 같이 interest Set과 동일한 방식으로 확인할 수도 있지만 아래와 같이 4가지 메소드를 이용해서 확인할 수도 있습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure></p><h3 id="channel-selector"><a href="#Channel-Selector" class="headerlink" title="Channel + Selector"></a>Channel + Selector</h3><p>SelectionKey를 이용해 채널과 셀렉터에 쉽게 접근할 수 있습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line"></span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure></p><h3 id="attaching-objects"><a href="#Attaching-Objects" class="headerlink" title="Attaching Objects"></a>Attaching Objects</h3><p>SelectionKey에 객체를 첨부(attach)할 수 있습니다. 이 방법을 이용하면 채널에 추가 정보나 채널에서 사용하는 버퍼와 같은 객체들을 쉽게 첨부할 수 있습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line"></span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure></p><p>selectionKey를 통해 직접 attach 하는 것 뿐만 아니라 셀렉터에 채널을 등록하면서 객체를 첨부할 수도 있습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure></p><h2 id="셀렉터를-이용해-채널-선택"><a href="#셀렉터를-이용해-채널-선택" class="headerlink" title="셀렉터를 이용해 채널 선택"></a>셀렉터를 이용해 채널 선택</h2><p><strong>셀렉터에 하나 이상의 채널을 등록한 후에는 <code>select()</code> 메소드를 호출할 수 있습니다. select() 메소드는 accept, connect, read, write 이벤트에 대해 준비(ready) 되어 있는 채널을 반환합니다.</strong> select() 메소드는 다음과 같이 3가지 방식으로 사용 가능합니다.</p><ul><li><strong>select()</strong><br>: 등록한 이벤트에 대해 하나 이상의 채널이 준비 될 때까지 봉쇄(block)됩니다. 몇개의 채널이 준비되었는지 준비된 채널의 수를 반환합니다. (마지막으로 select()를 호출한 이후 준비된 채널 수 입니다.)</li><li><strong>select(long timeout)</strong><br>: 최대 timeout(ms) 동안만 봉쇄한다는 점을 제외하면 select()와 동일합니다.</li><li><strong>selectNow()</strong><br>: select와 달리 봉쇄하지 않습니다. 준비된 채널이 있으면 즉시 반환됩니다.</li></ul><h3 id="selectedkeys"><a href="#selectedKeys" class="headerlink" title="selectedKeys()"></a>selectedKeys()</h3><p><strong>select() 메서드를 통해 하나 이상의 준비된 채널이 발생하면, <code>selectedKeys()</code> 메서드를 사용해 준비된 채널의 집합을 반환 받습니다.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure></p><p>반환된 SelectionKey set을 반복해 준비된 채널에 접근할 수 있습니다. 채널의 이벤트 처리가 끝나면 keyIterator.remove()를 통해 키 세트에서 제거해야 합니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    </span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="serversocketchannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h1><p><strong>NIO ServerSocketChannel은 표준 자바 네트워킹의 ServerSocket과 마찬가지로 들어오는 TCP 연결을 수신 대기 할 수 있는 채널입니다.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something with socketChannel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="non-blocking-mode"><a href="#Non-blocking-Mode" class="headerlink" title="Non-blocking Mode"></a>Non-blocking Mode</h2><p><strong>ServerSocketChannel은 non-blocking 모드로 설정이 가능합니다.</strong> non-blocking 모드에서는 accept() 메서드가 즉시 반환되므로 들어오는 연결이 없으면 null을 반환할 수 있습니다. 이에 따라 반환 된 ServerSocketChannel이 null인지 확인해야합니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// do something with socketChannel...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="socketchannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h1><p><strong>NIO SocketChannel은 TCP 네트워크 소켓에 연결된 채널입니다. 표준 자바 네트워킹의 Socket과 역할이 같습니다.</strong></p><h2 id="non-blocking-mode"><a href="#Non-blocking-Mode-1" class="headerlink" title="Non-blocking Mode"></a>Non-blocking Mode</h2><p><strong>ServerSocketChannel과 마찬가지로 SocketChannel을 non-blocking 모드로 설정할 수 있습니다.</strong> non-blocking 모드에서는 connect(), read(), write()를 호출할 수 있습니다.</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h3><p>SocketChannel이 non-blocking 모드일 때, connect()를 호출하면 메서드가 연결이 설정되기 전에 반환될 수 있습니다. 연결이 설정되었는지 확인하기 위해서 finishConnect() 메서드를 이용할 수 있습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://naver.com"</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!socketChannel.finishConnect()) &#123;</span><br><span class="line">    <span class="comment">// wait, or do something else...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h3><p>non-blocking 모드일 때, read() 메서드는 데이터를 전혀 읽지 않고 반환 될 수 있습니다. 따라서 반환 된 결과(int)를 갖고 판단해야 합니다. 반환 된 결과(int)는 읽은 바이트 수를 나타냅니다.</p><h1 id="멀티플렉싱-기반의-다중-접속-서버"><a href="#멀티플렉싱-기반의-다중-접속-서버" class="headerlink" title="멀티플렉싱 기반의 다중 접속 서버"></a>멀티플렉싱 기반의 다중 접속 서버</h1><p>지금까지 살펴본 Channel, Buffer, Selector를 이용해 간단한 echo 서버를 만들어 보았습니다.</p><h2 id="echoserverjava"><a href="#EchoServer-java" class="headerlink" title="EchoServer.java"></a>EchoServer.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">"EXIT"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ServerSocketChannel serverSocket = ServerSocketChannel.open();</span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">3000</span>));</span><br><span class="line">        serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey key = iter.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    register(selector, serverSocket);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    answerWithEcho(buffer, key);</span><br><span class="line">                &#125;</span><br><span class="line">                iter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">answerWithEcho</span><span class="params">(ByteBuffer buffer, SelectionKey key)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">        client.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span> String(buffer.array()).trim().equals(EXIT)) &#123;</span><br><span class="line">            client.close();</span><br><span class="line">            System.out.println(<span class="string">"Not accepting client messages anymore"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buffer.flip();</span><br><span class="line">        client.write(buffer);</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Selector selector, ServerSocketChannel serverSocket)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SocketChannel client = serverSocket.accept();</span><br><span class="line">        client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        System.out.println(<span class="string">"new client connected..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="실행-결과"><a href="#실행-결과" class="headerlink" title="실행 결과"></a>실행 결과</h2><p><img src="/images/post/2019-03-03/echo_server_with_select.gif" alt="echo_server_with_select"></p><h1 id="java-nio-vs-io"><a href="#Java-NIO-vs-IO" class="headerlink" title="Java NIO vs IO"></a>Java NIO vs IO</h1><h2 id="stream-oriented-vs-buffer-oriented"><a href="#Stream-Oriented-vs-Buffer-Oriented" class="headerlink" title="Stream Oriented vs Buffer Oriented"></a>Stream Oriented vs Buffer Oriented</h2><p><strong>스트림 지향의 IO는 스트림에서 한 번에 하나 이상의 바이트를 읽는 것을 의미합니다.</strong> 읽은 바이트를 이용해 유저가 데이터를 처리해야 하며 읽힌 바이트는 따로 캐시되지 않습니다. 또한 스트림의 데이터는 임의로 유저가 앞뒤로 이동할 수 없습니다. 스트림에서 읽은 데이터를 앞뒤로 이동해야 하는 경우는 먼저 스트림의 데이터를 읽어 버퍼에 캐시해야합니다.</p><p><strong>버퍼 지향의 NIO 방식은 조금 다릅니다. 데이터는 나중에 처리되는 임의의 버퍼로 읽어집니다.</strong> 필요에 따라 버퍼에서 앞뒤로 이동할 수 있습니다. 이로 인해 버퍼를 이용한 처리 과정에서 좀 더 유연한 사용이 가능합니다. 그러나 버퍼를 이용해 완전히 처리하려면 필요한 모든 데이터가 버퍼에 들어있는지 확인해야합니다. 또한 버퍼에 더 많은 데이터를 읽을 때, 아직 처리하지 않은 버퍼의 데이터를 덮어 쓰지 않도록 주의해야합니다.</p><h2 id="blocking-vs-non-blocking-io"><a href="#Blocking-vs-Non-blocking-IO" class="headerlink" title="Blocking vs Non-blocking IO"></a>Blocking vs Non-blocking IO</h2><p><strong>자바 IO의 스트림을 이용하면 봉쇄(block)됩니다.</strong> 즉, 스레드가 read() 혹은 write()를 호출하면 읽은 데이터가 있거나 데이터가 완전히 쓰여질 때까지 해당 스레드가 차단되어 그 동안 스레드는 아무 것도 할 수 없습니다.</p><p><strong>자바 NIO의 Non-blocking 모드는 스레드가 채널에서 데이터 읽기를 요청할 때, 현재 사용할 수 있는 데이터가 없는 경우 사용 가능한 데이터가 준비될 때까지 기다리지 않습니다.</strong> 때문에 해당 스레드는 봉쇄되지 않고 계속 진행될 수 있습니다. 쓰기 작업 또한 마찬가지 입니다. 스레드는 일부 데이터를 채널에 쓰도록 요청할 수 있지만 완전히 쓰여지기를 기다리지는 않습니다.</p><h2 id="selectos"><a href="#Selectos" class="headerlink" title="Selectos"></a>Selectos</h2><p><strong>자바 NIO의 셀렉터는 하나의 스레드에서 다중 입력 채널을 관리할 수 있습니다.</strong> 이 멀티플렉싱 메커니즘을 사용하면 단일 스레드에서 여러 채널의 입출력을 쉽게 관리할 수 있습니다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener">Java NIO Tutorial</a></li><li><a href="https://www.baeldung.com/java-nio-selector" target="_blank" rel="noopener">Introduction to the Java NIO Selector</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;자바 NIO에 대한 소개와 NIO와 함께 도입된 자바에서 I/O 멀티플렉싱(multiplexing)을 구현한 selector에 대해 알아봅니다. I/O 멀티플렉싱(multiplexing)에 대한 개념에 대해 아직 잘 이해하지 못하고 있다면 먼저 
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://jongmin92.github.io/categories/Programming/Java/"/>
    
    
      <category term="nio" scheme="https://jongmin92.github.io/tags/nio/"/>
    
      <category term="select" scheme="https://jongmin92.github.io/tags/select/"/>
    
      <category term="multiplexing" scheme="https://jongmin92.github.io/tags/multiplexing/"/>
    
  </entry>
  
  <entry>
    <title>멀티플렉싱 기반의 다중 접속 서버로 가기까지</title>
    <link href="https://jongmin92.github.io/2019/02/28/Java/java-with-non-blocking-io/"/>
    <id>https://jongmin92.github.io/2019/02/28/Java/java-with-non-blocking-io/</id>
    <published>2019-02-27T15:33:00.000Z</published>
    <updated>2019-03-09T04:50:29.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="소켓이란"><a href="#소켓이란" class="headerlink" title="소켓이란?"></a>소켓이란?</h1><p><code>소켓</code>은 네트워크 상에서 서버와 클라이언트 두개의 프로그램이 특정 포트를 통해 양방향 통신이 가능하도록 만들어주는 추상화된 장치입니다. <strong>메모리의 유저 공간에 존재하는 프로세스(서버, 클라이언트)는 커널 공간에 생성된 소켓을 통해 데이터를 송수신할 수 있습니다.</strong><br><img src="/images/post/2019-02-21/socket_1.png" alt="socket"></p><p>소켓은 아래와 같이 지역(로컬) IP 주소, Port 번호와 상대방의 IP 주소와 Port 번호, 그리고 <code>수신 버퍼</code>와 <code>송신 버퍼</code>가 존재합니다. <strong>서버와 클라이언트의 소켓이 서로 연결된 후, 데이터가 들어오면 수신 버퍼로 수신 데이터가 쓰이고, 반대로 데이터를 내 보낼 때는 송신 버퍼에 데이터가 쓰입니다.</strong><br><img src="/images/post/2019-02-21/socket_2.png" alt="socket"></p><h1 id="c언어로-간단한-서버-amp-클라이언트-구현"><a href="#C언어로-간단한-서버-amp-클라이언트-구현" class="headerlink" title="C언어로 간단한 서버 &amp; 클라이언트 구현"></a>C언어로 간단한 서버 &amp; 클라이언트 구현</h1><p>C언어를 이용해 linux와 window에서 간단하게 소켓을 이용해 echo server와 client를 만들어 보겠습니다.<br><strong>코드 한줄 한줄을 전부 해석하기 보다는 주석을 참고해 server와 client에서 어떤 순서로 소켓이 만들어지고 통신이 이루어지는지에 중점을 두어 보겠습니다.</strong></p><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p><a href="https://en.wikipedia.org/wiki/Everything_is_a_file" target="_blank" rel="noopener">“Everything is a File”</a>라는 말이 있습니다. linux에서는 소켓도 하나의 파일(File), 더 정확히는 <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank" rel="noopener">파일 디스크립터(File descriptor)</a>로 생성되어 관리됩니다. 그러므로 저 수준 파일 입출력 함수를 기반으로 소켓 기반의 데이터 송수신이 가능합니다.</p><blockquote><p><code>파일 디스크립터(File descriptor)</code></p><ul><li>운영체제가 만든 파일을 구분하기 위한 일종의 숫자</li><li>저 수준 파일 입출력 함수는 입출력을 목적으로 파일 디스크립터를 요구한다.</li><li>저 수준 파일 입출력 함수에 소켓의 파일 디스크립터를 전달하면, 소켓을 대상으로 입출력을 진행한다.</li></ul></blockquote><h3 id="echo_serverc"><a href="#echo-server-c" class="headerlink" title="echo_server.c"></a>echo_server.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 파일 디스크립터를 위한 변수</span></span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> str_len, i;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_adr_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. socket 하나를 생성한다.</span></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. socket에 IP와 Port 번호를 할당한다.</span></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr*)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. server socket(listen socket)을 통해 클라이언트의 접속 요청을 대기한다.</span></span><br><span class="line">    <span class="comment">//    5개의 수신 대기열(큐)을 생성한다.</span></span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"listen() error"</span>);</span><br><span class="line"></span><br><span class="line">    clnt_adr_sz=<span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 4. 클라이언트 접속 요청을 수락한다. (클라이언트와 연결된 새로운 socket이 생성된다.)</span></span><br><span class="line">        clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>)</span><br><span class="line">            error_handling(<span class="string">"accept() error"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Connected client %d \n"</span>, i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 클라이언트와 연결된 socket을 통해 데이터를 송수신한다.</span></span><br><span class="line">        <span class="keyword">while</span>((str_len=read(clnt_sock, message, BUF_SIZE)) != <span class="number">0</span>)</span><br><span class="line">            write(clnt_sock, message, str_len);</span><br><span class="line"></span><br><span class="line">        close(clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="echo_clientc"><a href="#echo-client-c" class="headerlink" title="echo_client.c"></a>echo_client.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 파일 디스크립터를 위한 변수</span></span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;IP&gt; &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. socket 하나를 생성한다.</span></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. socket을 이용해 server의 server socket(listen socket)에 연결을 요청한다.</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (struct sockaddr*)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"connect() error!"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Connected..........."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"Input message(Q to quit): "</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        fgets(message, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message,<span class="string">"q\n"</span>) || !<span class="built_in">strcmp</span>(message,<span class="string">"Q\n"</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 연결된 socket을 통해 server로부터 데이터를 송수신한다.</span></span><br><span class="line">        write(sock, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">        str_len = read(sock, message, BUF_SIZE<span class="number">-1</span>);</span><br><span class="line">        message[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Message from server: %s"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="결과-확인"><a href="#결과-확인" class="headerlink" title="결과 확인"></a>결과 확인</h3><p>gcc로 컴파일 후 실행하면 결과는 다음과 같습니다.<br><img src="/images/post/2019-02-21/echo_result.gif" alt="linux_simple_socket_result"></p><h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><p>window는 linux와 달리 파일이 아닌 별도의 소켓 구조체가 존재합니다. 별도의 소켓 구조체를 이용한 함수를 기반으로 소켓 기반의 데이터 송수신이 가능합니다.<br>window 코드의 결과는 위의 linux 코드의 결과와 같으므로 생략합니다.</p><h3 id="echo_server_winc"><a href="#echo-server-win-c" class="headerlink" title="echo_server_win.c"></a>echo_server_win.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// window socket</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    SOCKET hServSock, hClntSock;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> strLen, i;</span><br><span class="line"></span><br><span class="line">    SOCKADDR_IN servAdr, clntAdr;</span><br><span class="line">    <span class="keyword">int</span> clntAdrSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">        ErrorHandling(<span class="string">"WSAStartup() error!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. socket 하나를 생성한다.</span></span><br><span class="line">    hServSock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hServSock == INVALID_SOCKET)</span><br><span class="line">        ErrorHandling(<span class="string">"socket() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAdr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servAdr));</span><br><span class="line">    servAdr.sin_family = AF_INET;</span><br><span class="line">    servAdr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servAdr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 생성한 socket을 server socket(listen socket)으로 등록한다.</span></span><br><span class="line">    <span class="keyword">if</span> (bind(hServSock, (SOCKADDR*)&amp;servAdr, <span class="keyword">sizeof</span>(servAdr)) == SOCKET_ERROR)</span><br><span class="line">        ErrorHandling(<span class="string">"bind() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. server socket을 통해 클라이언트의 접속 요청을 확인한다.</span></span><br><span class="line">    <span class="keyword">if</span> (listen(hServSock, <span class="number">5</span>) == SOCKET_ERROR)</span><br><span class="line">        ErrorHandling(<span class="string">"listen() error"</span>);</span><br><span class="line"></span><br><span class="line">    clntAdrSize=<span class="keyword">sizeof</span>(clntAdr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 4. 클라이언트 접속 요청 대기 및 허락 (클라이언트와 연결된 새로운 socket이 생성된다.)</span></span><br><span class="line">        hClntSock = accept(hServSock, (SOCKADDR*)&amp;clntAdr, &amp;clntAdrSize);</span><br><span class="line">        <span class="keyword">if</span> (hClntSock == <span class="number">-1</span>)</span><br><span class="line">            ErrorHandling(<span class="string">"accept() error"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Connected client %d \n"</span>, i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 클라이언트와 연결된 socket을 통해 데이터를 송수신한다.</span></span><br><span class="line">        <span class="keyword">while</span>((strLen=recv(hClntSock, message, BUF_SIZE, <span class="number">0</span>)) != <span class="number">0</span>)</span><br><span class="line">            send(hClntSock, message, strLen, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        closesocket(hClntSock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closesocket(hServSock);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="echo_client_winc"><a href="#echo-client-win-c" class="headerlink" title="echo_client_win.c"></a>echo_client_win.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// window socket</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    SOCKET hSocket;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> strLen;</span><br><span class="line">    SOCKADDR_IN servAdr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;IP&gt; &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">        ErrorHandling(<span class="string">"WSAStartup() error!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. socket 하나를 생성한다.</span></span><br><span class="line">    hSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hSocket == INVALID_SOCKET)</span><br><span class="line">        ErrorHandling(<span class="string">"socket() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAdr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servAdr));</span><br><span class="line">    servAdr.sin_family = AF_INET;</span><br><span class="line">    servAdr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    servAdr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. socket을 이용해 server의 server socket(listen socket)에 연결을 요청한다.</span></span><br><span class="line">    <span class="keyword">if</span> (connect(hSocket, (SOCKADDR*)&amp;servAdr, <span class="keyword">sizeof</span>(servAdr)) == SOCKET_ERROR)</span><br><span class="line">        ErrorHandling(<span class="string">"connect() error!"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Connected..........."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"Input message(Q to quit): "</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        fgets(message, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message,<span class="string">"q\n"</span>) || !<span class="built_in">strcmp</span>(message,<span class="string">"Q\n"</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 연결된 socket을 통해 server로부터 데이터를 송수신한다.</span></span><br><span class="line">        send(hSocket, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>);</span><br><span class="line">        strLen = recv(hSocket, message, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        message[strLen] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Message from server: %s"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closesocket(hSocket);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="고찰"><a href="#고찰" class="headerlink" title="고찰"></a>고찰</h2><p>linux와 window의 서버 &amp; 클라이언트 소켓 생성과 연결 과정은 다음과 같습니다.<br><img src="/images/post/2019-02-21/server_client_socket.png" alt="server_client_socket"></p><ul><li>서버<ul><li>클라이언트로부터의 연결요청도 일종의 데이터 전송입니다. 따라서 연결 요청을 받아들이기 위해서도 하나의 소켓이 필요하고, 이 소켓을 가리켜 <code>서버소켓</code> 또는 <code>리스닝 소켓</code>이라고 합니다. listen 함수의 호출은 소켓을 리스닝 소켓으로 만듭니다.</li><li>accept 함수의 결과로 서버소켓을 통해 클라이언트로부터의 연결요청을 받으면, 연결요청 정보를 참조하여 <strong>클라이언트 소켓과의 통신을 위한 별도의 소켓을 추가로 하나 더 생성합니다. 그리고 이렇게 생성된 소켓을 대상으로 데이터의 송수신이 진행됩니다.</strong></li></ul></li><li>클라이언트<ul><li>소켓을 생성하고 연결 요청을 위해서 connect 함수를 호출하는 것이 전부입니다.</li><li>서버의 listen 함수호출 이후에야(서버소켓이 준비된 이후) connect 함수 호출이 유효합니다.</li></ul></li></ul><h3 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h3><p><img src="/images/post/2019-02-21/echo_result_problem.gif" alt="linux_simple_socket_result"><br>위 예제의 경우 반복적(Iterable)으로 accept 함수를 호출하면, 계속해서 클라이언트의 연결요청을 수락할 수 있습니다. 그러나, 동시에 둘 이상의 클라이언트에게 서비스를 제공할 수 있는 상태는 아닙니다. (처음 소켓 연결을 맺은 클라이언트가 종료하기 전까지는 다른 클라이언트의 연결은 listen 큐에 들어가 대기해야합니다.)</p><p><strong>이 문제를 해결하기 위해 둘 이상의 클라이언트들이 동시에 접속해 서버로부터 서비스를 제공받을 수 있는 여러 <code>다중 접속 서버</code>의 구현 방법들에 대해 알아보겠습니다.</strong></p><blockquote><p>다중 접속 서버 구현 방법</p><ul><li><strong>멀티프로세스 기반 서버</strong> : 다수의 프로세스를 생성하는 방식으로 서비스를 제공한다.</li><li><strong>멀티스레드 기반 서버</strong> : 클라이언트의 수만큼 스레드를 생성하는 방식으로 서비스를 제공한다.</li><li><strong>멀티플렉싱 기반 서버</strong> : 입출력 대상을 묶어서 관리하는 방식으로 서비스를 제공한다.</li></ul></blockquote><h1 id="멀티프로세스-기반의-다중-접속-서버"><a href="#멀티프로세스-기반의-다중-접속-서버" class="headerlink" title="멀티프로세스 기반의 다중 접속 서버"></a>멀티프로세스 기반의 다중 접속 서버</h1><p><strong><code>멀티프로세스 기반의 다중 접속 서버</code>는 다수의 프로세스를 생성하는 방식으로 서비스를 제공합니다.</strong><br><img src="/images/post/2019-02-21/multi_process_server.png" alt="multi_process_server"></p><ol><li>부모 프로세스는 <code>리스닝 소켓</code>으로 accept 함수 호출을 통해서 연결요청을 수락합니다. </li><li>이때 얻게 되는 소켓의 파일 디스크립터(<code>클라이언트와 연결된 연결 소켓</code>)를 자식 프로세스를 생성해 넘겨줍니다.</li><li>자식 프로세스는 전달받은 파일 디스크립터를 바탕으로 서비스를 제공합니다.</li></ol><p>핵심은 연결이 하나 생성될 때마다 프로세스를 생성해서 해당 클라이언트에 대해 서비스를 제공하는 것입니다.</p><h2 id="echo_multi_process_serverc"><a href="#echo-multi-process-server-c" class="headerlink" title="echo_multi_process_server.c"></a>echo_multi_process_server.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_childproc</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="keyword">int</span> str_len, state;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    act.sa_handler = read_childproc;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    state = sigaction(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 1. socket 하나를 생성한다.</span></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. socket에 IP와 Port 번호를 할당한다.</span></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr*) &amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">    <span class="comment">// 3. 생성한 socket을 server socket(listen socket)으로 등록한다.</span></span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"listen() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        <span class="comment">// 4. 부모 프로세스는 리스닝 소켓으로 accept 함수 호출을 통해서 연결요청을 수락한다.</span></span><br><span class="line">        clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"new client connected..."</span>);</span><br><span class="line">        <span class="comment">// 5. 이때 얻게 되는 소켓의 파일 디스크립터(클라이언트와 연결된 연결 소켓)를 자식 프로세스를 생성해 넘겨준다.</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            close(clnt_sock);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            close(serv_sock);</span><br><span class="line">            <span class="comment">// 6. 자식 프로세스는 전달받은 파일 디스크립터를 바탕으로 서비스를 제공한다.</span></span><br><span class="line">            <span class="keyword">while</span>((str_len = read(clnt_sock, buf, BUF_SIZE)) != <span class="number">0</span>)</span><br><span class="line">                write(clnt_sock, buf, str_len);</span><br><span class="line"></span><br><span class="line">            close(clnt_sock);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"client disconnected..."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            close(clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_childproc</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"removed proc id: %d \n"</span>, pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결과-확인"><a href="#결과-확인-1" class="headerlink" title="결과 확인"></a>결과 확인</h2><p><img src="/images/post/2019-02-21/echo_result_multi_process.gif" alt="echo_result_multi_process"><br>위에서 Iterable하게 구현했을때 발생했던 문제를 각 클라이언트 요청마다 별도의 프로세스를 생성함으로써 문제를 해결한 것을 확인할 수 있습니다.</p><h2 id="고찰"><a href="#고찰-1" class="headerlink" title="고찰"></a>고찰</h2><ul><li>장점<ul><li>프로그램 흐름이 단순하기 때문에 이해하기 쉽습니다.</li><li>안정적인 동작이 가능합니다. 운영체제에서 프로세스는 서로 독립된 실행 객체로 존재합니다. 서로 독립된 메모리 공간을 갖고 서로 다른 프로세스끼리 서로 영향을 미치지 않고 독립적으로 수행이 가능합니다.</li></ul></li><li>단점<ul><li>프로세스 복사에 따른 성능 문제가 있습니다.</li><li>병렬 처리해야 하는 만큼의 프로세스를 생성해야 합니다.</li><li>fork에 의해 자식 프로세스가 생성될 경우, 부모 프로세스의 자원이 복사됩니다. (코드, 소켓을 포함한 모든 열린 파일들(파일 디스크립터)) 부모 프로세스로부터 accept되어 생성된 하나의 소켓에 대해 부모 프로세스와 자식 프로세스 모두에서 한 소켓에 대한 파일 디스크립터가 존재합니다. 따라서 두 파일 디스크립터를 모두 종료해야 해당 소켓을 제거할 수 있습니다.</li><li>서로 다른 독립적인 메모리 공간을 갖기 때문에 프로세스간 정보 교환이 어렵다.</li></ul></li></ul><p>위의 단점들은 각 클라이언트의 요청마다 프로세스가 아닌 스레드를 생성함으로써 해결할 수 있습니다.<br>다음으로 멀티프로세스 기반의 다중 접속 서버의 단점을 개선할 수 있는 멀티스레드 기반의 다중 접속 서버에 대해 알아보겠습니다.</p><h1 id="멀티스레드-기반의-다중-접속-서버"><a href="#멀티스레드-기반의-다중-접속-서버" class="headerlink" title="멀티스레드 기반의 다중 접속 서버"></a>멀티스레드 기반의 다중 접속 서버</h1><p><strong><code>멀티스레드 기반의 다중 접속 서버</code>는 다수의 스레드를 생성하는 방식으로 서비스를 제공합니다.</strong><br><img src="/images/post/2019-02-21/multi_thread_server.png" alt="multi_thread_server"></p><ol><li>메인 스레드는 <code>리스닝 소켓</code>으로 accept 함수 호출을 통해서 연결요청을 수락합니다. </li><li>이때 얻게 되는 소켓의 파일 디스크립터(<code>클라이언트와 연결된 연결 소켓</code>)를 별도의 워커 스레드를 생성해 넘겨줍니다.</li><li>워커 스레드는 전달받은 파일 디스크립터를 바탕으로 서비스를 제공합니다.</li></ol><p>핵심은 연결이 하나 생성될 때마다 프로세스가 아닌 스레드를 생성해서 해당 클라이언트에 대해 서비스를 제공하는 것입니다.</p><h2 id="echo_multi_thread_serverc"><a href="#echo-multi-thread-server-c" class="headerlink" title="echo_multi_thread_server.c"></a>echo_multi_thread_server.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">handle_clnt</span><span class="params">(<span class="keyword">void</span> * arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> * msg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> t_id;</span><br><span class="line">    <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="keyword">int</span> str_len, state;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. socket 하나를 생성한다.</span></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. socket에 IP와 Port 번호를 할당한다.</span></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr*) &amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">    <span class="comment">// 3. 생성한 socket을 server socket(listen socket)으로 등록한다.</span></span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"listen() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        <span class="comment">// 4. 메인 스레드는 리스닝 소켓으로 accept 함수 호출을 통해서 연결요청을 수락한다.</span></span><br><span class="line">        clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"new client connected..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 클라이언트와 연결된 소켓의 파일 디스크립터를 워커 스레드를 생성해 넘겨준다.</span></span><br><span class="line">        pthread_create(&amp;t_id, <span class="literal">NULL</span>, handle_clnt, (<span class="keyword">void</span>*)&amp;clnt_sock);</span><br><span class="line">        pthread_detach(t_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">handle_clnt</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clnt_sock=*((<span class="keyword">int</span>*)arg);</span><br><span class="line">    <span class="keyword">int</span> str_len=<span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 워커 스레드는 전달받은 파일 디스크립터를 바탕으로 서비스를 제공한다.</span></span><br><span class="line">    <span class="keyword">while</span>((str_len = read(clnt_sock, buf, BUF_SIZE)) != <span class="number">0</span>)</span><br><span class="line">        write(clnt_sock, buf, str_len);</span><br><span class="line"></span><br><span class="line">    close(clnt_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> * msg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(msg, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결과-확인"><a href="#결과-확인-2" class="headerlink" title="결과 확인"></a>결과 확인</h2><p><img src="/images/post/2019-02-21/echo_result_multi_thread.gif" alt="echo_result_multi_thread"><br>처음 Iterable하게 구현했을때 발생했던 문제를 각 클라이언트 요청마다 별도의 스레드를 생성함으로써 문제를 해결했으며, 클라이언트의 요청마다 각 프로세스를 할당해서 해결한 방법보다 스레드를 생성해 할당함으로써 리소스 소모를 줄였습니다.</p><h2 id="고찰"><a href="#고찰-2" class="headerlink" title="고찰"></a>고찰</h2><ul><li>장점<ul><li>프로세스 복사에 따른 비용보다 스레드 생성에 대한 비용이 적다.</li><li>스레드간 서로 공유하는 메모리를 갖기 때문에, 스레드간 정보 교환이 쉽다.</li></ul></li><li>단점<ul><li>하나의 프로세스 내의 다수의 스레드가 존재하기 때문에 하나의 스레드에서 문제가 생긴다면 프로세스에 영향을 미쳐 나머지 다수의 스레드에도 영향을 끼칠 수 있다.</li></ul></li></ul><p>각 클라이언트 요청마다 별도의 스레드를 생성함으로써 프로세스를 생성하던 방법보다 리소스의 비용을 줄일 수 있었고, 스레드들이 서로 공유하는 메모리를 가질 수 있는 환경이 되었습니다.<br>그러나 <strong><code>I/O 멀티플렉싱(multiplexing)</code> 기법을 사용한다면, 각 클라이언트 마다 별도의 스레드를 생성하는 것이 아닌 하나의 스레드에서 다수의 클라이언트에 연결된 소켓(파일 디스크립터)을 괸리하고 소켓에 이벤트(read/write)가 발생할 경우에만 별도의 스레드를 만들어 해당 이벤트를 처리하도록 구현할 수 있습니다.</strong></p><h1 id="멀티플렉싱-기반의-다중-접속-서버"><a href="#멀티플렉싱-기반의-다중-접속-서버" class="headerlink" title="멀티플렉싱 기반의 다중 접속 서버"></a>멀티플렉싱 기반의 다중 접속 서버</h1><p><code>입출력 다중화</code>란 하나의 프로세스 혹은 스레드에서 입력과 출력을 모두 다룰 수 있는 기술을 말합니다. 커널(kernel)에서는 <strong>하나의 스레드가 여러 개의 소켓(파일)을 핸들링 할 수 있는 <code>select</code>, <code>poll</code>, <code>epoll</code>과 같은 시스템 콜(system call)을 제공하고 있습니다.</strong></p><p>한개의 프로세스 혹은 스레드에서 한개의 클라이언트에 대한 입출력만 처리할 수 있었던 이유는 입출력 함수가 봉쇄(block)되었기 때문에, 입출력 데이터가 준비될때까지 무한정 봉쇄되어 여러 클라이언트의 입출력을 처리할 수 없었기 때문입니다.</p><p><strong>그러나 I/O 멀티플렉싱 기법을 사용하면 입출력 다중화에서도 입출력 함수는 여전히 봉쇄로 작동하지만, 입출력 함수를 호출하기전에 어떤 파일에서 입출력이 준비가 되었는지 확인할 수가 있습니다.</strong></p><blockquote><p><strong>봉쇄 (block)</strong></p><p>봉쇄를 이해하기 위해 먼저 두가지 짚고 넘어가야할 사항이 있습니다.</p><ol><li>애플리케이션에서 I/O 작업을 하는 경우, 스레드는 데이터 준비가 완료될 때까지 대기합니다. 예를 들어 소켓을 통해 read(recvfrom)를 수행하는 경우 데이터가 네트워크를 통해 도착하는 것을 기다립니다. 패킷이 네트워크를 통해 도착하면 커널 내의 버퍼에 복사됩니다. (처음에 커널 공간에 생성된 소켓의 구조에서 송신 버퍼와 수신 버퍼가 있는 것을 보았습니다.)</li><li>커널 내의 버퍼에 복사된 데이터를 애플리케이션에서 사용하기 위해서는 <code>커널 버퍼(kernel space)</code>에서 <code>유저 버퍼(user space)</code>로 복사 후 이용해야 합니다. 애플리케이션은 유버 모드에서 유저 버퍼에만 접근이 가능하기 때문입니다.</li></ol><p><strong>Blocking I/O Model</strong><br><img src="/images/post/2019-02-21/blocking_io_model.png" alt="blocking_io_model"><br>프로세스(스레드)는 하나의 소켓에 대해 recvfrom을 호출하고 데이터가 kernel space 도착해 user space의 프로세스 버퍼에 복사 될 때까지 시스템 호출이 반환되지 않습니다. <strong>즉 recvfrom은 kernel space에 데이터가 도착하길 기다리는것 부터 시작됩니다.</strong> 프로세스는 recvfrom을 호출할 때부터 반환 할 때까지 전체 프로세스가 봉쇄됩니다.</p></blockquote><p><strong>I/O Multiplexing Model</strong><br><img src="/images/post/2019-02-21/multiplexing_io_model.png" alt="multiplexing_io_model"><br>멀티플렉싱 모델에서는 select 함수를 호출해, 여러개의 소켓들 중 recvfrom이 가능한 소켓이 생길 때까지 대기합니다. select의 결과로 recvfrom을 호출할 수 있는 소켓의 목록이 반환되면, 해당 소켓들에 대해 recvfrom을 호출합니다.</p><p>봉쇄 모델(Blocking I/O model)에서는 하나의 프로세스(스레드)에서 하나의 소켓(파일 디스크립터)에 대해 recvfrom을 호출해 데이터가 kernel space에 도착했는지 확인하고 현재 읽을 수 있는 데이터가 없다면 봉쇄되어 대기했다면, <strong>멀티플렉싱 모델(I/O Multiplexing Model)에서는 하나 이상의 소켓(파일 디스크립터)이 준비 될 때까지 대기할 수 있습니다.</strong></p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p><strong><code>select</code> 방식은 이벤트(입력|출력|에러) 별로 감시할 파일들을 fd_set 이라는 파일 상태 테이블(fd 비트 배열)에 등록하고, 등록된 파일(파일 디스크립터)에 어떠한 이벤트가 발생했을 경우 fd_set을 확인하는 방식으로 동작합니다.</strong><br><img src="/images/post/2019-02-21/select_model.png" alt="select_model"><br>예를 들어 위와 같이 6개의 파일을 다루어야 한다고 했을 때, 6개의 파일에 대해 입출력 데이터가 준비될 때까지 이벤트를 기다리는 파일 상태 테이블을 준비합니다. 그 후 6개의 파일 중 입출력이 준비된 파일에 대해서 이벤트가 발생하면 이벤트가 발생한 파일 디스크립터의 수를 반환합니다. 이후 이벤트가 준비된 파일에 대해 입출력을 수행하는데 이미 데이터가 준비된 파일에 대해 입출력을 수행하기 때문에 봉쇄가 발생하지 않을 것이라는게 보장됩니다.</p><blockquote><p>int select(int nfds, fd_set <em>readfds, fd_set </em>writefds, fd_set <em>exceptfds, struct timeval </em>timeout)</p><ul><li>nfds: 검사 대상이 되는 파일 디스크립터의 수</li><li>readfs: 읽기 이벤트를 검사할 파일 디스크립터의 목록</li><li>writefds: 쓰기 이벤트를 검사할 파일 디스크립터의 목록</li><li>exceptfds: 예외 이벤트를 검사할 파일 디스크립터의 목록</li><li>timeout: 이벤트를 기다릴 시간 제한</li><li>반환 값: <strong>이벤트가 발생한 파일의 갯수</strong></li></ul><p>반환 값이 이벤트가 발생한 파일의 디스크립터 목록이 아닌 파일의 갯수임에 주의해야합니다. </p></blockquote><h3 id="echo_select_serverc"><a href="#echo-select-server-c" class="headerlink" title="echo_select_server.c"></a>echo_select_server.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    <span class="comment">// 파일 상태 테이블 선언</span></span><br><span class="line">    fd_set reads, cpy_reads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="keyword">int</span> fd_max, str_len, fd_num, i;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr*) &amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"listen() error"</span>);</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;reads); <span class="comment">// fd_set 테이블을 초기화한다.</span></span><br><span class="line">    FD_SET(serv_sock, &amp;reads); <span class="comment">// 서버 소켓(리스닝 소켓)의 이벤트 검사를 위해 fd_set 테이블에 추가한다.</span></span><br><span class="line">    fd_max = serv_sock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        cpy_reads = reads;</span><br><span class="line">        timeout.tv_sec = <span class="number">5</span>;</span><br><span class="line">        timeout.tv_usec = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// result</span></span><br><span class="line">        <span class="comment">// -1: 오류 발생</span></span><br><span class="line">        <span class="comment">// 0: 타임 아웃</span></span><br><span class="line">        <span class="comment">// 1 이상 : 등록된 파일 디스크립터에 해당 이벤트가 발생하면 이벤트가 발생한 파일 디스크립터의 수를 반환한다.</span></span><br><span class="line">        <span class="keyword">if</span> ((fd_num = select(fd_max+<span class="number">1</span>, &amp;cpy_reads, <span class="number">0</span>, <span class="number">0</span>, &amp;timeout)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd_num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;fd_max+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(i, &amp;cpy_reads)) &#123; <span class="comment">// fd_set 테이블을 검사한다.</span></span><br><span class="line">                <span class="comment">// 서버 소켓(리스닝 소켓)에 이벤트(연결 요청) 발생</span></span><br><span class="line">                <span class="keyword">if</span> (i == serv_sock) &#123;     <span class="comment">// connection request!</span></span><br><span class="line">                    adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">                    clnt_sock= accept(serv_sock, (struct sockaddr*)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line">                    FD_SET(clnt_sock, &amp;reads); <span class="comment">// fd_set 테이블에 클라이언트 소켓 디스크립터를 추가한다.</span></span><br><span class="line">                    <span class="keyword">if</span> (fd_max &lt; clnt_sock)</span><br><span class="line">                        fd_max = clnt_sock;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"connected client: %d \n"</span>, clnt_sock);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 클라이언트와 연결된 소켓에 이벤트 발생</span></span><br><span class="line">                <span class="keyword">else</span> &#123;   <span class="comment">// read message!</span></span><br><span class="line">                    str_len = read(i, buf, BUF_SIZE);</span><br><span class="line">                    <span class="keyword">if</span> (str_len == <span class="number">0</span>) &#123;   <span class="comment">// close request!</span></span><br><span class="line">                        FD_CLR(i, &amp;reads); <span class="comment">// fd_set 테이블에서 파일 디스크립터를 삭제한다.</span></span><br><span class="line">                        close(i);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"closed client: %d \n"</span>, i);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        write(i, buf, str_len);    <span class="comment">// echo!</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(buf, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="결과-확인"><a href="#결과-확인-3" class="headerlink" title="결과 확인"></a>결과 확인</h3><p><img src="/images/post/2019-02-21/echo_result_select.gif" alt="echo_result_select"></p><h3 id="고찰"><a href="#고찰-3" class="headerlink" title="고찰"></a>고찰</h3><ul><li>장점<ul><li>단일 프로세스(스레드)에서 여러 파일의 입출력 처리가 가능합니다.</li><li>지원 하는 OS가 많아 이식성이 좋습니다. (POSIX 표준)</li></ul></li><li>단점<ul><li>커널에 의해서 완성되는 기능이 아닌, 순수하게 함수에 의해 완성되는 기능이다. </li><li>select 함수의 호출을 통해서 전달된 정보는 커널에 등록되지 않은 것이며, 그래서 select 함수를 호출할 때마다 매번 관련 정보를 전달해야 합니다. </li><li>select 함수의 호출 결과가 이벤트가 발생한 파일 디스크립터의 개수이기 때문에 어떤 파일 디스크립터에서 이벤트가 발생했는지 확인하기 위해서는 fd_set 테이블 전체를 검사해야 합니다. (속도가 느립니다)</li><li>검사할 수 있는 fd 개수에 제한이 있습니다. (최대 1024개)</li><li>select 호출 때마다 데이터를 복사해야합니다. (select 함수를 호출한 후 이벤트를 처리할 때 fd_set 테이블 변경이 필요하기 때문에 미리 복사가 필요합니다)</li></ul></li></ul><blockquote><p><a href="https://ko.wikipedia.org/wiki/POSIX" target="_blank" rel="noopener">POSIX란?</a></p><p>POSIX(Portable Operating System Interface)는 이식 가능 운영 체제 인터페이스의 약자로, 서로 다른 UNIX OS의 공통 API를 정리하여 이식성이 높은 유닉스 응용 프로그램을 개발하기 위한 목적으로 IEEE가 책정한 애플리케이션 인터페이스 규격입니다.</p></blockquote><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll도 select와 마찬가지로 멀티플렉싱을 구현하기 위한 방법입니다. poll이 여러 개의 파일을 다루는 방법은 select와 마찬가지로 fd(파일 디스크립터)의 이벤트를 기다리다가 이벤트가 발생하면, poll에서의 block이 해제되고, 다음 루틴에서 어떤 fd에 이벤트가 발생했는지 검사하는 방식을 사용합니다.</p><p>poll의 동작 원리는 select와 비슷하므로 생략합니다. 간단히 select와 비교해 차이점에 대해서만 알아보겠습니다.</p><ul><li>장점<ul><li>select와 단일 프로세스(스레드)에서 여러 파일의 입출력 처리가 가능합니다.</li><li>select 방식처럼 표준 입력|출력|에러을 따로 감시할 필요가 없습니다.</li><li>select는 timeval이라는 구조체를 사용해 타임아웃 값을 세팅하지만, poll은 별다른 구조체 없이 타임아웃 기능을 지원합니다. </li></ul></li><li>단점<ul><li>일부 unix 시스템에서는 poll을 지원하지 않습니다.</li></ul></li></ul><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll은 select 함수의 단점 극복을 위해 <strong>커널 레벨멀티플렉싱을 지원해줍니다.</strong> 커널에 관찰대상에 대한 정보를 한 번만 전달하고, 관찰대상의 범위, 또는 내용에 변경이 있을 때만 변경 사항을 알려줍니다. <strong>리눅스에서는 <code>epoll</code>, 윈도우에서는 <code>IOCP</code>, 맥에서는 <code>Kqueue</code>가 이에 해당합니다.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size); //size는 epoll_fd의 크기정보를 전달한다.</span><br><span class="line">// 반환 값 : 실패 시 -1, 일반적으로 epoll_fd의 값을 리턴</span><br><span class="line"></span><br><span class="line">int epoll_ctl(int epoll_fd,             // epoll_fd</span><br><span class="line">              int operate_enum,         // 어떤 변경을 할지 결정하는 enum값</span><br><span class="line">              int enroll_fd,            // 등록할 fd</span><br><span class="line">              struct epoll_event* event // 관찰 대상의 관찰 이벤트 유형</span><br><span class="line">              ); </span><br><span class="line">// 반환 값 : 실패 시 -1, 성공시 0</span><br><span class="line"></span><br><span class="line">int epoll_wait(int epoll_fd,              // epoll_fd</span><br><span class="line">               struct epoll_event* event, // event 버퍼의 주소</span><br><span class="line">               int maxevents,             // 버퍼에 들어갈 수 있는 구조체 최대 개수</span><br><span class="line">               int timeout                // select의 timeout과 동일 단위는 1/1000</span><br><span class="line">               );</span><br><span class="line">// 성공시 이벤트 발생한 파일 디스크립터 개수 반환, 실패시 -1 반환</span><br></pre></td></tr></table></figure><blockquote><ul><li>epoll_create : epoll 파일 디스크립터 저장소 생성</li><li>epoll_ctl : 저장소에 파일 디스크립터 등록 및 삭제</li><li>epoll_wait : select 함수와 마찬가지로 파일 디스크립터의 변화를 대기한다.</li></ul><p>epoll_create를 통해 생성된 epoll 인스턴스에 관찰대상을 저장 및 삭제하는 함수가 epoll_ctl이고, epoll 인스턴스에 등록된 파일 디스크립터를 대상으로 이벤트의 발생 유무를 확인하는 함수가 epoll_wait이다.</p></blockquote><h3 id="echo_epoll_serverc"><a href="#echo-epoll-server-c" class="headerlink" title="echo_epoll_server.c"></a>echo_epoll_server.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 리눅스에서만 사용 가능</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLL_SIZE 50</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="keyword">int</span> str_len, i;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">ep_events</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="keyword">int</span> epfd, event_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr*) &amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"listen() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 커널이 관리하는 epoll 인스턴스라 불리는 파일 디스크립터의 저장소 생성</span></span><br><span class="line">    <span class="comment">// 성공 시 epoll 파일 디스크립터, 실패시 -1 반환</span></span><br><span class="line">    epfd = epoll_create(EPOLL_SIZE);</span><br><span class="line">    ep_events = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct epoll_event)*EPOLL_SIZE);</span><br><span class="line"></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = serv_sock;</span><br><span class="line">    <span class="comment">// 파일 디스크립터(serv_sock)를 epoll 인스턴스에 등록한다. (관찰대상의 관찰 이벤트 유형은 EPOLLIN)</span></span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 성공 시 이벤트가 발생한 파일 디스크립터이ㅡ 수, 실패 시 -1 반환</span></span><br><span class="line">        <span class="comment">// 두 번째 인자로 전달된 주소의 메모리 공간에 이벤트 발생한 파일 디스크립터에 대한 정보가 들어있다.</span></span><br><span class="line">        event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (event_cnt == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"epoll_wait() error"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;event_cnt; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ep_events[i].data.fd == serv_sock) &#123;</span><br><span class="line">                adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">                clnt_sock= accept(serv_sock, (struct sockaddr*)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line">                event.events = EPOLLIN;</span><br><span class="line">                event.data.fd = clnt_sock;</span><br><span class="line">                <span class="comment">// 파일 디스크립터(clnt_sock)를 epoll 인스턴스에 등록한다. (관찰대상의 관찰 이벤트 유형은 EPOLLIN)</span></span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, &amp;event);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"connected client: %d \n"</span>, clnt_sock);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                str_len = read(ep_events[i].data.fd, buf, BUF_SIZE);</span><br><span class="line">                <span class="keyword">if</span> (str_len == <span class="number">0</span>) &#123; <span class="comment">// close request!</span></span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(ep_events[i].data.fd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"closed client: %d \n"</span>, ep_events[i].data.fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    write(ep_events[i].data.fd, buf, str_len);    <span class="comment">// echo!</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(serv_sock);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(buf, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="결과-확인"><a href="#결과-확인-4" class="headerlink" title="결과 확인"></a>결과 확인</h3><p><img src="/images/post/2019-02-21/echo_result_epoll.gif" alt="echo_result_epoll"></p><h3 id="고찰"><a href="#고찰-4" class="headerlink" title="고찰"></a>고찰</h3><ul><li>장점<ul><li>상태변화의 확인을 위한, 전체 파일 디스크립터를 대상으로 하는 반복문이 필요 없습니다.</li><li>select 함수에 대응하는 epoll_wait 함수호출 시, 커널에서 상태정보를 유지하기 때문에 관찰대상의 정보를 매번 전달할 필요가 없습니다.</li></ul></li><li>단점<ul><li>리눅스의 select 기반 서버를 윈도우의 select 기반 서버로 변경하는 것은 간단하나, 리눅스의 epoll 기반의 서버를 윈도우의 IOCP 기반으로 변경하는 것은 select를 이용하는 것보다 번거롭습니다.</li></ul></li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html" target="_blank" rel="noopener">I/O Models</a></li><li><a href="https://notes.shichao.io/unp/ch6/" target="_blank" rel="noopener">I/O Multiplexing: The select and poll Functions</a> </li><li><a href="http://www.hanbit.co.kr/store/books/look.php?p_code=B2142415021" target="_blank" rel="noopener">뇌를 자극하는 TCP/IP 소켓 프로그래밍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;소켓이란&quot;&gt;&lt;a href=&quot;#소켓이란&quot; class=&quot;headerlink&quot; title=&quot;소켓이란?&quot;&gt;&lt;/a&gt;소켓이란?&lt;/h1&gt;&lt;p&gt;&lt;code&gt;소켓&lt;/code&gt;은 네트워크 상에서 서버와 클라이언트 두개의 프로그램이 특정 포트를 통해 양방향 
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://jongmin92.github.io/categories/Programming/Java/"/>
    
    
      <category term="select" scheme="https://jongmin92.github.io/tags/select/"/>
    
      <category term="multiplexing" scheme="https://jongmin92.github.io/tags/multiplexing/"/>
    
      <category term="socket" scheme="https://jongmin92.github.io/tags/socket/"/>
    
      <category term="nonblocking" scheme="https://jongmin92.github.io/tags/nonblocking/"/>
    
      <category term="poll" scheme="https://jongmin92.github.io/tags/poll/"/>
    
      <category term="epoll" scheme="https://jongmin92.github.io/tags/epoll/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 구조와 I/O</title>
    <link href="https://jongmin92.github.io/2019/02/18/Programming/computer-structure/"/>
    <id>https://jongmin92.github.io/2019/02/18/Programming/computer-structure/</id>
    <published>2019-02-18T14:22:00.000Z</published>
    <updated>2019-03-09T04:50:29.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="computer-system"><a href="#Computer-system" class="headerlink" title="Computer system"></a>Computer system</h1><p>일반적인 컴퓨터 시스템은 <strong><code>CPU, 메모리, 외부 장치</code></strong>(ex. 하드디스크, 키보드, 모니터, 마우스)로 구성된다. CPU와 장치 컨트롤러들은 메모리 사이클을 두고 경쟁하며 동시에 실행된다. 경쟁상황에서 공유하는 메모리에 순차적으로 접근할 수 있도록 메모리 컨트롤러가 메모리에 대한 접근을 제어한다.</p><blockquote><p><code>장치 컨트롤러</code>: 컴퓨터 내의 각 하드웨어 장치에는 컨트롤러(Controller: 제어기)가 존재한다. 컨트롤러는 일종의 작은 CPU로서, 컴퓨터 전체에 CPU라는 중앙 처리 장치가 있듯이 컨트롤러는 각 하드웨어 장치마다 존재하면서 이들을 제어하는 작은 CPU라고 할 수 있다.<br><code>로컬 버퍼</code>: 장치 컨트롤러에는 장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리를 가지고 있다. 이를 로컬 버퍼(local buffer)라고 부른다.<br>디스크나 키보드 등에서 데이터를 읽어오는 경우, 우선 로컬 버퍼에 데이터가 임시로 저장된 후 메모리에 전달된다. 이 때, 장치에서 로컬 버퍼로 읽어오는 일은 컨트롤러가 담당한다.</p></blockquote><p><img src="/images/post/2019-02-18/computer_structure.png" alt="Computer system"></p><h1 id="io-inputoutput"><a href="#I-O-Input-Output" class="headerlink" title="I/O (Input/Output)"></a>I/O (Input/Output)</h1><p>컴퓨터는 목적을 달성하기 위해 CPU/메모리와 외부 장치간에 정보를 주고 받는다. 이를 I/O라고 말할 수 있다.<br>컴퓨터에서 연산을 한다는 것은 CPU가 무언가 일을 한다는 뜻이다. 입출력 장치들의 I/O 연산은 I/O 컨트롤러가 담당하고, 컴퓨터 내에서 수행되는 연산은 메인 CPU가 담당한다.<br><img src="/images/post/2019-02-18/input_output.png" alt="Computer system"></p><h1 id="cpu-context"><a href="#CPU-context" class="headerlink" title="CPU context"></a>CPU context</h1><p>어느 시점에나 CPU의 모든 레지스터 값은 CPU 컨텍스트를 정의한다. CPU 컨텍스트라 하면 프로세스 혹은 스레드에서 사용되는 데이터의 집합으로, 진행중이던 작업을 중단하고 나중에 같은 지점에서 다시 계속할 수 있도록 필요한 내용들을 포함하고 있다.</p><h1 id="dual-mode-operation"><a href="#Dual-mode-operation" class="headerlink" title="Dual mode operation"></a>Dual mode operation</h1><p>사용자 프로세스에서 운영체제(OS)를 보하하기 위해 하드웨어는 <code>사용자 모드(user mode)</code>와 <code>커널 모드(kernel mode)</code>라는 두 가지 모드를 제공한다. 두 가지 모드 작동은 CPU가 실행할 수 있는 작업의 유형과 범위에 제한을 둔다. (운영 체제 커널이 사용자 응용 프로그램 프로세스보다 많은 권한을 갖고 있다.)<br><img src="/images/post/2019-02-18/usermode_kernelmode.png" alt="usermode, kernelmode"></p><h1 id="system-call"><a href="#System-call" class="headerlink" title="System call"></a>System call</h1><p><strong>사용자 프로그램은 <code>시스템 호출(System call)</code>을 사용해서 운영 체제에게 서비스를 요청한다.</strong> 시스템 호출은 특별한 시스템 호출 예외를 사용하여 구현되어 있으며, 시스템 호출은 트랩(trap)이라고도 불린다.</p><blockquote><p>시스템 호출(System call)은 운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스이다. 보통 C나 C++과 같은 고급 언어로 작성된 프로그램들은 직접 시스템 호출을 사용할 수 없기 때문에 API를 통해 시스템 호출에 접근하게 하는 방법이다.<br>하드웨어 제어를 하는 모든 권한을 커널에서 가지고 있기 때문에 파일 시스템 같은 경우 응용 프로그램에서는 직접 제어할 수 없다. 따라서 응용 프로그램에서 하드웨어의 데이터를 가져오거나 쓰려면 커널의 장치 드라이버와 연동되어 실행되어야 한다. 결국 응용 프로그램이 파일 시스템을 이용하려면 커널의 파일 시스템 드라이버로 넘어가 실행되어야 하므로 시스템 호출 방법을 사용한다.</p></blockquote><p><img src="/images/post/2019-02-18/system_call.png" alt="system call"></p><h1 id="exceptions-and-interrupt"><a href="#Exceptions-and-Interrupt" class="headerlink" title="Exceptions and Interrupt"></a>Exceptions and Interrupt</h1><p><code>예외(Exception)</code>와 <code>인터럽트(Interrupt)</code>는 즉각 실행되어야 하는 이벤트를 CPU에게 알리는데 사용된다. <strong>인터럽트는 컨트롤러가 CPU에게 이벤트를 알리기 위해 사용한다.</strong></p><blockquote><p>CPU 옆에는 인터럽트 라인(interrupt line)이 있어서, CPU가 자신의 작업을 하던 중간에 인터럽트 라인에 신호가 들어오면 하던 일을 멈추고, 인터럽트와 관련된 일을 처리한다. 좀더 정확히 CPU는 명령 하나를 수행할 때마다 인터럽트가 발생했는지를 체크하고, 인터럽트가 발생했으면 다음 명령을 수행하기 전에 인터럽트 처리를 하게 되고 그렇지 않으면 다음 명령을 계속 수행하게 된다.</p></blockquote><h1 id="exception-and-interrupt-handler"><a href="#Exception-and-Interrupt-handler" class="headerlink" title="Exception and Interrupt handler"></a>Exception and Interrupt handler</h1><p>예외 혹은 인터럽트가 발생하면 사용자 모드에서 커널 모드로 실행이 전환된다. 예외 혹은 인터럽트가 처리된 후 다시 사용자 모드로 전환된다.<br><img src="/images/post/2019-02-18/interrupt_handler.png" alt="exception and interrupt handler"></p><p>조금 더 상세하게는 다음과 같은 과정을 거친다.<br><img src="/images/post/2019-02-18/interrupt_handle_detail.png" alt="interrupt handle detail"></p><ol><li>커널에 들어가는 동안 현재 실행중인 프로세스의 컨텍스트(CPU의 모든 레지스터의 값)가 먼저 메모리에 저장된다.</li><li>예외 / 인터럽트를 처리한다.</li><li>복원 및 재개할 프로세스를 선택한다.</li><li>선택한 프로세스의 컨텍스트를 복구한다.</li><li>선택한 프로세스의 실행을 재개한다.</li></ol><h1 id="read-string-system-call-design"><a href="#Read-string-system-call-design" class="headerlink" title="Read string system call design"></a>Read string system call design</h1><p>문자열(String)을 입력받는 System call을 디자인 해보자.</p><h2 id="input-buffer-amp-memory-safety"><a href="#Input-buffer-amp-Memory-safety" class="headerlink" title="Input buffer &amp; Memory safety"></a>Input buffer &amp; Memory safety</h2><ul><li>사용자 프로세스가 커널에 저장된 임의의 데이터를 읽을 수 있는 것은 바람직하지 않다.</li><li>사용자 프로세스가 입력 버퍼 외부에 데이터를 기록하여 커널을 손상시킬 수 있다. 이를 <a href="https://en.wikipedia.org/wiki/Buffer_overflow" target="_blank" rel="noopener">Buffer overflow</a>라고 한다.</li><li>메모리 보안을 위해 사용자 프로세스는 커널 데이터에 읽고 쓸 수 없지만, 커널은 사용자 공간에 데이터를 읽고 쓸 수 있다.</li></ul><h2 id="buffer-pointer"><a href="#Buffer-pointer" class="headerlink" title="Buffer pointer"></a>Buffer pointer</h2><p>커널은 사용자 공간에서 입력 버퍼에 대한 주소(pointer)를 알아야 한다.</p><h2 id="buffer-size"><a href="#Buffer-size" class="headerlink" title="Buffer size"></a>Buffer size</h2><p>커널은 입력 버퍼의 크기를 알아야하고 버퍼가 꽉 찼을 때 수행 할 작업을 결정해야한다.</p><h2 id="read-string-system-call-example"><a href="#Read-string-system-call-example" class="headerlink" title="Read string system call example"></a>Read string system call example</h2><p><img src="/images/post/2019-02-18/string_system_call.png" alt="string system call"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;computer-system&quot;&gt;&lt;a href=&quot;#Computer-system&quot; class=&quot;headerlink&quot; title=&quot;Computer system&quot;&gt;&lt;/a&gt;Computer system&lt;/h1&gt;&lt;p&gt;일반적인 컴퓨터 시스템은 &lt;str
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
    
      <category term="Computer System" scheme="https://jongmin92.github.io/tags/Computer-System/"/>
    
      <category term="Interrupt" scheme="https://jongmin92.github.io/tags/Interrupt/"/>
    
      <category term="System call" scheme="https://jongmin92.github.io/tags/System-call/"/>
    
      <category term="User mode" scheme="https://jongmin92.github.io/tags/User-mode/"/>
    
      <category term="Kernel mode" scheme="https://jongmin92.github.io/tags/Kernel-mode/"/>
    
  </entry>
  
  <entry>
    <title>&lt;객체지향의 사실과 오해&gt; 정리</title>
    <link href="https://jongmin92.github.io/2019/02/10/Programming/object_oriented_facts_and_misunderstandings/"/>
    <id>https://jongmin92.github.io/2019/02/10/Programming/object_oriented_facts_and_misunderstandings/</id>
    <published>2019-02-10T11:50:00.000Z</published>
    <updated>2019-02-10T12:32:41.034Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/post/2019-02-10/cover.png" alt=""><br><a href="https://book.naver.com/bookdb/book_detail.nhn?bid=9145968" target="_blank" rel="noopener">객체지향의 사실과 오해 (역할, 책임, 협력 관점에서 본 객체지향)</a></p><h1 id="협력하는-객체들의-공동체"><a href="#협력하는-객체들의-공동체" class="headerlink" title="협력하는 객체들의 공동체"></a>협력하는 객체들의 공동체</h1><ul><li>객체지향의 목표는 실세계를 모방하는 것이 아니다. 오히려 새로운 세계를 창조하는 것이다.</li><li>객체를 스스로 생각하고 스스로 결정하는 현실 세계의 생명체에 비유하는 것은 상태와 행위를 ‘캡슐화’하는 소프트웨어 객체의 ‘자율성’을 설명하는 데 효과적이다. 현실 세계의 사람들이 암묵적인 약속과 명시적인 계약을 기반으로 목표를 달성해 나가는 과정은 ‘메시지’를 주고받으며 공동의 목표를 달성하기 위해 ‘협력’하는 객체들의 관계를 설명하는 데 적합하다.</li><li>실세계의 모방이라는 객체지향의 개념은 훌륭한 프로그램을 설계하고 구현하는 실무적인 관점에서는 부적합하지만 객체지향이라는 용어에 담긴 기본 사상을 이해하고 학습하는 데는 매우 효과적이다.</li><li>역할은 관련성 높은 책임의 집합이다. 객체의 역할은 사람의 역할과 유사하게 다음과 같은 특징을 지닌다.<ul><li>여러 객체가 동일한 역할을 수행할 수 있다.</li><li>역할은 대체 가능성을 의미한다.</li><li>각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있다.</li><li>하나의 객체가 동시에 여러 역할을 수행할 수 있다.</li></ul></li><li>객체를 상태와 행동을 함께 지닌 실체라고 정의한다. 이 말은 객체가 협력에 참여하기 위해 어떤 행동을 해야 한다면 그 행동을 하는 데 필요한 상태도 함께 지니고 있어야 한다는 것을 의미한다.</li><li>과거의 전통적인 개발 방법은 데이터와 프로세스를 엄격하게 구분한다. 이에 반해 객체지향에서는 데이터와 프로세스를 객체라는 하나의 틀 안에 함께 묶어 놓음으로써 객체의 자율성을 보장한다. 이것이 전통적인 개발 방법과 객체지향을 구분 짓는 가장 핵심적인 차이다.</li><li>객체지향의 세계에서는 오직 한 가지 의사소통 수단만이 존재한다. 이를 메시지라고 한다.</li><li>객체지향이란?<ul><li>객체지향이란 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법이다.</li><li>자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미한다.</li><li>객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력한다. 각 객체는 협력 내에서 정해진 역할을 수행하며 역할은 관련된 책임의 집합이다.</li><li>객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는 데 적합한 메서드를 자율적으로 선택한다.</li></ul></li></ul><h1 id="이상한-나라의-객체"><a href="#이상한-나라의-객체" class="headerlink" title="이상한 나라의 객체"></a>이상한 나라의 객체</h1><ul><li>인간은 행동의 과정과 결과를 단순하게 기술하기 위해 상태라는 개념을 고안했다. 상태를 이용하면 과거에 얽매이지 않고 현재를 기반으로 객체의 행동 방식을 이해할 수 있다.</li><li>객체와 객체 사이의 의미 있는 연결을 링크라고 한다. 객체와 객체 사이에는 링크가 존재해야만 요청(메시지)을 보내고 받을 수 있다.</li><li>객체 간의 선으로 표현되는 링크와 달리 객체를 구성하는 단순한 값은 속성이라고 한다.</li><li>객체는 자율적인 존재이다. 객체지향의 세계에서 객체는 다른 객체의 상태에 직접적으로 접근할 수도, 상태를 변경할 수도 없다. 자율적인 객체는 스스로 자신의 상태를 책임져야 한다.</li><li>객체의 상태는 저절로 변경되지 않는다. 객체의 상태를 변경하는 것은 객체의 자발적인 행동뿐이다.</li><li>객체는 협력에 참여하는 과정에서 자기 자신의 상태뿐만 아니라 다른 객체의 상태 변경을 유발할 수도 있다.</li><li>객체의 행동으로 인해 발생하는 결과는 두 가지 관점에서 설명할 수 있다.<ul><li>객체 자신의 상태 변경</li><li>행동 내에서 협력하는 다른 객체에 대한 메시지 전송</li></ul></li><li>현실 세계의 객체와 객체지향 세계의 객체 사이에는 중요한 차이점이 있다. 현실과 달리 객체지향의 세계에서 모든 객체는 자신의 상태를 스스로 관리하는 자율적인 존재다.</li><li>객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다. 객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동뿐이다.</li><li>객체의 행동을 유발하는 것은 외부로부터의 전달된 메시지지만 객체의 상태를 변경할지 여부는 객체 스스로 결정한다. 사실 객체에게 메시지를 전달하는 외부의 객체는 메시지를 수신하는 객체의 상태가 변경된다는 사실조차 알지 못한다.</li><li>상태를 외부에 노출시키지 않고 행동을 경계로 캡슐화하는 것은 결과적으로 객체의 자율성을 높인다.</li><li>상태를 잘 정의된 행동 뒤로 캡슐화하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다.</li><li>상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 끼친다.<ul><li>상태를 먼저 결정할 경우 캡슐화가 저해된다.</li><li>객체를 협력자가 아닌 고립된 섬으로 만든다.</li><li>객체의 재사용성이 저하된다.</li></ul></li><li>객체지향 설계는 애플리케이션에 필요한 협력을 생각하고 협력에 참여하는 데 필요한 행동을 생각한 후 행동을 수행할 객체를 선택하는 방식으로 수행된다. 행동을 결정한 후에야 행동에 필요한 정보가 무엇인지를 고려하게 되며 이 과정에서 필요한 상태가 결정된다.</li><li>객체지향 세계는 현실 세계의 단순한 모방이 아니다. 소프트웨어 안에 구현된 상품 객체는 실제 세계의 상품과는 전혀 다른 양상을 띤다.<ul><li>현실 속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다.</li><li>소프트웨어 객체가 현실 객체의 부분적인 특징을 모방하는 것이 아니라 현실 객체가 가지지 못한 추가적인 능력을 보유하게 된다.</li><li>현실 세계와 객체지향 세계 사이의 관계를 좀 더 정확하게 설명할 수 있는 단어는 은유다.</li><li>현실 속의 객체의 의미 일부가 소프트웨어 객체로 전달되기 때문에 프로그램 내의 객체는 현실 속의 객체에 대한 은유다.</li></ul></li></ul><h1 id="역할-책임-협력"><a href="#역할-책임-협력" class="headerlink" title="역할, 책임, 협력"></a>역할, 책임, 협력</h1><ul><li>객체의 세계에서는 협력이라는 문맥이 객체의 행동 방식을 결정한다. 중요한 것은 개별 객체가 아니라 객체들 사이에 이뤄지는 협력이다.</li><li>객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소트웨어 객체에 할당하는 것이다. 책임을 어떻게 구현할 것인가 하는 문제는 객체와 책임이 제자리를 잡은 후에 고려해도 늦지 않다. 객체와 책임이 이리저리 부유하는 상황에서 성급하게 구현에 뛰어드는 것은 변경에 취약하고 다양한 협력에 참여할 수 없는 비자율적인 객체를 낳게 된다.</li><li>객체의 책임은 크게 ‘하는 것’과 ‘아는 것’의 두 가지 범주로 분류된다.<ul><li>하는 것<ul><li>객체를 생성하거나 계산을 하는 등의 스스로 하는 것</li><li>다른 객체의 행동을 시작시키는 것</li><li>다른 객체의 활동을 제어하고 조절하는 것</li></ul></li><li>아는 것<ul><li>개인적인 정보에 관해 아는 것</li><li>관련된 객체에 관해 아는 것</li><li>자신이 유도하거나 계산할 수 있는 것에 관해 아는 것</li></ul></li></ul></li><li>책임은 객체의 외부에 제공해 줄 수 있는 정보(아는 것의 측면)와 외부에 제공해 줄 수 있는 서비스(하는 것의 측면)의 목록이다. 따라서 책임은 객체의 공용 인터페이스를 구성한다.</li><li>객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것을 메시지 전송이라고 한다. 따라서 두 객체 간의 협력은 메시지를 통해 이뤄진다.</li><li>객체지향 설계는 협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고 어떤 객체로부터 메시지를 수신할 것인지를 결정하는 것으로부터 시작된다. 어떤 클래스가 필요하고 어떤 메서드를 포함해야 하는지를 결정하는 것은 책임과 메시지에 대한 대략적인 윤곽을 잡은 후에 시작해도 늦지 않다.</li><li>역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 표식이다. 협력 안에서 역할은 “이 자리는 해당 역할을 수행할 수 있는 어떤 객체라도 대신할 수 있습니다”라고 말하는 것과 같다.</li><li>역할을 대체하기 위해서는 각 역할이 수신할 수 있는 메시지를 동일한 방식으로 이해해야 한다.</li><li>역할은 객체지향 설계의 단순성, 유연성, 재사용성을 뒷받침하는 핵심 개념이다.</li><li>역할의 대체 가능성은 행위 호환성을 의미하고, 행위 호환성은 동일한 책임의 수행을 의미한다.</li></ul><h2 id="객체지향-설계-기법"><a href="#객체지향-설계-기법" class="headerlink" title="객체지향 설계 기법"></a>객체지향 설계 기법</h2><ul><li>책임-주도 설계(Responsibility-Driven Design)<ul><li>객체지향 설계란 애플리케이션의 기능을 구현하기 위한 협력 관계를 고안하고, 협력에 필요한 역할과 책임을 식별한 후 이를 수행할 수 있는 적절한 객체를 식별해 나가는 과정이다. 객체지향 설계의 핵심은 올바른 책임을 올바른 객체에게 할당하는 것이다.</li><li>책임-주도 설계에서는 시스템의 책임을 객체의 책임으로 변환하고, 각 객체가 책임을 수행하는 중에 필요한 정보나 서비스를 제공해줄 협력자를 찾아 해당 협력자에게 책임을 할당하는 순차적인 방식으로 객체들의 협력 공동체를 구축한다. 책임-주도 설계는 개별적인 객체의 상태가 아니라 객체의 책임과 상호작용에 집중한다.</li></ul></li><li>디자인 패턴(Design Pattern)<ul><li>디자인 패턴은 책임-주도 설계의 결과를 표현한다. 패턴은 모범이되는 설계다.</li><li>패턴은 반복해서 일어나는 특정한 상황에서 어떤 설계가 왜 더 효과적인지에 대한 이유를 설명한다.</li><li>특정 상황에 적용 가능한 디자인 패턴을 잘 알고 있다면 책임-주도 설계의 절차를 순차적으로 따르지 않고도 시스템 안에 구현할 객체들의 역할과 책임, 협력 관계를 빠르고 손 쉽게 포착할 수 있을 것이다.</li></ul></li><li>테스트-주도 개발(Test-Driven Development)<ul><li>테스트-주도 개발의 기본 흐름은 실패하는 테스트를 작성하고, 테스트를 통과하는 가장 간단한 코드를 작성한 후, 리팩터링을 통해 중복을 제거하는 것이다.</li><li>테스트-주도 개발은 객체가 이미 존재한다고 가정하고 객체에게 어떤 메시지를 전송할 것인지에 관해 먼저 생각하라고 충고한다. 그러나 이 같은 종류의 충고는 역할, 책임, 협력의 관점에서 객체를 바라보지 않을 경우 무의미하다.</li><li>테스트-주도 개발은 테스트를 작성하는 것이 아니라 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것이다.</li><li>테스트를 작성하기 위해 객체의 메서드를 호출하고 반환값을 검증하는 것은 순간적으로 객체가 수행해야 하는 책임에 관해 생각한 것이다. 테스트에 필요한 간접 입력 값을 제공하기 위해 스텁(stub)을 추가하거나 간접 출력 값을 검증하기 위해 목 객체(mock object)를 사용하는 것은 객체와 협력해야 하는 협력자에 관해 고민한 결과를 코드로 표현한 것이다.</li></ul></li></ul><h1 id="책임과-메시지"><a href="#책임과-메시지" class="headerlink" title="책임과 메시지"></a>책임과 메시지</h1><ul><li>객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문이다. 요청을 처리하기 위해 객체가 수행하는 행동을 책임이라고 한다. 따라서 자율적인 객체란 스스로의 의지와 판단에 따라 각자 맡은 책임을 수행하는 객체를 의미한다.</li><li>적절한 책임이 자율적인 객체를 낳고, 자율적인 객체들이 모여 유연하고 단순한 협력을 낳는다. 따라서 협력에 참여하는 객체가 얼마나 자율적인지가 전체 애플리케이션의 품질을 결정한다.</li><li>추상적이고 포괄적인 책임은 협력을 좀 더 다양한 환경에서 재사용할 수 있도록 유연성이라는 축복을 내려준다. 그러나 책임은 협력에 참여하는 의도를 명확하게 설명할 수 있는 수준 안에서 추상적이어야 한다.</li><li>객체가 다른 객체에게 접근할 수 있는 유일한 방법은 요청을 전송하는 것뿐이다. 그리고 이 요청을 메시지라고 부른다. 메시지는 객체로 하여금 자신의 책임, 즉 행동을 수행하게 만드는 유일한 방법이다.</li><li>메시지를 처리할 수 있다는 것은 객체가 해당 메시지에 해당하는 행동을 수행해야 할 책임이 있다는 것을 의미한다. 따라서 메시지의 개념은 책임의 개념과 연결된다. 송신자는 메시지 전송을 통해서만 다른 객체의 책임을 요청할 수 있고, 수신자는 오직 메시지 수신을 통해서만 자신의 책임을 수행할 수 있다. 따라서 객체가 수신할 수 있는 메시지의 모양이 객체가 수행할 책임의 모양을 결정한다.</li><li>객체가 유일하기 이해할 수 있는 의사소통 수단은 메시지 뿐이며 객체는 메시지를 처리하기 위한 방법을 자율적으로 선택할 수 있다. 외부의 객체는 메시지에 관해서만 볼 수 있고 객체 내부는 볼 수 없기 때문에 자연스럽게 객체의 외부와 내부가 분리된다.</li><li>메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다는 사실은 다른 프로그래밍 언어와 객체지향 프로그래밍 언어를 구분 짓는 핵심적인 특징 중 하나다. 이것은 프로시저 호출에 대한 실행 코드를 컴파일 시간에 결정하는 절차적인 언어와 확연히 구분되는 특징이다.</li></ul><ul><li>다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다. 서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해 메시지를 처리할 수 있는 메커니즘을 가리킨다.</li><li>다형성은 역할, 책임, 협력과 깊은 관련이 있다. 서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미한다.</li><li>다형성에서 중요한 것은 메시지 송신자의 관점이다. 메시지 수신자들이 동일한 오퍼레이션을 서로 다른 방식으로 처리하더라도 메시지 송신자의 관점에서 이 객체들은 동일한 책임을 수행하는 것이다. 즉, 다형성은 수신자의 종류를 캡슐화한다.</li><li>다형성은 송신자와 수신자 간의 객체 타입에 대한 결합도를 메시지에 대한 결합도로 낮춤으로써 달성된다. 다형성을 사용하면 메시지를 이해할 수 있는 어떤 객체와도 협력할 수 있는 유연하고 확장 가능한 구조를 만들 수 있다. 객체지향 패러다임이 강력한 이유는 다형성을 이용해 협력을 유연하게 만들 수 있기 때문이다.</li></ul><ul><li>객체지향의 기본 개념은 책임을 수행하는 자율적인 객체들의 협력을 통해 애플리케이션을 구축하는 것이다. 객체지향의 세계에서 객체들이 서로 협력하기 위해 사용할 수 있는 유일한 방법은 메시지를 전송하는 것이다.</li><li>객치지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것이다.</li><li>클래스 기반의 객체지향 언어를 사용하는 대부분의 사람들은 객체지향 애플리케이션을 클래스의 집합으로 생각한다. 프로그래머 입장에서 클래스는 실제로 볼 수 있고 수정할 수 있는 구체적인 존재다. 그러나 클래스는 단지 동적인 객체들의 특성과 행위를 정적인 텍스트로 표현하기 위해 사용할 수 있는 추상화 도구일 뿐이다. 중요한 것은 클래스가 아니라 객체다. 클래스를 정의하는 것이 먼저가 아니라 객체들의 속성과 행위를 식별하는 것이 먼저다. 클래스는 객체의 속성과 행위를  담는 틀일 뿐이다.</li><li>객체지향 패러다임으로의 전환은 시스템을 정적인 클래스들의 집합이 아니라 메시지를 주고받는 동적인 객체들의 집합으로 바라보는 것에서 시작된다. 클래스에 담길 객체들의 공통적인 행위와 속성을 포착하기 위해서는 먼저 협력하는 객체들의 관점에서 시스템을 바라봐야 한다. 진정한 객체지향 패러다임으로의 도약은 개별적인 객체가 아니라 메시지를 주고받는 객체들 사이의 커뮤니케이션에 초점을 맞출 때 일어난다.</li><li>훌륭한 객체지향 설계는 어떤 객체가 어떤 메시지를 전송할 수 있는가와 어떤 객체가 어떤 메시지를 이해할 수 있는가를 중심으로 객체 사이의 협력 관계를 구성하는 것이다. 이것은 개별 객체에 초점을 맞추는 관점과는 매우 다르다. 사실 협력이라는 문맥에서 벗어나 독립적인 객체에 관해 고민하는 것은 클래스에 초점을 맞추는 것과 별다른 차이가 없다.</li><li>객체지향 설계의 중심에는 메시지가 위치한다. 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다. 메시지가 객체를 선택하게 만들려면 메시지를 중심으로 협력을 설계해야 한다.</li></ul><ul><li>책임-주도 설계의 핵심은 어떤 행위가 필요한지를 먼저 결정한 후에 이 행위를 수행할 객체를 결정하는 것이다. 이 과정을 흔히 What/Who 사이클이라고 한다.</li><li>결론적으로 협력이라는 문맥 안에서 필요한 메시지를 먼저 결정한 후에 메시지를 수신하기에 적합한 객체를 선택한다. 그리고 수신된 메시지가 객체의 책임을 결정한다. 이것은 객체를 고립된 상태로 놓고 어떤 책임이 적절한지를 결정하는 것과는 근본적으로 다른 접근 방법이다.</li><li>협력이라는 문맥 안에서 객체의 책임을 결정하는 것은 메시지다. 책임이 먼저 오고 객체가 책임을 따른다. 결과적으로 시스템이 수행해야 하는 전체 행위는 협력하는 객체들의 책임으로 분배된다.</li><li>객체가 자신이 수신할 메시지를 결정하게 하지 말고 메시지가 협력에 필요한 객체를 발견하게 해야 한다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/post/2019-02-10/cover.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://book.naver.com/bookdb/book_detail.nhn?bid=9145968&quot; target=&quot;_blan
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
    
      <category term="book" scheme="https://jongmin92.github.io/tags/book/"/>
    
      <category term="review" scheme="https://jongmin92.github.io/tags/review/"/>
    
      <category term="OOP" scheme="https://jongmin92.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Mockito annotation을 사용하는 field 초기화 하기</title>
    <link href="https://jongmin92.github.io/2019/02/10/Java/mockito-anotation-field-initialize/"/>
    <id>https://jongmin92.github.io/2019/02/10/Java/mockito-anotation-field-initialize/</id>
    <published>2019-02-10T01:35:00.000Z</published>
    <updated>2019-02-10T15:13:48.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mockito-junit-rule"><a href="#Mockito-JUnit-rule" class="headerlink" title="Mockito JUnit rule"></a>Mockito JUnit rule</h1><p>Mockito에서 제공하는 <strong>@Mock, @Spy, @InjectMocks과 같은 annotation을 사용하는 field를 초기화 하는 방법</strong>으로는 2가지가 제공되고 있었다.</p><ul><li><p>JUnit test class에 <code>@RunWith(MockitoJUnitRunner.class)</code>를 추가하는 방법</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(MockitoJUnitRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> List list;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldDoSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.add(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>MockitoAnnotations.initMocks(Object)</code>을 @Before 메서드에서 실행하는 방법</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> List list;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldDoSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.add(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>그리고 추가로 Mockito <a href="https://static.javadoc.io/org.mockito/mockito-core/2.24.0/org/mockito/Mockito.html#mockito_junit_rule" target="_blank" rel="noopener">1.10.17</a> 버전부터 제공하는 <code>JUnit rule</code>을 이용하는 방법이 있다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> MockitoRule mockito = MockitoJUnit.rule();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> List list;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldDoSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.add(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>그럼 위의 3가지 방법 중 어떤 방법을 사용하는 것이 좋을까? 먼저, 3가지 방식들을 비교하기전에 <strong>Test Runner, @RunWith, Rule</strong>에 대해서 간단하게 알아보자.</p><h1 id="test-runner"><a href="#Test-Runner" class="headerlink" title="Test Runner"></a>Test Runner</h1><p><strong>JUnit 프레임워크에서 테스트 클래스 내에 존재하는 각각의 테스트 메소드 실행을 담 당하고 있는 클래스를 Test Runner라고 한다.</strong> Test Runner는 테스트 클래스의 구조에 맞게 테스트 메소드들을 실행하고 결과를 표시하는 역할을 수행한다. 우리 눈에는 보이지 않지만, 테스트 케이스를 IDE에서 실행하면 내부적으로 는 JUnit의 BlockJUnit4ClassRunner라는 Test Runner 클래스가 실행되고, IDE는 그 결과를 해석해서 우리에게 보기 편한 화면으로 보여준다.</p><blockquote><p>대부분의 Java 통합개발환경(IDE)은 JUnit 프레임워크를 내장 지원하고 있다. 그래서 종종 JUnit이 독립적인 프레임워크라기보다는 하나의 기능처럼 생각될 수 있다. 하지만 JUnit 프레임워크는 분명 독립적인 소프트웨어이고, 애초부터 그렇게 만들어 졌다. 그렇기 때문에 명령행 프롬프트에서 실행하거나 셸 스크립트 등을 이용해서 실행할 수도 있다.</p></blockquote><h1 id="runwith"><a href="#RunWith" class="headerlink" title="@RunWith"></a>@RunWith</h1><p>@RunWith annotation은 JUnit에 내장된 기본 테스트 러너인 BlockJUnit4ClassRunner 대신에 <strong>@RunWith(클래스이름.class)를 이용해 JUnit Test 클래스를 실행하기 위한 Test Runner를 명시적으로 지정할 수 있다.</strong> 지정된 클래스를 이용해 테스트 클래스 내의 테스트 메소드들을 수행하도록 지정해주는 annotation이다. 일종의 JUnit 프레임워크의 확장지점이다. 이런 구조를 이용해서 많은 애플리케이션이나 프레임워크가 자신에게 필요한 Test Runner를 직접 만들어 자신만의 고유한 기능을 추가해 테스트를 수행하고 있다. 예를 들면, 스프링 프레임워크에서 제공하는 SpringJUnit4ClassRunner, SpringRunner같은 클래스는 이 확장 기능을 이용한 대표적인 사례 중 하나다.</p><h1 id="rule"><a href="#Rule" class="headerlink" title="Rule"></a>Rule</h1><p>JUnit 4.7 버전부터 추가된 기능으로 <strong>하나의 테스트 클래스 내에서 각 테스트 메소드의 동작 방식을 재정의하거나 추가하기 위해 사용하는 기능이다.</strong> 테스트 케이스 수행을 좀 더 세밀하게 조작할 수 있게 된다.</p><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>MockitoJUnit의 rule을 사용하면 MockitoJUnitRunner와 똑같은 기능을 수행하면서, 다른 Test Runner를 사용할 수 있다. 사용하고 있는 Mockito의 버전이 1.10.17, JUnit 버전이 4.7 이상이라면 <strong>@RunWith가 아닌 MockitoJUnit의 rule을 사용해서 Mockito annotation을 사용하는 field를 초기화 하자</strong></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://stackoverflow.com/questions/10806345/runwithmockitojunitrunner-class-vs-mockitoannotations-initmocksthis/10812752#10812752" target="_blank" rel="noopener">@RunWith(MockitoJUnitRunner.class) vs MockitoAnnotations.initMocks(this)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mockito-junit-rule&quot;&gt;&lt;a href=&quot;#Mockito-JUnit-rule&quot; class=&quot;headerlink&quot; title=&quot;Mockito JUnit rule&quot;&gt;&lt;/a&gt;Mockito JUnit rule&lt;/h1&gt;&lt;p&gt;Mockit
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://jongmin92.github.io/categories/Programming/Java/"/>
    
    
      <category term="Java" scheme="https://jongmin92.github.io/tags/Java/"/>
    
      <category term="Mockito" scheme="https://jongmin92.github.io/tags/Mockito/"/>
    
      <category term="TDD" scheme="https://jongmin92.github.io/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>Design Pattern - Adapter</title>
    <link href="https://jongmin92.github.io/2018/08/20/Java/design-pattern-adapter/"/>
    <id>https://jongmin92.github.io/2018/08/20/Java/design-pattern-adapter/</id>
    <published>2018-08-20T13:22:00.000Z</published>
    <updated>2018-08-20T13:30:12.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>해당 포스팅은 <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=4529127" target="_blank" rel="noopener">Java 언어로 배우는 디자인 패턴 입문</a> 책을 참고해 작성했습니다.<br>사용된 코드는 <a href="https://github.com/jongmin92/Design-Pattern" target="_blank" rel="noopener">jongmin92/Design-Pattern</a> repository 에서 확인할 수 있습니다.</p></blockquote><h1 id="adapter-패턴"><a href="#Adapter-패턴" class="headerlink" title="Adapter 패턴"></a>Adapter 패턴</h1><p>이미 제공되어 있는 것을 그대로 사용할 수 없을 때, 필요한 형태로 교환하고 사용하는 일이 자주 있습니다. <strong>‘이미 제공되어 있는 것’과 ‘필요한 것’ 사이(서로 다른 두 개)의 ‘차이’를 없애주는 디자인 패턴이 <code>Adapter 패턴</code> 입니다.</strong></p><p>Adapter 패턴은 Wrapper 패턴으로 불리기도 하며, 다음과 같은 두 가지 종류가 있습니다.</p><ul><li>클래스에 의한 Adapter 패턴 (상속을 사용한 Adapter 패턴)</li><li>인스턴스에 의한 Adapter 패턴 (위임을 사용한 Adapter 패턴)</li></ul><h2 id="예제-프로그램1-상속을-사용한-adapter-패턴"><a href="#예제-프로그램-1-상속을-사용한-Adapter-패턴" class="headerlink" title="예제 프로그램(1) - 상속을 사용한 Adapter 패턴"></a>예제 프로그램(1) - 상속을 사용한 Adapter 패턴</h2><p>만들 예제 프로그램은 주어진 문자열을 아래와 같이 표시하는 간단한 것입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Hello)</span><br><span class="line">*Hello*</span><br></pre></td></tr></table></figure><p>Banner 클래스에는 문자열을 괄호로 묶어서 표시하는 showWithParen 메소드와 문자열 전후에 *를 붙여 표시하는 showWithAster 메소드가 준비되어 있습니다. (이미 제공되어 있는 것)</p><p>Print 인터페이스에는 문자열을 느슨하게(괄호 사용) 표시하기 위한 printWeak 메소드와 문자열을 강하게 표시하기 위한 (* 표시를 앞뒤에 붙여 강조) printStrong 메소드가 선언되어 있습니다.</p><p>지금 하고 싶은 일은 Banner 클래스를 사용해서 Print 인터페이스를 충족시키는 클래스를 만드는 일입니다.</p><p>PrintBanner 클래스가 어댑터의 역할을 담당합니다. 이 클래스는 제공되어 있는 Banner 클래스를 <strong>상속</strong>해서, 필요로 하는 Print 인터페이스를 <strong>구현</strong>합니다.</p><p><img src="/images/post/2018-08-20/adapter-uml_1.png" alt=""></p><h3 id="banner-클래스"><a href="#Banner-클래스" class="headerlink" title="Banner 클래스"></a>Banner 클래스</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Banner</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.string = string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithParen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">'('</span> + string + <span class="string">')'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithAster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">'*'</span> + string + <span class="string">'*'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="print-인터페이스"><a href="#Print-인터페이스" class="headerlink" title="Print 인터페이스"></a>Print 인터페이스</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="printbanner-클래스"><a href="#PrintBanner-클래스" class="headerlink" title="PrintBanner 클래스"></a>PrintBanner 클래스</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner</span> <span class="keyword">extends</span> <span class="title">Banner</span> <span class="keyword">implements</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintBanner</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        showWithParen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        showWithAster();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main-클래스"><a href="#Main-클래스" class="headerlink" title="Main 클래스"></a>Main 클래스</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Print p = <span class="keyword">new</span> PrintBanner(<span class="string">"Hello"</span>);</span><br><span class="line">        p.printWeak();</span><br><span class="line">        p.printStrong();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main 클래스는 Print 인터페이스를 사용하고 있습니다. Banner 클래스나 showWithParen 메소드나 showWithAster 메소드는 Main 클래스 소스 코드 상에서는 완전히 감추어져 있습니다.</p><h2 id="예제-프로그램2-위임을-사용한-adapter-패턴"><a href="#예제-프로그램-2-위임을-사용한-Adapter-패턴" class="headerlink" title="예제 프로그램(2) - 위임을 사용한 Adapter 패턴"></a>예제 프로그램(2) - 위임을 사용한 Adapter 패턴</h2><p>Main 클래스, Banner 클래스, Print 인터페이스는 예제 프로그램(1)과 동일합니다.</p><p>PrintBanner 클래스는 banner 필드에서 Banner 클래스의 인스턴스를 가집니다. 이 인스턴스는 PrintBanner 클래스의 생성자에서 생성합니다.</p><p>이전 예와는 달리, 이번에는 필드를 경우해서 호출하고 있습니다. 즉 위임을 하고 있습니다.</p><p><img src="/images/post/2018-08-20/adapter-uml_2.png" alt=""></p><h3 id="printbanner-클래스"><a href="#PrintBanner-클래스-1" class="headerlink" title="PrintBanner 클래스"></a>PrintBanner 클래스</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner</span> <span class="keyword">implements</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Banner banner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintBanner</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.banner = <span class="keyword">new</span> Banner(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        banner.showWithParen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        banner.showWithAster();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="adapter-패턴의-구성요소"><a href="#Adapter-패턴의-구성요소" class="headerlink" title="Adapter 패턴의 구성요소"></a>Adapter 패턴의 구성요소</h2><ul><li><strong>Target(대상)의 역할</strong><br>지금 필요한 메소드를 결정합니다. 예제 프로그램에서 Print 인터페이스(상속의 경우)나 Print 클래스(위임의 경우)가 이 역할을 합니다.</li><li><strong>Client(의뢰자)의 역할</strong><br>Target 역할의 메소드를 사용해서 일을 합니다. 예제 프로그램에서 Main 클래스가 이 역할을 합니다.</li><li><strong>Adaptee(개조되는 쪽)의 역할</strong><br>Adaptee는 이미 준비되어 있는 메소드를 갖고 있는 역할입니다. Adaptee역의 메소드가 Target 역할의 메소드와 일치하면 다음 Adapter의 역할은 필요없습니다.</li><li><strong>Adapter의 역할</strong><br>Adapter 패턴의 주인공입니다. Adaptee 역할의 메소드를 사용해서 어떻게든 Target 역할을 만족시키기 위한 것이 Adapter 패턴의 목적이며, Adapter 역할의 임무입니다. 예제 프로그램에서는 PrintBanner 클래스가 Adapter의 역할을 합니다.</li></ul><h2 id="사고-넓히기"><a href="#사고-넓히기" class="headerlink" title="사고 넓히기"></a>사고 넓히기</h2><h3 id="어떤-경우에-사용할까"><a href="#어떤-경우에-사용할까" class="headerlink" title="어떤 경우에 사용할까?"></a>어떤 경우에 사용할까?</h3><p><strong>Adapter 패턴은 기존의 클래스를 개조해서 필요한 클래스를 만듭니다.</strong> 이 패턴으로 필요한 메소드를 빠르게 만들 수 있습니다.</p><p>이미 만들어진 클래스를 새로운 인터페이스(API)에 맞게 개조시킬 때 기존 클래스의 소스를 바꾸어서 ‘수정’하려고 합니다. 그러나 그렇게하면 테스트가 이미 끝난 기존의 클래스를 수정한 후에 다시 한 번 테스트 해야 합니다. Adapter 패턴은 기존의 클래스를 전혀 수정하지 않고 목적한 인터페이스(API)에 맞추려는 것입니다.</p><p>만약 버그가 발생해도 기존의 클래스(Adaptee의 역할)에는 버그가 없으므로 Adapter 역할의 클래스를 중점적으로 조사하면 되고, 프로그램 검사도 상당히 쉬워집니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;해당 포스팅은 &lt;a href=&quot;https://book.naver.com/bookdb/book_detail.nhn?bid=4529127&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 언어로 배우는 디자인 
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://jongmin92.github.io/categories/Programming/Java/"/>
    
    
      <category term="java" scheme="https://jongmin92.github.io/tags/java/"/>
    
      <category term="design pattern" scheme="https://jongmin92.github.io/tags/design-pattern/"/>
    
      <category term="adapter" scheme="https://jongmin92.github.io/tags/adapter/"/>
    
  </entry>
  
  <entry>
    <title>&lt;웹 프로그래머를 위한 서블릿 컨테이너의 이해&gt; 리뷰</title>
    <link href="https://jongmin92.github.io/2018/08/18/Book/servlet_container_review/"/>
    <id>https://jongmin92.github.io/2018/08/18/Book/servlet_container_review/</id>
    <published>2018-08-18T04:00:00.000Z</published>
    <updated>2018-08-18T04:19:07.827Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/post/2018-08-18_2/cover.jpg" alt=""><br><a href="http://www.hanbit.co.kr/store/books/look.php?p_code=E1064947038" target="_blank" rel="noopener">한빛미디어 - 웹 프로그래머를 위한 서블릿 컨테이너의 이해</a></p><p>스프링을 이용해 개발하고 있지만 스프링이 구동되는 서블릿 컨테이너에 대한 이해가 부족해 읽게 되었다. (어떻게 돌아가고 있는지 궁금했다…)</p><p>책의 구성은 <strong>서블릿 컨테이너를 학습해야 하는 이유</strong>를 시작으로 <strong>HTTP 프로토콜에 대한 이해</strong> 그리고 <strong>서블릿의 이해</strong>로 이어진다.<br>그 후에는 실제 <strong>서블릿 컨테이너에서 HTTP 프로토콜을 어떻게 분석해 서블릿에 전달</strong>해주는지, <strong>스레드 풀을 이용해 동시에 들어오는 request 들을 어떻게 처리</strong>하는지에 대한 내용을 다루고 있다.</p><p>도입 부분(서블릿 컨테이너를 학습해야 하는 이유)에 다음과 같은 이야기가 있다.</p><blockquote><p>특히 성능과 관련된 문제가 발생했을 때, 웹 기반 시스템의 하위 레벨 영역인 웹 애플리케이션 서버가 담당하는 부분을 모르고서는 근본적인 원인 규명 자체가 불가능합니다. 웹 애플리케이션 서버의 내부구조와 동작 원리를 이해하지 못하는지가 웹 프로그램의 고성능, 고가용성에 대한 요구를 충족시킬 수 있는지 결정한다고 할 수 있습니다.</p></blockquote><p>위의 말에 전적으로 동의한다. 스프링을 이용해 웹 애플리케이션을 만들기 위해 스프링을 공부하고 이해하듯, 스프링이 실행되는 서블릿 컨테이너에 대한 공부와 이해도 필요하다. 아마 나와 같이 서블릿을 이용한 개발 경험 없이, 스프링을 시작했다면 이 책을 읽어보기를 더욱 추천하고 싶다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/post/2018-08-18_2/cover.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a href=&quot;http://www.hanbit.co.kr/store/books/look.php?p_code=E1064947038&quot; targe
      
    
    </summary>
    
      <category term="Book" scheme="https://jongmin92.github.io/categories/Book/"/>
    
    
      <category term="book" scheme="https://jongmin92.github.io/tags/book/"/>
    
      <category term="java" scheme="https://jongmin92.github.io/tags/java/"/>
    
      <category term="review" scheme="https://jongmin92.github.io/tags/review/"/>
    
      <category term="servlet container" scheme="https://jongmin92.github.io/tags/servlet-container/"/>
    
  </entry>
  
  <entry>
    <title>Design Pattern - Iterator</title>
    <link href="https://jongmin92.github.io/2018/08/18/Java/design-pattern-iterator/"/>
    <id>https://jongmin92.github.io/2018/08/18/Java/design-pattern-iterator/</id>
    <published>2018-08-18T03:20:00.000Z</published>
    <updated>2018-08-20T13:30:27.330Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>해당 포스팅은 <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=4529127" target="_blank" rel="noopener">Java 언어로 배우는 디자인 패턴 입문</a> 책을 참고해 작성했습니다.<br>사용된 코드는 <a href="https://github.com/jongmin92/Design-Pattern" target="_blank" rel="noopener">jongmin92/Design-Pattern</a> repository 에서 확인할 수 있습니다.</p></blockquote><h1 id="iterator-패턴"><a href="#Iterator-패턴" class="headerlink" title="Iterator 패턴"></a>Iterator 패턴</h1><p>Java 언어에서 배열 arr의 모든 요소를 표시하기 위해서는 다음과 같이 for문을 사용합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for문의 i++에서 i를 하나씩 증가시키면서 배열 arr의 요소 전체를 처음부터 차례대로 검색하게 됩니다. 여기서 사용되고 있는 변수 i의 기능을 추상화해서 일반화한 것을 디자인 패턴에서는 <code>Iterator 패턴</code>이라고 합니다.</p><p><strong><code>Iterator 패턴</code>이란, 무엇인가 많이 모여있는 것들을 순서대로 지정하면서 전체를 검색하는 처리를 실행하기 위한 것입니다.</strong> Iterator는 무엇인가를 ‘반복한다’라는 의미이며, 반복자라고도 합니다.</p><h2 id="예제-프로그램"><a href="#예제-프로그램" class="headerlink" title="예제 프로그램"></a>예제 프로그램</h2><p>Iterator 패턴을 사용해 책장에 꽂혀 있는 책들을 하나씩 검색해 책 이름을 출력해보는 예제 프로그램을 작성해 보겠습니다.</p><p><img src="/images/post/2018-08-18/iterator-uml.png" alt=""></p><h3 id="aggregate-인터페이스"><a href="#Aggregate-인터페이스" class="headerlink" title="Aggregate 인터페이스"></a>Aggregate 인터페이스</h3><p><strong><code>Aggregate</code> 인터페이스는 요소들이 나열되어 있는 ‘집합체’를 나타냅니다.</strong> 이 인터페이스를 구현하고 있는 클래스는 배열과 같이 무엇인가가 많이 모여 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Aggregate 인터페이스에 선언되어 있는 메소드는 iterator 메소드 하나뿐입니다. 이 메소드는 집합체에 대응하는 Iterator를 1개 작성하기 위한 것입니다.</p><h3 id="iterator-인터페이스"><a href="#Iterator-인터페이스" class="headerlink" title="Iterator 인터페이스"></a>Iterator 인터페이스</h3><p><strong><code>Iterator</code> 인터페이스는 요소를 하나씩 나열하면서 루프 변수와 같은 역할을 수행합니다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">Iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>hasNext</strong> 메소드는  다음 요소가 존재하는지를 조사하기 위한 메소드입니다. 다음 요소가 존재하면 true를 반환하고, 다음 요소가 존재하지 않는 마지막 요소라면 false를 반환합니다. 즉, hasNext는 루프의 종료 조건으로 사용됩니다.</p><p><strong>next</strong> 메소드는 집합체의 요소를 1개 반환합니다. 또한 next 메소드를 호출했을 때 다음 요소를 반환하도록 내부 상태를 다음으로 진행시켜 두는 역할도 함께합니다.</p><h3 id="book-클래스"><a href="#Book-클래스" class="headerlink" title="Book 클래스"></a>Book 클래스</h3><p><code>Book</code> 클래스는 책을 나타내는 클래스입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bookshelf-클래스"><a href="#BookShelf-클래스" class="headerlink" title="BookShelf 클래스"></a>BookShelf 클래스</h3><p><code>BookShelf</code> 클래스는 책장을 나타내는 클래스입니다. 이 클래스를 <strong>집합체로 다루기 위해 Aggregate 인터페이스를 구현합니다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Book[] books;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookShelf</span><span class="params">(<span class="keyword">int</span> maxsize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.books = <span class="keyword">new</span> Book[maxsize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getBookAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> books[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.books[last] = book;</span><br><span class="line">        last++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BookShelfIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iterator 메소드는 BookShelf 클래스에 대응하는 Iterator로서, BookShelfIterator라는 클래스의 인스턴스를 생성해서 그것을 반환합니다.</p><h3 id="bookshelfiterator-클래스"><a href="#BookShelfIterator-클래스" class="headerlink" title="BookShelfIterator 클래스"></a>BookShelfIterator 클래스</h3><p><code>BookshelfIterator</code> 를 Iterator로서 다루기 위해 Iterator 인터페이스를 구현합니다. bookShelf 필드는 BookShelfIterator가 검색할 책장이고, index 필드는 현재 가리키는 책을 가리키는 첨자입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelfIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookShelf bookShelf;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookShelfIterator</span><span class="params">(BookShelf bookShelf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookShelf = bookShelf;</span><br><span class="line">        <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; bookShelf.getLength();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Book book = bookShelf.getBookAt(index);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main-클래스"><a href="#Main-클래스" class="headerlink" title="Main 클래스"></a>Main 클래스</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BookShelf bookShelf = <span class="keyword">new</span> BookShelf(<span class="number">4</span>);</span><br><span class="line">        bookShelf.appendBook(<span class="keyword">new</span> Book(<span class="string">"Effective Java"</span>));</span><br><span class="line">        bookShelf.appendBook(<span class="keyword">new</span> Book(<span class="string">"Head First Java"</span>));</span><br><span class="line">        bookShelf.appendBook(<span class="keyword">new</span> Book(<span class="string">"Thinking In Java"</span>));</span><br><span class="line">        bookShelf.appendBook(<span class="keyword">new</span> Book(<span class="string">"Agile Java"</span>));</span><br><span class="line"></span><br><span class="line">        Iterator it = bookShelf.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Book book = (Book) it.next();</span><br><span class="line">            System.out.println(book.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실행결과</span></span><br><span class="line">Effective Java</span><br><span class="line">Head First Java</span><br><span class="line">Thinking In Java</span><br><span class="line">Agile Java</span><br></pre></td></tr></table></figure><h2 id="iterator-패턴의-구성요소"><a href="#Iterator-패턴의-구성요소" class="headerlink" title="Iterator 패턴의 구성요소"></a>Iterator 패턴의 구성요소</h2><ul><li><p><strong>Iterator(반복자)의 역할</strong><br>요소를 순서대로 검색해가는 인터페이스(API)를 결정 (hasNext, next)</p></li><li><p><strong>ConcreteIterator(구체적인 반복자)의 역할</strong><br>Iterator가 결정한 인터페이스(API)를 실제로 구현</p></li><li><p><strong>Aggregate(집합체)의 역할</strong><br>Iterator 역할을 만들어내는 인터페이스(API)를 결정</p></li><li><p><strong>ConcreteAggregate(구체적인 집합체)의 역할</strong><br>Aggregate 역할이 결정한 인터페이스(API)를 실제로 구현</p></li></ul><h2 id="사고-넓히기"><a href="#사고-넓히기" class="headerlink" title="사고 넓히기"></a>사고 넓히기</h2><h3 id="구현에-상관-없이-iterator를-사용할-수-있다"><a href="#구현에-상관-없이-Iterator를-사용할-수-있다" class="headerlink" title="구현에 상관 없이 Iterator를 사용할 수 있다."></a>구현에 상관 없이 Iterator를 사용할 수 있다.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">Book book = (Book) it.next();</span><br><span class="line">System.out.println(book.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 사용되고 있는 것은 hasNext와 next라는 Iterator의 메소드 뿐입니다. BooShelf의 구현에서 사용되고 있는 메소드는 호출되고 있지 않습니다. 결국 위 코드의 <strong>while 루프는 BookShelf의 구현에 의존하지 않습니다.</strong></p><p>그렇기 때문에 현재 배열을 사용해 구현하고 있는 BookShelf를 List를 사용하도록 수정해도, 위의 while 루프는 전혀 <strong>변경하지 않아도 동작</strong>합니다.</p><h3 id="aggregate와-iterator의-대응"><a href="#Aggregate와-Iterator의-대응" class="headerlink" title="Aggregate와 Iterator의 대응"></a>Aggregate와 Iterator의 대응</h3><p>BookShelfIterator는 BookShelf가 어떻게 구현되고 있는지 알기 때문에, ‘다음 책’을 얻기 위해 getBookAt 메소드를 호출할 수 있었습니다.</p><p>만약 BookShelf의 구현을 전부 변경하고, getBookAt 메소드라는 인터페이스(API)도 변경된다면 BookShelfIterator의 수정이 필요하게 됩니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;해당 포스팅은 &lt;a href=&quot;https://book.naver.com/bookdb/book_detail.nhn?bid=4529127&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 언어로 배우는 디자인 
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://jongmin92.github.io/categories/Programming/Java/"/>
    
    
      <category term="java" scheme="https://jongmin92.github.io/tags/java/"/>
    
      <category term="design pattern" scheme="https://jongmin92.github.io/tags/design-pattern/"/>
    
      <category term="iterator" scheme="https://jongmin92.github.io/tags/iterator/"/>
    
  </entry>
  
  <entry>
    <title>소나큐브</title>
    <link href="https://jongmin92.github.io/2018/08/12/Tool/sonarqube/"/>
    <id>https://jongmin92.github.io/2018/08/12/Tool/sonarqube/</id>
    <published>2018-08-12T08:30:00.000Z</published>
    <updated>2018-08-12T08:50:21.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>해당 포스팅은 <strong>‘<a href="http://www.hanbit.co.kr/store/books/look.php?p_code=B8716214772" target="_blank" rel="noopener">자바 필수 프로젝트 유틸리티</a>‘</strong> 책의 <code>8.3 소나큐브</code> 부분을 참고해 작성했습니다.</p></blockquote><h1 id="소나큐브"><a href="#소나큐브" class="headerlink" title="소나큐브"></a>소나큐브</h1><p>소나큐브를 사용해서 작성한 코드를 정적 분석하고 작성한 테스트로 얼마나 검증했는지 측정할 수 있다.</p><p>소나큐브를 로컬 환경에 설치하고 젠킨스와 소나큐브를 연결해서 소나큐브의 기본 퀄리티 게이트(Quality Gate)를 실행시켜보자. 퀄리티 게이트는 조직의 모든 소스가 통과해야만 하는 소스의 품질을 정의해둔 것으로 소스의 품질을 보증하는 수단으로 이용된다.</p><h2 id="기능과-특징"><a href="#기능과-특징" class="headerlink" title="기능과 특징"></a>기능과 특징</h2><p><strong>소나큐브의 주요 기능</strong>은 아래와 같다.</p><ul><li>복잡도 확인</li><li>코드 중복 검출</li><li>코딩 규칙 확인</li><li>잠재적 버그 검출</li><li>단위 테스트</li><li>커버리지</li></ul><p>소나큐브 자체에서 지원하는 심플한 UI를 이용해 프로젝트의 소스 코드가 얼마나 개선되고 있는지를 직관적으로 확인할 수 있다. <strong>소나큐브의 특징</strong>은 다음과 같다.</p><ul><li>서버는 크게 웹 서버, 검색 서버, 연산 서버로 구성된다.</li><li>데이터베이스는 소나큐브 자체의 설정과 각 프로젝트의 정보가 저장된다.</li><li>플러그인을 추가할 수 있다.</li><li>소나큐브 스캐너(SonarQube Scanner)로 코드를 분석한다.</li></ul><h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><p>brew를 이용해 설치 후 실행한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew install sonarqube</span><br><span class="line">$ brew services start sonarqube</span><br></pre></td></tr></table></figure><p>brew를 이용해 설치하게 되면 다음과 <strong>/usr/local/Cellar/sonarqube/7.2.1/libexec/conf</strong> 디렉터리에 설치된다. 각 디렉터리의 역할은 다음과 같다.</p><ul><li>bin : 운영체제별 실행파일이 있다.</li><li>conf : 소나큐브의 설정 팡리이 있다. 설정 파일에서 데이터베이스 연결과 웹 서버의 설정 등을 한다.</li><li>data : 기본 데이터베이스인 H2 데이터베이스를 사용할 때 데이터가 저장되는 곳이다. 테스트 목적이 아니라면, 실제 운영할 때는 다른 데이터베이스를 사용해야 한다.</li><li>elasticsearch : 루씬 기반의 검색 엔진인 elasticsearch가 포함되어 있다.</li><li>extensions : jdbc-driver와 플러그인이 포함된다.</li><li>lib : 실제 애플리케이션 바이너리가 포함되어 있다.</li><li>logs : 각 로그가 출력되는 디렉터리이다. 설정 파일에서 변경 가능하다.</li><li>temp : 서버 실행 시에 필요한 임시 파일이 저장된다. 실행 중에 삭제하면 안된다.</li><li>web : UI에 필요한 이미지와 CSS, JS 파일이 있다.</li></ul><p>실행 후 <a href="http://localhost:9000에" target="_blank" rel="noopener">http://localhost:9000에</a> 접속하면 다음과 같은 화면을 볼 수 있다.<br><img src="/images/post/2018-08-12/sonar_1.png" alt=""></p><p>관리자로 접속해서 젠킨스와 연결할 사용자를 만들어 보자. 오른쪽 상단 위에 있는 <strong>‘Log in’</strong> 을 클릭한 후 초기 ID/PW인 admin/admin을 입력해서 로그인한다.<br><img src="/images/post/2018-08-12/sonar_2.png" alt=""></p><p>로그인이 완료되면 튜토리얼 페이지가 나온다. 우측 상단의 <strong>‘Skip this tutorial’</strong> 을 클릭해서 스킵한다.<br><img src="/images/post/2018-08-12/sonar_3.png" alt=""></p><p>아래와 같이 프로젝트 페이지를 확인할 수 있다.<br><img src="/images/post/2018-08-12/sonar_4.png" alt=""></p><h2 id="젠킨스-사용자-생성"><a href="#젠킨스-사용자-생성" class="headerlink" title="젠킨스 사용자 생성"></a>젠킨스 사용자 생성</h2><p>젠킨스에서 소나큐브에 접속할 때 사용할 사용자를 생성한다.</p><p>화면 상단의 메뉴에서 <strong>‘Administration’ -&gt; ‘Security’ -&gt; ‘Users’ -&gt; ‘Create User’</strong> 를 클릭해서 사용자 생성 창을 출력한다.<br><img src="/images/post/2018-08-12/sonar_5.png" alt=""></p><p>jenkins라는 이름으로 사용자를 생성한다.<br><img src="/images/post/2018-08-12/sonar_6.png" alt=""></p><p>젠킨스에서 접속할 때 사용할 토큰을 생성한다. 조금전 생성한 jenkins 유저의 <strong>‘Token’</strong> 을 클릭한다.<br><img src="/images/post/2018-08-12/sonar_7.png" alt=""></p><p><strong>‘Enter Token Name’</strong> 에 적당한 이름을 넣고 <strong>‘Generate’</strong> 버튼을 눌러서 생성한다.<br><img src="/images/post/2018-08-12/sonar_8.png" alt=""></p><p>생성된 토큰 앞에 있는 <strong>‘Copy’</strong> 버튼을 눌러 젠킨스에서 사용할 키를 저장한다.<br><img src="/images/post/2018-08-12/sonar_9.png" alt=""></p><h2 id="소나큐브-스캐너-설정"><a href="#소나큐브-스캐너-설정" class="headerlink" title="소나큐브 스캐너 설정"></a>소나큐브 스캐너 설정</h2><p>이번에는 젠킨스의 빌드 과정에서 소나큐브를 연동한다.</p><p><strong>‘Jenkins 관리’ -&gt; ‘플러그인 관리’에서 ‘SonarQube Scanner’를 설치</strong> 한다.<br><img src="/images/post/2018-08-12/sonar_10.png" alt=""></p><p><strong>‘Jenkins 관리’ -&gt; ‘시스템 설정’</strong> 으로 이동하면, <strong>‘SonarQube servers’</strong> 라는 설정이 추가된것을 확인할 수 있다. 만약 플러그인을 설치했는데도 해당 설정이 표시되지 않는다면 젠킨스 서버를 재실행해본다.</p><p><strong>‘Add SonarQube’</strong> 를 클릭한다.<br><img src="/images/post/2018-08-12/sonar_11.png" alt=""></p><p><strong>‘고급’</strong> 버튼을 클릭한 후 시스템 환경 변수를 사용하도록 각각 다음과 같이 설정한다.</p><ul><li>Environment variables : 체크 박스 선택</li><li>Name : SonarQube-Local 입력 (스페이스와 한글을 입력하지 않는다.)</li><li>Server URL : 소나큐브의 URL 입력(여기서는 default인 <a href="http://localhost:9000" target="_blank" rel="noopener">http://localhost:9000</a>)</li><li>Server authentication token : 소나큐브에서 생성한 토큰 입력</li><li>Additional analysis properties :<br>sonar.sources=src sonar.java.binaries=target/classes, target/test-classes<br><img src="/images/post/2018-08-12/sonar_12.png" alt=""></li></ul><p><strong>‘저장’</strong> 을 클릭해서 저장한다.</p><p>소나큐브 스캐너를 추가하는 작업을 진행한다. <strong>‘Jenkins 관리’ -&gt; ‘Global Tool Configuration’</strong> 을 클릭한다.<br><img src="/images/post/2018-08-12/sonar_13.png" alt=""></p><p><strong>‘SonarQube Scanner for MSBuild’와 ‘SonarQube Scanner’</strong> 아래의 버튼을 클릭해서 각각 스캐너를 추가한다.<br><img src="/images/post/2018-08-12/sonar_14.png" alt=""></p><p>‘Name’에 적당한 이름을 넣고 <strong>‘Install automatically’</strong> 가 체크되어 있는지 확인 후 저장한다.<br><img src="/images/post/2018-08-12/sonar_15.png" alt=""></p><p><img src="/images/post/2018-08-12/sonar_16.png" alt=""></p><p>새로운 잡을 생성해서 테스트 해보자.</p><ol><li><p>젠킨스 메인 페이지에서 ‘새로운 Item’을 클릭하고 잡 이름에 ‘SonarQubeTset’를 입력하고 ‘Freestyle project’를 선택 후 저장 버튼을 클릭한다.</p></li><li><p>소스 코드 관리 : 테스트 프로젝트의 깃허브 주소를 넣는다. (여기서는 ‘<a href="http://www.hanbit.co.kr/store/books/look.php?p_code=B8716214772" target="_blank" rel="noopener">자바 필수 프로젝트 유틸리티</a>‘ 책에서 제공한 ‘<a href="https://github.com/jongmin92/spring-mvc-example" target="_blank" rel="noopener">spring-mvc-example</a>‘ 프로젝트를 fork해 사용했다.)</p></li><li><p>Credentials : 저장되어 있는 자격증명에서 선택한다.</p></li><li><p>빌드 환경에서 ‘Prepare SonarQube Scanner environment’를 선택한다. (이번 테스트에서는 필요하지는 않지만, ‘빌드 환경’에서 호나경 변수를 사용할 수 있게 하려고 체크하는 것이다.)</p></li><li><p>Build : ‘Invoke top-level Maven targets’를 선택한다.</p></li><li><p>Goals : ‘clean install’을 입력한다. (다른 골을 추가해도 된다.)</p></li><li><p>다시 Build의 ‘Add build step’을 클릭해서 ‘Execute SonarQube Scaner’를 추가한 후 ‘Analysis properties’에 아래의 정보를 입력한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sonar.projectKey=spring-mvc-example</span><br><span class="line">sonar.projectName=spring-mvc-example</span><br><span class="line">sonar.projectVersion=1.0.0</span><br></pre></td></tr></table></figure><p>이 테스트에서는 고정값으로 입력했지만 매개변수로 처리하거나 환경 변수에서 치환하는 방법도 많이 사용한다.</p></li><li><p>‘저장’ 버튼을 클릭해서 잡 대시보드로 이동한다.</p></li></ol><p>소나큐브의 아이콘이 추가된것을 확인할 수 있다.<br><img src="/images/post/2018-08-12/sonar_17.png" alt=""></p><h2 id="소나큐브-빌드"><a href="#소나큐브-빌드" class="headerlink" title="소나큐브 빌드"></a>소나큐브 빌드</h2><p><strong>‘Build Now’</strong> 를 클릭해서 빌드한다. 정상 종료되면 <strong>‘SonarQube Quality Gate’</strong> 가 표시되고 실행 결과를 알려준다.</p><p>화면에 표시되는 ‘SonarQube’ 링크나 ‘OK’를 클릭하면 소나큐브의 대시보드로 이동한다.<br><img src="/images/post/2018-08-12/sonar_18.png" alt=""></p><p><img src="/images/post/2018-08-12/sonar_19.png" alt=""></p><p>상단의 메뉴에서 ‘Issues’, ‘Code’를 통해 각 결과를 확인할 수 있다.<br><img src="/images/post/2018-08-12/sonar_20.png" alt=""></p><p><img src="/images/post/2018-08-12/sonar_21.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;해당 포스팅은 &lt;strong&gt;‘&lt;a href=&quot;http://www.hanbit.co.kr/store/books/look.php?p_code=B8716214772&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;자바
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Tool" scheme="https://jongmin92.github.io/categories/Programming/Tool/"/>
    
    
      <category term="jenkins" scheme="https://jongmin92.github.io/tags/jenkins/"/>
    
      <category term="ci &amp; cd" scheme="https://jongmin92.github.io/tags/ci-cd/"/>
    
      <category term="sonarqube" scheme="https://jongmin92.github.io/tags/sonarqube/"/>
    
  </entry>
  
  <entry>
    <title>젠킨스</title>
    <link href="https://jongmin92.github.io/2018/08/09/Tool/jenkins/"/>
    <id>https://jongmin92.github.io/2018/08/09/Tool/jenkins/</id>
    <published>2018-08-08T16:50:00.000Z</published>
    <updated>2018-08-12T08:31:15.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="젠킨스"><a href="#젠킨스" class="headerlink" title="젠킨스"></a>젠킨스</h1><p><strong><code>젠킨스</code></strong> 는 자바로 작성된 오픈 소스 소트트웨어로 <strong>지속적 통합</strong>(Continuous Integration, <strong>CI</strong>)과 <strong>지속적 배포</strong>(Continuous Delivery, <strong>CD</strong>)를 제공한다.</p><p>웹 애플리케이션 형태로 제공되고 있어서 어떠한 환경에서도 손쉽게 설치할 수 있으며 도커를 사용해 설치할 수도 있다. 또한 천 개 이상의 플러그인으로 다양한 시스템과 연동할 수 있다.</p><p>젠킨스의 주요 기능은 다음과 같다.</p><ul><li>형상관리 도구와의 연동</li><li>소스 코드 체크아웃</li><li>웹 인터페이스</li><li>테스트 보고서 생성</li><li>빌드 및 테스트 자동화</li><li>실행 결과 통보</li><li>코드 품질 감시</li><li>다양한 인증 기반과 결합한 인증 및 권한 관리</li><li>배포 관리 자동화</li><li>분산 빌드(마스터 슬레이브)</li><li>그루비 스크립트를 이용한 자유로운 잡 스케줄링</li></ul><p>젠킨스는 개발자가 소스코드를 추가, 수정한 뒤 형상관리 도구에 저장하면 자동으로 읽어 빌드 및 테스트를 실행한다.</p><h2 id="젠킨스-설치"><a href="#젠킨스-설치" class="headerlink" title="젠킨스 설치"></a>젠킨스 설치</h2><p>젠킨스를 사용하려면 JDK와 메이븐이 필요하다.</p><p>macOS에서 brew를 이용해 쉽게 설치가 가능하다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install jenkins</span><br></pre></td></tr></table></figure><p>추후 필요하다면 다음과 같이 삭제할 수도 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew remove jenkins</span><br></pre></td></tr></table></figure><p>설치 후 다음과 같이 젠킨스를 백그라운드 서비스로 구동 및 중지가 가능하다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew services start jenkins</span><br><span class="line">$ brew services stop jenkins</span><br></pre></td></tr></table></figure><p>젠킨스를 실행 후 웹사이트에 접속한다. <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br><img src="/images/post/2018-08-09/set_up_1.png" alt=""></p><p>처음 접속 시 Administrator password를 입력하게 되어 있는데 아래의 경로에 있는 파일에서 키를 확인해 입력한다.</p><p><code>/Users/{사용자 계정}/.jenkins/secrets/initialAdminPassword</code></p><p><img src="/images/post/2018-08-09/set_up_2.png" alt=""><br>젠킨스를 어떻게 설치할지 결정할 수 있다. ‘Install suggested plugins’를 선택하면 젠킨스에서 추천하는 플러그인들이 같이 설치되고, ‘Select plugins to install’을 선택하면 필요한 플러그인을 선택하여 설치할 수 있다.</p><p><img src="/images/post/2018-08-09/set_up_3.png" alt=""><br>필요한 플러그인들을 자동으로 설치하기 시작한다.</p><p><img src="/images/post/2018-08-09/set_up_4.png" alt=""><br>설치가 끝나면 관리자 정보 입력 화면이 나온다. 정보를 입력한 후 ‘Save and Finish’ 버튼을 클릭한다.</p><p><img src="/images/post/2018-08-09/set_up_5.png" alt=""><br><img src="/images/post/2018-08-09/set_up_6.png" alt=""></p><h2 id="빌드-잡job-생성하기"><a href="#빌드-잡-job-생성하기" class="headerlink" title="빌드 잡(job) 생성하기"></a>빌드 잡(job) 생성하기</h2><ol><li>좌측 메뉴 상단에 있는 ‘새로운 Item’을 클릭한다. ‘Enter an item name’에 적당한 이름을 넣고 아래의 템플릿 중 ‘Freestyle project’를 선택한 후 ‘OK’ 버튼을 클릭한다. (Freestyle project는 거의 모든 젠킨스의 설정을 자유롭게 설정할 수 있다.)<br> <img src="/images/post/2018-08-09/set_up_7.png" alt=""></li><li>Github에 테스트를 위해 간단하게 만들어 놓은 프로젝트를 가져와 빌드를 테스트 한다.<br> <img src="/images/post/2018-08-09/set_up_8.png" alt=""></li><li>Github에서 프로젝트를 가져오기 위해서는 자격 증명을 추가해야 한다. ssh-key를 등록하거나 Github의 계정을 입력해야 한다.<br> <img src="/images/post/2018-08-09/set_up_9.png" alt=""></li><li>Credentials 선택 박스에서 조금 전 추가한 계정을 선택한 후 ‘저장’ 버튼을 클릭한다.<br> <img src="/images/post/2018-08-09/set_up_10.png" alt=""></li><li>‘Build Now’를 클릭해 빌드를 진행한다.<br> <img src="/images/post/2018-08-09/set_up_11.png" alt=""></li><li>‘Console Output’을 누르면 빌드가 성공한 것을 확인할 수 있다.<br> <img src="/images/post/2018-08-09/set_up_12.png" alt=""></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;젠킨스&quot;&gt;&lt;a href=&quot;#젠킨스&quot; class=&quot;headerlink&quot; title=&quot;젠킨스&quot;&gt;&lt;/a&gt;젠킨스&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;젠킨스&lt;/code&gt;&lt;/strong&gt; 는 자바로 작성된 오픈 소스 소트트웨어로 &lt;strong&gt;지
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Tool" scheme="https://jongmin92.github.io/categories/Programming/Tool/"/>
    
    
      <category term="jenkins" scheme="https://jongmin92.github.io/tags/jenkins/"/>
    
      <category term="ci &amp; cd" scheme="https://jongmin92.github.io/tags/ci-cd/"/>
    
  </entry>
  
  <entry>
    <title>그레이들 기초</title>
    <link href="https://jongmin92.github.io/2018/08/08/Tool/gradle_basic/"/>
    <id>https://jongmin92.github.io/2018/08/08/Tool/gradle_basic/</id>
    <published>2018-08-07T16:25:00.000Z</published>
    <updated>2018-08-08T16:49:27.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="그레이들"><a href="#그레이들" class="headerlink" title="그레이들"></a>그레이들</h1><h2 id="그루비와-그레이들"><a href="#그루비와-그레이들" class="headerlink" title="그루비와 그레이들"></a>그루비와 그레이들</h2><p><strong><code>그루비</code></strong>는 자바 가상머신에서 동작하는 오픈 소스 스크립트 언어이다. 그루비는 자바 문법을 더욱 쉽게 쓰기 위해 스크립트 언어와 비슷한 문법으로 되어 있어서, 대부분의 자바 프로그래머는 자바 코드를 작성하는 느낌으로 그루비를 작성할 수 있다. 동적 언어이며 자바와 달리 작성한 스크립트를 컴파일할 필요 없이 직접 실행할 수도 있다.</p><p>또한, 일부 자바 프레임워크에서는 그루비를 지원한다. 대표적인 스프링 프레임워크에서도 그루비를 이용할 수 있다.</p><p>이처럼 자바와 거의 같고, 스크립트 언어처럼 부담 없이 작성해서 바로 실행할 수 있는 특징을 고려하면, 그루비를 사용해서 자바 빌드 도구를 만들려는 생각은 자연스럽다.</p><p>그루비의 이러한 이점을 최대한 활용해서 개발한 빌드 도구가 <strong><code>그레이들</code></strong>이다.</p><h2 id="그레이들이란"><a href="#그레이들이란" class="headerlink" title="그레이들이란"></a>그레이들이란</h2><p><strong>그레이들은 그루비를 사용한 빌드 도구이다.</strong> 메이븐은 XML을 이용하여 빌드 정보를 기술했는데, 그레이들은 그루비를 이용해 빌드 정보를 기술하기 한다. 때문에 자바 프로그래머가 좀 더 쉽게 다룰 수 있다.</p><p>그레이들의 특징은 다음과 같다.</p><ul><li><strong>유연한 언어로 기술</strong><br>그루비라는 프로그래밍 언어를 사용해서 기술하기 때문에 유연하게 각종 처리를 수행할 수 있다. 또한 기술하는 내용을 분할하거나 구조화하는 것도 간단하다.</li><li><strong>태스크로 처리</strong><br>그레이들은 ‘태스크’라는 개념을 이용해 프로그램을 작성한다. 다양한 용도별로 태스크를 만들어서 그 안에 처리를 기술한다.</li><li><strong>자바/그루비/스칼라 기본 지원 + 알파</strong><br>그레이들은 자바 가상 머신에서 동작하는 언어를 중심으로 지원한다. (별도의 네이티브 코드 플러그인을 사용하면 C/C++ 등, 다른 언어에도 대응할 수 있다.)</li><li><strong>각종 도구와 통합</strong><br>여러 도구들(앤트, 아파치 아이비 등)과 통합되어 처리를 실행할 수 있다. 또한, 메이븐의 pom.xml을 그레이들용으로 변환하는 도구도 있다.</li><li><strong>메이븐 중앙 저장소 대응</strong><br>그레이들에서는 메이븐 중앙 저장소를 지원하기 때문에, 중앙 저장소에 있는 라이브러리 모두 그대로 이용 가능하다.</li></ul><h2 id="그레이들-사용하기"><a href="#그레이들-사용하기" class="headerlink" title="그레이들 사용하기"></a>그레이들 사용하기</h2><p>그레이들 소프트웨어에는 그루비가 포함되어 있기 때문에, 단지 그레이들을 사용하는 용도라면 그루비를 설치할 필요는 없다. (그레이들을 설치하는 것만으로는 그루비 언어를 이용해서 프로그래밍할 수는 없다.)</p><h2 id="그레이들-프로젝트-생성"><a href="#그레이들-프로젝트-생성" class="headerlink" title="그레이들 프로젝트 생성"></a>그레이들 프로젝트 생성</h2><p>그레이들 명령어를 사용해 프로젝트를 생성할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir gradle-app</span><br><span class="line"><span class="built_in">cd</span> gradle-app</span><br><span class="line">gradle init --<span class="built_in">type</span> java-library</span><br></pre></td></tr></table></figure><p><strong>gradle init</strong></p><p>그레이들 명령어는 gradle OO 형태로 실행한다. 위에서 프로젝트를 생성하며 사용한 init은 그레이들에서 <strong><code>&#39;태스크&#39;</code></strong>라고 부른다. 이 init은 프로젝트의 기본적은 파일과 폴더를 생성한다.</p><p>–type은 생성할 프로젝트의 타입을 지정하는 옵션인데, java-library는 자바 프로젝트임을 나타낸다. 지정한 언어의 샘플 코드를 생성한다. 이 옵션을 생략하면 그레이들 프로젝트의 기본적인 파일들만 생성된다.</p><blockquote><p><strong>그레이들 실행과 태스크</strong></p><p>그레이들에서는 다양한 처리를 위해 ‘태스크’를 이용한다. 태스크란, 실행할 처리를 모아놓은 단위로 그레이들에서 처음부터 포함된 것도 있고, 프로그래머가 작성할 수도 있다. 이 태스크를 실행하는 것이 그레이들에서 빌드를 관리하는 기본적인 방법이다. 프로젝트를 컴파일하거나, 실행하는 모든 처리에 태스크를 이용한다.</p></blockquote><p>생성된 gradle-app 폴더 내부의 구조를 살펴보자.</p><ul><li>.gradle 폴더 : 태스크로 생성된 파일 등을 보존한다.</li><li>gradle 폴더 : 기본값으로는 그레이들 환경을 모아놓은 wrapper 파일이라고 하는 파일들이 들어 있다.</li><li>src 폴더 : 소스 코드 관련 파일을 이곳에 작성한다.</li><li>build.gradle : 그레이들 빌드 파일, 이곳에 프로젝트의 빌드 내용을 기술한다.</li><li>settings.gradle : 빌드 설정 정보를 기술한 파일. 빌드를 실행하기 전에 읽히기 때문에, 필요한 라이브러리를 읽는 등의 기술을 할 수 있다.</li></ul><p>이번에는 생성된 파일의 코드를 확인해보자.</p><p><strong>build.gradle</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 자바 프로그램을 빌드할 경우에는 java 플러그인을 로드한다.</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 저장소 정보를 관리하는 프로퍼티이다. 이곳에서 저장소를 설정할 수 있다. (로컬 환경이나 원격 저장소 기술)</span></span><br><span class="line"><span class="comment">// jcenter는 그레이들에서 중앙 저장소로 이용되는 저장소이다.</span></span><br><span class="line"><span class="comment">// 메이븐 중앙 저장소는 mavenCentral 메서드를 이용해서 사용할 수 있다.</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 의존성에 관한 설정을 관리하는 프로퍼티이다. 필요한 라이브러리등의 정보를 기술한다.</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">'org.slf4j:slf4j-api:1.7.21'</span></span><br><span class="line">    testCompile <span class="string">'junit:junit:4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>settings.gradle</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 루트 프로젝트의 이름을 설정한다. 루트 프로젝트는 다수의 프로젝트를 관리할 때 기본이 되는 프로젝트를 가리킨다. 여기에서는 '이 빌드 파일로 빌드할 프로젝트의 이름'이라고 생각하면 된다.</span></span><br><span class="line">rootProject.name = <span class="string">'gradle-app'</span></span><br></pre></td></tr></table></figure><h2 id="인텔리제이에서-사용하기"><a href="#인텔리제이에서-사용하기" class="headerlink" title="인텔리제이에서 사용하기"></a>인텔리제이에서 사용하기</h2><p>인텔리제이는 표준으로 그레이들을 지원한다. 인텔리제이에서 그레이들용 프로젝트를 생성할 경우, <strong>gradle init –type java-library</strong> 명령어를 사용하는 경우와 결과가 조금 다르다.</p><p><strong>build.gradle</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">group <span class="string">'com.jongmin'</span></span><br><span class="line">version <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line"></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testCompile <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>시작 부분에 그룹 ID와 버전을 지정하는 문장이 포함되어 있다. gradle init으로 작성한 build.gradle에서는 포함되지 않았는데, 그 이유는 메이븐 저장소를 이용하기 때문이다. 메이븐에는 모든 프로그램에 그룹 ID와 아티팩트 ID가 할당되어 있다.</p><p>sourceCompatibility는 자바 소스 코드의 버전을 가리킨다.</p><h2 id="태스크-실행"><a href="#태스크-실행" class="headerlink" title="태스크 실행"></a>태스크 실행</h2><p>메이븐과 마찬가지로 실행할 내용을 <strong>‘Run…’ -&gt; ‘Edit Configurations’</strong> 메뉴에서 컨피그레이션에 설정하면 인텔리제이의 ‘Run’으로 프로그램의 빌드와 실행, 디버그 등의 기능을 수행할 수 있다.</p><h2 id="buildgradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h2><p>그래이들은 build.gradle에 기술한 코드를 필요에 따라 실행하여 빌드를 실행한다.</p><p>그레이들은 ‘그루비를 사용하는 빌드 도구’이다. 하지만 이는 정확한 설명은 아니다. 그레이들은 ‘그루비 그 자체’는 아니고 <strong>‘그루비 기반의 DSL(Domain Specific Language)’</strong>이다.</p><p>DSL은 ‘도메인 고유 언어’라고 불리는데, 특정한 용도에 한정된 언어를 말한다. 그 언어 그 자체는 아니고, 특정한 용도에 맞게 해당 언어를 기반으로 각색한 것이다. 그레이들에서 사용되는 언어는 ‘그루비를 기반으로 작성된 Gradle DLS’이다.</p><p><strong>그레이들은 기본적으로 태스크를 작성하여 실행한다.</strong> 태스크는 실행할 처리를 모아서 명령어로서 실행할 수 있게 한 것이다. 다음과 같은 형식으로 정의한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task 이름&#123;</span><br><span class="line">    ...실행할 처리...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 정의한 태스크는 명령행에서 <strong>gradle 이름</strong> 형태로 실행할 수 있다.</p><p>간단한 예제를 작성해 실행해보자. 다음과 같이 build.gradle을 수정한다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">   doLast &#123;</span><br><span class="line">       println();</span><br><span class="line">       println(<span class="string">"================="</span>);</span><br><span class="line">       println(<span class="string">"Welcome to Gradle!"</span>);</span><br><span class="line">       println(<span class="string">"================="</span>);</span><br><span class="line">       println();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>수정한 후, 명령행에서 다음과 같이 실행한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle hello</span><br></pre></td></tr></table></figure><p>결과는 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :hello</span><br><span class="line"></span><br><span class="line">=================</span><br><span class="line">Welcome to Gradle!</span><br><span class="line">=================</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> 2s</span><br><span class="line">1 actionable task: 1 executed</span><br></pre></td></tr></table></figure><p>그레이들은 기본적으로 빌드 도구이지만, 여기에서는 빌드도 컴파일도 하지 않고, 단지 메시지를 표시했다. 태스크는 작성된 처리를 실행할 뿐이지, 반드시 빌드와 관련된 기능이 포함되어야 하는 것은 아니다.</p><h3 id="quiet-모드로-실행"><a href="#quiet-모드로-실행" class="headerlink" title="quiet 모드로 실행"></a>quiet 모드로 실행</h3><p>이번에는 <strong>quiet 모드</strong>로 실행해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle -q hello</span><br></pre></td></tr></table></figure><p>결과는 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=================</span><br><span class="line">Welcome to Gradle!</span><br><span class="line">=================</span><br></pre></td></tr></table></figure><p>이렇게 하면 hello에서 println한 내용만 출력되며, 그 이외의 내용은 표시되지 않는다. <code>-q 옵션</code>은 태스크를 quiet 모드로 실행해 예외 발생 등 중요한 문제 이외의 표시가 제한된다. 태스크의 실행 결과만 알고 싶을 때 편리한 옵션이다.</p><blockquote><p><strong>액션 리스트</strong></p><p>태스크는 다양한 ‘액션’을 내부에 가지고 있다. 태스크를 실행하면 준비된 액션이 순서대로 실행된다. 이 액션을 관리하는 것이 ‘액션 리스트’이다. 액션은 어떤 역할을 하는지가 정해져 있다. 필요에 따라 액션에 처리를 추가해 태스크를 조합할 수 있다.</p><p>액션 중에서도 <strong>doFirst</strong>와 <strong>doLast</strong>가 가장 많이 사용된다. 각각 ‘처음에 실행되는 액션’과 ‘마지막에 실행되는 액션’이다. 이들을 이용해 태스크의 처음과 마지막에 처리를 실행할 수 있다.</p></blockquote><h3 id="매개변수-이용"><a href="#매개변수-이용" class="headerlink" title="매개변수 이용"></a>매개변수 이용</h3><p>태스크를 실행할 때 어떤 정보를 태스크에 전달하고 싶은 경우도 있다. 이럴 때 매개변수를 이용할 수 있다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">   doLast &#123;</span><br><span class="line">       <span class="keyword">def</span> total = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">def</span> i <span class="keyword">in</span> <span class="number">1.</span>.num.toInteger()) &#123;</span><br><span class="line">           total += i;</span><br><span class="line">       &#125;</span><br><span class="line">       println(<span class="string">"total: "</span> + total);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1에서 num까지 합하는 태스크이다. 여기서 사용되는 num이 매개변수로 전달되는 프로퍼티이다. 이처럼 매개변수에서 전달되는 값을 프로퍼티로 사용할 수 있다. 단, 주의할 점은 값이 String이라는 것이다.</p><p>hello 태스크는 다음과 같이 실행한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle hello -q -Pnum=100</span><br></pre></td></tr></table></figure><p>이처럼 태스크를 실행하는 동안에는 <strong>-P프로퍼티=값</strong> 형태로 특정 변수에 값을 전달할 수 있다.</p><h3 id="동적-태스크-실행"><a href="#동적-태스크-실행" class="headerlink" title="동적 태스크 실행"></a>동적 태스크 실행</h3><p>스크립트를 사용해서 동적으로 태스크를 생성할 수도 있다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> arr = [<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>];</span><br><span class="line">arr.each &#123;s -&gt;</span><br><span class="line">    task <span class="string">"$s"</span> &#123;</span><br><span class="line">        doLast &#123;</span><br><span class="line">            println(<span class="string">"this is $s task."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음과 같이 실행한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle -q one</span><br></pre></td></tr></table></figure><h3 id="java-플러그인-사용하기"><a href="#java-플러그인-사용하기" class="headerlink" title="java 플러그인 사용하기"></a>java 플러그인 사용하기</h3><p>자바로 개발할 때 필요한 기본적인 기능은 ‘java’ 플러그인에 포함되어 있다. build.gradle에서 로드하여 이용한다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br></pre></td></tr></table></figure><p>다음의 명령어로 빌드한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle java</span><br></pre></td></tr></table></figure><p>위 명령어를 실행하면 프로젝트가 컴파일되고 JAR 파일이 생성된다. 컴파일로 생성된 파일들은 build 폴더에 보관된다. 이 안의 libs 폴더 안에 gradle-app.jar 파일이 생성된다.</p><p>build 폴더 안에는 classes 폴더도 있는데, 여기에는 컴파일된 클래스 파일이 보관된다. gradle java에서는 우선 소스 코드를 컴파일하여 클래스 파일을 작성한 후, 이를 모아서 JAR 파일로 만드는 일련의 처리가 자동으로 수행된다.</p><blockquote><p><strong>gradle java와 gradle build</strong></p><p>grade java는 자바 프로그램의 빌드를 수행하지만, gradle build는 어떤 언어로 작성된 프로젝트라도 빌드한다. (그레이들은 자바 이외에도 그루비나 스칼라 등 많은 언어를 지원하고 각각의 언어에서 빌드를 수행하는 플러그인을 제공한다.)</p></blockquote><h3 id="java-플러그인의-태스크"><a href="#java-플러그인의-태스크" class="headerlink" title="java 플러그인의 태스크"></a>java 플러그인의 태스크</h3><p>java 플러그인에는 이 외에도 몇 가지 태스크가 더 있다.</p><ul><li><strong>java</strong><br>자바 소스 코드를 컴파일하고 그 외에 필요한 리소스 파일들을 모아서 JAR 파일을 생성한다. 프로그램을 배포할 때 이 태스크로 JAR 파일을 만들면 유용하다. <strong>단, 이 java 태스크로 생성된 JAR 파일은 Executable이 아니라는 점에 주의해야 한다.</strong></li><li><strong>compileJava</strong><br>자바 소스 코드를 모두 컴파일한다. 보존할 장소(build 안의 classes 폴더)가 없다면 폴더를 자동으로 생성하고 그 안에 클래스 파일을 작성한다.</li><li><strong>processResources</strong><br>리소스 파일을 클래스 디렉터리(classes 폴더) 안에 복사한다.</li><li><strong>classes</strong><br>소스 코드 컴파일과 리소스 파일 복사를 실행한다. compileJava와 processResources가 합쳐진 것이라 생각해도 된다.</li><li><strong>test</strong><br>프로그램 테스트를 실행한다. 소스 코드와 관련된 컴파일을 수행하고 테스트에 필요한 리소스 복사 등을 수행한 뒤 JUnit으로 테스트를 실행한다. JUnit 라이브러리를 이용할 수 없는 상태에서는 테스트를 실행할 때 오류가 발생한다.</li><li><strong>jar</strong><br>프로그램을 컴파일하고 리소스 파일 등을 준비한 뒤, JAR 파일로 패키징한다. 단, 파일을 단순히 JAR 파일에 모을 뿐이며 Executable jar을 작성하는 것은 아니다.</li><li><strong>javadoc</strong><br>소스 코드를 해석하여 Javadoc 파일을 생성한다. build 안의 docs 폴더 안에 javadoc 폴더를 작성하여 파일을 보관한다.</li><li><strong>clean</strong><br>빌드로 생성된 파일을 모두 삭제한다.</li></ul><h3 id="java-플러그인의-태스크-이용하기"><a href="#java-플러그인의-태스크-이용하기" class="headerlink" title="java 플러그인의 태스크 이용하기"></a>java 플러그인의 태스크 이용하기</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task doit(<span class="string">dependsOn:</span> [compileJava, jar]) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"*** compiled and created jar! ***"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doit 태스크에는 매개변수가 포함되어 있다. <strong>dependsOn은 이 매개변수가 ‘의존성’을 지정하는 것을 가리킨다.</strong> ‘compileJava, jar’은 2개의 태스크를 모아놓은 배열이다. 즉, doit이 compileJava와 jar이라는 2개의 태스크에 의존한다.</p><p>이 상태에서 dependsOn에서 태스크를 지정하면 그 태스크가 실행되기 전에 의존하는 모든 태스크가 실행된다. 그리고 의존하는 태스크의 실행이 완료된 후에 doit 태스크의 doLast가 호출된다.</p><p>의존성을 지정해서 실행하는 방법 이외에 태스크를 직접 실행할 수도 있는데, 태스크의 <code>execute 메서드</code>를 호출하면 된다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">task doit &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"*** compiled now! ***"</span></span><br><span class="line">        tasks.compileJava.execute()</span><br><span class="line">        println <span class="string">"*** create jar! ***"</span></span><br><span class="line">        tasks.jar.execute()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실행하면 의존성을 지정해서 실행할 때와 같은 결과를 얻지만, “Deprecated Gradle features were used in this build, making it incompatible with Gradle 5.0.” 라는 메시지가 출력된다. 그레이들 버전 5.0 부터는 execute 메서드를 직접 호출하는 것이 호환되지 않기 때문이다.</p><h3 id="application-플러그인"><a href="#application-플러그인" class="headerlink" title="application 플러그인"></a>application 플러그인</h3><p>java 플러그인에는 프로그램을 실행하는 태스크가 없어 application 플러그인을 사용해 애플리케이션을 실행해야 한다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'application"</span></span><br></pre></td></tr></table></figure><p>build.gradle에 이처럼 작성하고 그 다음에 mainClassName 프로퍼티에 메인 클래스(실행할 클래스)를 설정한다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainClassName = <span class="string">"com.jongmin.gradle.App"</span></span><br></pre></td></tr></table></figure><p>application 플러그인에는 run 태스크가 포함되어 있다. 이것을 실행하면 mainClassName에 지정된 클래스가 실행된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle run</span><br></pre></td></tr></table></figure><p>다음과 같이 작성하면 jar을 실행한 후 run으로 클래스를 실행할 수 있다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'application'</span></span><br><span class="line"></span><br><span class="line">mainClassName = <span class="string">"com.jongmin.gradle.App"</span></span><br><span class="line"></span><br><span class="line">task doit(<span class="string">dependsOn:</span>[jar, run]) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println(<span class="string">"*** do it! ***"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;그레이들&quot;&gt;&lt;a href=&quot;#그레이들&quot; class=&quot;headerlink&quot; title=&quot;그레이들&quot;&gt;&lt;/a&gt;그레이들&lt;/h1&gt;&lt;h2 id=&quot;그루비와-그레이들&quot;&gt;&lt;a href=&quot;#그루비와-그레이들&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Tool" scheme="https://jongmin92.github.io/categories/Programming/Tool/"/>
    
    
      <category term="java" scheme="https://jongmin92.github.io/tags/java/"/>
    
      <category term="build tool" scheme="https://jongmin92.github.io/tags/build-tool/"/>
    
      <category term="gradle" scheme="https://jongmin92.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>빌드 도구와 메이븐</title>
    <link href="https://jongmin92.github.io/2018/08/06/Tool/maven_basic/"/>
    <id>https://jongmin92.github.io/2018/08/06/Tool/maven_basic/</id>
    <published>2018-08-06T13:55:00.000Z</published>
    <updated>2018-08-08T16:49:35.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="빌드-도구"><a href="#빌드-도구" class="headerlink" title="빌드 도구"></a>빌드 도구</h1><h2 id="빌드-도구란"><a href="#빌드-도구란" class="headerlink" title="빌드 도구란?"></a>빌드 도구란?</h2><h3 id="개발-환경의-변화와-빌드"><a href="#개발-환경의-변화와-빌드" class="headerlink" title="개발 환경의 변화와 빌드"></a>개발 환경의 변화와 빌드</h3><p>자바를 처음 공부할 때는 이클립스 혹은 인텔리제이 같은 IDE만으로 프로그램을 뚝딱 만들 수 있다. 그러나 현업에 투입되면 무언가 복잡한 환경을 만나게 된다.</p><p>하지만 실제 자바 입문시절에 배운 과정과 현업에서 사용하는 과정에 차이는 없다. 다만 다양한 도구를 사용하여 더 전문화하여 현업 도구에 활용할 뿐이다.</p><ul><li><strong>명령행에서 컴파일하기</strong><br>아주 간단한 프로그램이라면 명령행에서 javac를 이용하는 것만으로도 충분하다. 하지만 라이브러리 등을 이용하면, classpath에 다수의 라이브러리 경로를 기술한 뒤에 컴파일 해야 한다. 또한 생성된 클래스 파일을 모아 JAR 파일을 생성하려면 이 역시 모두 명령어로 실행해야 한다.<br>소스 코드의 컴파일에서 JAR 파일의 생성까지 긴 과정을 수행하려면 방대한 명령어가 필요한데, 이를 매번 수작업으로 작성하면 큰 수고가 든다.</li><li><strong>프로젝트 및 라이브러리 설치</strong><br>최근에는 개발할 때 모든 프로그램을 처음부터 만드는 경우가 거의 없다. 프로그램에 필요한 기능은 라이브러리를 이용하거나, 프레임워크를 이용하여 애플리케이션을 개발한다.<br>이런 경우, 필요한 소프트웨어를 갖추고 정해진 대로 파일을 구성해야 한다.</li><li><strong>테스트 자동화</strong><br>단순한 프로그램이라면 컴파일 후 실행 및 동작만 확인하는 것으로 충분하지만, 어느 정도 규모 있는 프로그램은 프로그램 생성과 함께 테스트를 실행하는 것이 일반적이다.</li><li><strong>프로그램 배포</strong><br>웹 애플리케이션은 구현한 프로그램을 서버에 배포하게 된다. 이런 작업을 수작업으로 시행하기가 번거롭다.</li></ul><h3 id="빌드-도구의-역할"><a href="#빌드-도구의-역할" class="headerlink" title="빌드 도구의 역할"></a>빌드 도구의 역할</h3><p>‘빌드 도구’는 단순히 프로그램을 컴파일하여 애플리케이션을 생성하는 작업 그 이상으로 다양한 기능을 제공한다.</p><ul><li><strong>프로그램 빌드</strong><br>프로그램을 컴파일하고, 지정된 디렉터리에 필요한 리소스를 모아서 프로그램을 완성한다. 그때 라이브러리등 필요한 파일을 설치하도록 지정할 수 있다.</li><li><strong>프로그램 테스트와 실행</strong><br>빌드된 프로그램의 실행뿐 아니라 테스트 기능도 제공한다. 빌드를 실행 할 때, 빌드가 완료되면 곧바로 테스트를 실행하는 도구도 있다.</li><li><strong>라이브러리 관리</strong><br>프로그램에서 필요한 라이브러리들을 관리한다. 빌드 실행 시 자동으로 라이브러리를 다운로드하고 설치하는 등의 작업을 한다.</li><li><strong>배포 작업</strong><br>빌드한 프로그램을 배포하는 기능을 제공한다.</li></ul><h2 id="개발-도구와-빌드-도구"><a href="#개발-도구와-빌드-도구" class="headerlink" title="개발 도구와 빌드 도구"></a>개발 도구와 빌드 도구</h2><p>개발 도구에 있어 빌드 도구를 다루는 방식은 크게 두 가지이다.</p><ul><li><strong>빌드 도구를 이용하는 기능이 포함된 경우</strong><br>이클립스는 메이븐, 인텔리제이는 메이븐과 그레이들을 지원한다.</li><li><strong>개발 도구에서 명령어로 실행하는 경우</strong></li></ul><h1 id="메이븐-기초"><a href="#메이븐-기초" class="headerlink" title="메이븐 기초"></a>메이븐 기초</h1><p>메이븐은 아파치 소프트웨어 재단이 개발하는 오픈 소스 빌드 도구이다. ‘아파치 앤트(Ant)’의 후속으로 개발되었고, 자바 프로그램 개발을 대상으로 한 오픈 소스 빌드 도구이다.</p><h2 id="메이븐-특징"><a href="#메이븐-특징" class="headerlink" title="메이븐 특징"></a>메이븐 특징</h2><ul><li><strong>빌드 파일은 XML로 작성</strong></li><li><strong>단위 작업 ‘골’</strong><br>골은 메이븐에서 실행하는 작업의 목적을 지정한다. 메이븐 명령어를 실행할 때 골을 지정하면, 어떤 작업을 수행하여 무엇을 작성할지 지정할 수 있다.</li><li><strong>라이브러리 관리와 중앙 저장소</strong><br>빌드를 실행하는 사이에, 빌드 파일에 기술된 정보를 바탕으로 필요한 라이브러리를 자동으로 다운로드하여 포함시킨다. 이를 가능하게 하는 것이 중앙 저장소이다. 중앙 저장소는 메이븐에서 이용 가능한 라이브러리를 모아서 관리하는 웹 서비스이다.</li><li><strong>테스트와 문서 생성</strong><br>엔트의 표준에는 포함되지 않았던 JUnit 테스트 및 Javadoc 문서 생성 등의 기능을 갖추고 있다.</li><li><strong>플러그인을 이용한 확장</strong><br>플러그인을 사용하면 메이븐에 기능을 추가할 수 있다.</li></ul><h2 id="메이븐-프로젝트-생성"><a href="#메이븐-프로젝트-생성" class="headerlink" title="메이븐 프로젝트 생성"></a>메이븐 프로젝트 생성</h2><p>메이븐에 포함된 <strong><code>archetype:generate</code></strong>라는 골을 이용하면, 간단하게 프로젝트의 기본 부분을 만들 수 있다. 아키타입(archetype)은 프로그램의 템플릿 모음이다.</p><p>Intellij를 이용해서도 메이븐을 기반으로 프로그램을 빌드하는 프로젝트를 생성할 수 있다. New Project -&gt; 목록에서 Maven 선택 -&gt; Create from archetype 체크 -&gt; maven-archetype-quickstart 선택</p><p>메이븐에서는 mvn 명령어로 각종 조작을 할 수 있는데, 이 명령어들을 인텔리제이의 ‘Run’을 이용하여 실행할 수 있다. 실행할 내용을 컨피그레이션에 설정하면 인텔리제이의 ‘Run’으로 프로그램의 빌드와 실행, 디버그 등의 기능을 수행할 수 있다. (‘Run…’ -&gt; Edit Configurations’ 메뉴에서 설정 가능)</p><h2 id="pomxml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><p>pom.xml 파일에서 POM은 ‘Project Object Model’을 말한다. 이 파일에 프로젝트에 관한 각종 정보를 기술한다.</p><h3 id="ltprojectgt와-기본속성"><a href="#lt-project-gt-와-기본속성" class="headerlink" title="&lt;project&gt;와 기본속성"></a>&lt;project&gt;와 기본속성</h3><ul><li><p><strong>모델 버전</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modeVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modeVersion</span>&gt;</span></span><br></pre></td></tr></table></figure><p>기본적으로 메이븐은 하위 호환성을 지원하기 때문에 이후 새로운 버전이 되더라도 이곳의 버전 번호를 바꾸면 이외 부분은 크게 수정하지 않고도 사용할 수 있다.</p></li><li><p><strong>그룹 ID</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jongmin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br></pre></td></tr></table></figure><p>그룹 ID는 작성할 프로그램이 어디에 소속되어 있는지를 나타낸다.</p></li><li><p><strong>아티팩트 ID</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mvn-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure><p>그룹 ID와 함께 프로그램을 식별하는 데 사용된다. ID이기 때문에 같은 그룹 내에서 같은 프로젝트 이름이 중복되지 않도록 주의해야 한다.</p></li><li><p><strong>버전</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>메이븐을 사용하는 프로젝트를 빌드하거나 패키징한 경우 여기서 지정된 번호가 생성된 프로그램의 버전으로 설정된다. 보통은 생성된 JAR 파일의 파일명에도 사용된다.</p></li><li><p><strong>패키지 종류</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>보통은 jar을 지정하지만, zip이라고 지정하면 ZIP 파일로 패키징한다.</p></li><li><p><strong>애플리케이션 이름</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mvn-app<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br></pre></td></tr></table></figure><p>작성하는 애플리케이션의 이름을 지정한다. 그룹 ID나 아티팩트 ID와 달리 유일한 값일 필요가 없다.</p></li><li><p><strong>URL</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br></pre></td></tr></table></figure><p>기본값으로는 메이븐 사이트의 URL이 지정되어 있다.</p></li></ul><p><strong>&lt;properties&gt;</strong>는 pom.xml에서 이용되는 속성값을 설정한다.</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>기본값으로는 &lt;project.build.sourceEncoding&gt;라는 항목이 설정되어 있는데 이는 소스 파일의 문자 인코딩 방식을 지정한다.</p><h3 id="ltdependenciesgt와-의존성-설정"><a href="#lt-dependencies-gt-와-의존성-설정" class="headerlink" title="&lt;dependencies&gt;와 의존성 설정"></a>&lt;dependencies&gt;와 의존성 설정</h3><p>dependencies 태크를 통해 필요한 라이브러리를 관리할 수 있다. 여기에 의존성을 적어두면 필요한 라이브러리 등을 자동으로 다운로드하여 설치 등을 할 수 있다.</p><blockquote><p> &lt;dependency&gt; 태그를 설정하는 것만으로 의존 라이브러리가 자동으로 로드되는 것은 <strong>메이븐의 중앙 저장소</strong> 때문이다. 중앙 저장소는 메이븐을 개발한 아파치 소프트웨어 재단이 운영하는 사이트이다.</p></blockquote><h2 id="기본적인-골"><a href="#기본적인-‘골’" class="headerlink" title="기본적인 ‘골’"></a>기본적인 ‘골’</h2><p>메이븐은 골을 지정하여 실행할 처리의 역할을 정한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn 골</span><br></pre></td></tr></table></figure><ul><li><p><strong>compile</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br></pre></td></tr></table></figure><p>자바 소스 코드 파일을 컴파일 한다. 프로젝트 폴더 내에 target 폴더가 생성된다.</p></li><li><p><strong>test-compile</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">test</span>-compile</span><br></pre></td></tr></table></figure><p>유닛 테스트용 클래스를 컴파일한다. src 폴더 안의 test 안에 작성된 유닛 테스트용 소스 코드 파일을 컴파일하여, target 폴더 안에 test-class 폴더를 작성하고 그 안에 클래스 파일을 생성한다.</p></li><li><p><strong>test</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>메이븐은 테스트(유닛 테스트)가 거의 표준 기능으로 포함되어 있다. 테스트를 개별적으로 실행하는 골이 test이다.작성한 유닛 테스트용 클래스를 이용하여 테스트가 실행되고 그 결과가 출력된다.</p></li><li><p><strong>package</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure><p>mvn compile을 실행하면 클래스 파일이 생성되지만, 일반적으로 자바 프로그램은 클래스파일을 그대로 배포하지는 않는다. 일반적으로 JAR 파일 등으로 패키징하여 배포한다.</p><p>명령 한 번으로 프로그램을 컴파일하여 유닛 테스트를 실행한 후 JAR 파일로 패키징하는 처리가 모두 자동적으로 수행된다.</p><p>실행 후 target 폴더 안에 jar 파일이 생성된다.</p></li><li><p><strong>clean</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure><p>메이븐은 프로그램을 빌드하면서 컴파일된 클래스 파일 뿐만 아니라, 테스트, 압축을 실행하는 파일 등을 만든다. clean은 부가적으로 생성된 파일을 모두 지운다.</p></li></ul><h2 id="프로그램-실행하기"><a href="#프로그램-실행하기" class="headerlink" title="프로그램 실행하기"></a>프로그램 실행하기</h2><p>클래스가 하나인 코드는 java 명령어로도 쉽게 실행할 수 있다. 그러나 다양한 라이브러리를 이용하는 프로젝트에서는 모든 클래스 경로를 직접 지정해야 하기 때문에 java 명령어를 이용해 실행하는 일은 번거롭다.</p><p>메이븐에는 표준으로 자바 프로그램을 실행하는 골은 없다. 하지만 <code>exec-java-plugin</code> 플러그인을 이용하면 프로그램을 실행할 수 있다.</p><p>pom.xml의 &lt;project&gt; 태그 안에 있는 &lt;dependencies&gt; 종료 태그의 다음 행에 다음과 같이 플러그인을 추가한다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>exec-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.jongmin.App<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>명령행에 다음과 같이 실행하면 App 클래스가 실행된다. 만약 mvn clean으로 프로젝트의 빌드 결과물을 제거한 경우 다시 mvn package로 빌드한 후에 실행한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">exec</span>:java</span><br></pre></td></tr></table></figure><blockquote><p>exec-maven-plugin은 메인 클래스를 지정해야 한다. 플러그인에 정보를 지정할 때는 &lt;configuration&gt; 태그를 이용한다.</p></blockquote><h2 id="빌드-플러그인"><a href="#빌드-플러그인" class="headerlink" title="빌드 플러그인"></a>빌드 플러그인</h2><p>&lt;build&gt; 태그는 빌드에 관한 정보를 기술하는 태그이다. 형태는 다음과 같다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>...<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>...<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&lt;build&gt;와 &lt;plugins&gt; 태그는 여러 개 사용할 수 없다. 반드시 1개씩 있고, 그 안에 모든 &lt;plugin&gt;을 모아서 사용한다.</p><h2 id="메이븐의-골과-플러그인"><a href="#메이븐의-골과-플러그인" class="headerlink" title="메이븐의 골과 플러그인"></a>메이븐의 골과 플러그인</h2><p>exec:java 골은 플러그인을 사용해 추가된 것이다. 사실, 지금까지 사용했던 모든 골들도 플러그인으로 추가된 것이다.</p><ul><li>compile : maven-compiler-plugin</li><li>package : maven-jar-plugin</li><li>test : maven-surefire-plugin</li></ul><p>하지만 위의 플러그인은 표준으로 포함되어 있기 때문에 플러그인이라고 의식하지 못했던 것이다.</p><p>표준이 아닌 &lt;plugin&gt; 태그에 의해 추가된 플러그인의 골을 지정하는 경우에는 <code>xx:xx</code>와 같이 요소가 둘인 경우가 일반적이다. 플러그인 하나가 여러 골을 가질 수도 있기 때문에 ‘플로그인:골’ 형태로 기술한다.</p><blockquote><p>&lt;plugin&gt;이 필수는 아니다. 플러그인으로 추가하여 이용하는 골이라고 해서 &lt;plugin&gt;에 기술하지 않으면 사용하지 못하는 것은 아니다. &lt;plugin&gt;은 플러그인에 포함된 설정 등의 정보를 기술하는 태그이다. 그렇기 때문에 설정이 필요하지 않으면 기술할 필요가 없다.</p></blockquote><h2 id="인텔리제이에서-사용하기"><a href="#인텔리제이에서-사용하기" class="headerlink" title="인텔리제이에서 사용하기"></a>인텔리제이에서 사용하기</h2><p>플러그인을 통해 개발 도구의 프로젝트로 변환이 가능하다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn idea:idea</span><br></pre></td></tr></table></figure><p>위 골을 실행하면 인텔리제이에서 프로젝트를 다루는데 필요한 파일들이 생성된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn idea:clean</span><br></pre></td></tr></table></figure><p>인텔리제이 프로젝트에서 인텔리제이 관련 파일을 삭제하여 원래의 메이븐 프로젝트로 돌리려면 위의 골을 실행한다.</p><h2 id="실행-가능한-jar-파일-만들기"><a href="#실행-가능한-JAR-파일-만들기" class="headerlink" title="실행 가능한 JAR 파일 만들기"></a>실행 가능한 JAR 파일 만들기</h2><p>앞서 mvn package로 패키징했지만 이렇게 생성된 JAR 파일은 단순히 패키징 된 것이기 때문에 실행되지는 않는다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar 00.jar</span><br></pre></td></tr></table></figure><p>따라서 위의 명렁을 실행해도 00.jar에 기본 Manifest 속성이 없어 실행에 실패하게 된다.</p><p>실행 가능한 JAR 파일을 만들기 위해서는 maven-jar-plugin을 이용해 다음과 같은 &lt;plugin&gt; 태그를 작성하면 된다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>버전<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>메인 클래스<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&lt;archive&gt; 태그는 압축에 관한 설정이다. addClasspath는 클래스 경로에 JAR 파일이 있는 경로를 추가하기 위한 태그인데 보통은 true로 지정한다.</p><p>이렇게 설정 후 다시 <strong>mvn package</strong>로 JAR 파일을 생성한 후 java -jar로 실행해보면 문제없이 실행할 수 있다.</p><h2 id="저장소-이용"><a href="#저장소-이용" class="headerlink" title="저장소 이용"></a>저장소 이용</h2><p>&lt;dependency&gt; 를 추가하는 것만으로 필요한 라이브러리를 추가해 사용할 수 있었던 것은 <strong>중앙 저장소</strong> 때문이다. 그런데 저장소가 중앙 저장소만 있는 것은 아니다. 다른 원격 저장소나 로컬 저장소도 있다.</p><h3 id="로컬-저장소"><a href="#로컬-저장소" class="headerlink" title="로컬 저장소"></a>로컬 저장소</h3><p>자신이 만든 라이브러린, 그다지 유명하지 않은 라이브러리라면 아직 중앙 저장소에 공개되지 않을 수도 있다. 이러한 라이브러리는 로컬 저장소를 이용해 사용할 수 있다.</p><ul><li>원격 저장소 : 네트워크를 거쳐 서버에 접속하여 이용하는 공개된 저장소. 중앙 저장소도 원격 저장소의 한 종류이다.</li><li>로컬 저장소 : 로컬 환경에 있는 저장소이다.</li></ul><h3 id="원격-저장소-이용"><a href="#원격-저장소-이용" class="headerlink" title="원격 저장소 이용"></a>원격 저장소 이용</h3><p>원격 저장소는 pom.xml에 &lt;repositories&gt; 태그 안에 저장소 정보를 기술한다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>저장소 ID<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>이름<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>저장소 주소(URL)<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="로컬-저장소에-라이브러리-추가하기"><a href="#로컬-저장소에-라이브러리-추가하기" class="headerlink" title="로컬 저장소에 라이브러리 추가하기"></a>로컬 저장소에 라이브러리 추가하기</h3><p>추가하고자 하는 라이브러리 프로젝트에서 다음과 같이 실행하면 target에 빌드된 JAR 파일을 로컬 저장소에 설치한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure><p>또는 설치할 JAR 파일이 별도로 준비되어 있다면 <strong>install:install-file</strong> 골을 실행해서 지정한 라이브러리 파일을 로컬 저장소에 설치할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file</span><br><span class="line">-Dfile=<span class="string">"라이브러리 jar의 경로"</span></span><br><span class="line">-DgroupId=<span class="string">"그룹 ID"</span></span><br><span class="line">-DartifactId=<span class="string">"아티팩트 ID"</span></span><br><span class="line">-Dpackaging=<span class="string">"패키징(jar)"</span></span><br><span class="line">-Dversio=<span class="string">"버전(1.0)"</span></span><br></pre></td></tr></table></figure><h3 id="로컬-저장소의-위치-알아보기"><a href="#로컬-저장소의-위치-알아보기" class="headerlink" title="로컬 저장소의 위치 알아보기"></a>로컬 저장소의 위치 알아보기</h3><p>로컬 저장소의 위치는 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">홈 디렉터리/.m2/repository</span><br></pre></td></tr></table></figure><p>이 폴더에는 라이브러리가 그룹 ID마다 폴더로 정리되어 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;빌드-도구&quot;&gt;&lt;a href=&quot;#빌드-도구&quot; class=&quot;headerlink&quot; title=&quot;빌드 도구&quot;&gt;&lt;/a&gt;빌드 도구&lt;/h1&gt;&lt;h2 id=&quot;빌드-도구란&quot;&gt;&lt;a href=&quot;#빌드-도구란&quot; class=&quot;headerlink&quot; title=&quot;빌
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Tool" scheme="https://jongmin92.github.io/categories/Programming/Tool/"/>
    
    
      <category term="java" scheme="https://jongmin92.github.io/tags/java/"/>
    
      <category term="build tool" scheme="https://jongmin92.github.io/tags/build-tool/"/>
    
      <category term="maven" scheme="https://jongmin92.github.io/tags/maven/"/>
    
      <category term="mvn" scheme="https://jongmin92.github.io/tags/mvn/"/>
    
  </entry>
  
  <entry>
    <title>&lt;이펙티브 자바 2판&gt; 리뷰</title>
    <link href="https://jongmin92.github.io/2018/08/05/Book/effective_java_2e_review/"/>
    <id>https://jongmin92.github.io/2018/08/05/Book/effective_java_2e_review/</id>
    <published>2018-08-05T10:45:00.000Z</published>
    <updated>2018-08-18T04:02:57.595Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/post/2018-08-05/effective_java.jpg" alt=""></p><p>Java 개발자라면 꼭 읽어보아야 한다는 <code>Effective Java</code> 책이다.<br>Java 언어를 처음 접하는 개발자보다는 어느정도 Java를 이용해 개발을 하고 있는 개발자에게 많이 추천되는 책이다. 실제 책 도입 부분에서도 <strong>Java 언어를 처음 공부하는 개발자 보다는 중급 이상의 프로그래머 반열에 오르려면 반드시 읽어야 할 내용들을 포함하고 있다고 말하고 있다.</strong></p><p>나는 아무래도 이직 후 자바 개발과 스프링 프레임워크를 처음 접하게 되었는데, 자바 웹 애플리케이션 개발 전반에 대해 이해하고자 스프링 관련된 서적을 먼저 읽고 있었지만, 여러 팀 동료분들이 코드리뷰를 해주시면서 “이펙티브 자바” 책을 읽어보면 도움이 많이 될 것 같다고 조언해주셔서 읽어보게 되었다.</p><p><strong>이 책은 총 78개의 규칙으로 구성되어 있으며, 각 규칙은 최고의 프로그래머와 노련한 프로그래머 대부분이 유용하다고 믿는 지침들을 요약한 것이다.</strong> 책에서 등장하는 첫 번째 규칙이 <strong>“규칙 1. 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해 보라”</strong>인데, 동료분께 코드리뷰 받으면서 조언 받았던 부분이기도 했다. 그래서 첫 부분부터 아주 재밌게 읽어나갔다. 그 외에도 평소 코드리뷰에서 말씀해 주셨던 여러 내용들을 이 책을 통해 자세하게 알 수 있었다.</p><p>책 자체 내용은 쉽게 읽을 수 있는 정도는 아니었다. 오히려 이해하기 위해 고민하는 부분에서 깨닫게 되는 부분도 많은것 같다. (특히 제네릭 부분과 병행성 부분은 아직도 좀 어려운데 이 부분은 앞으로 어느 정도 시간이 지난 후 다시 읽어보면 또 다르게 받아들여지지 않을까 싶다.)<br>결과적으로 책을 읽고 난 후, 이부분을 개발할 때는 어떤 부분을 고려해 보아야 겠다라는 생각이 조금은 들게 된것 같다.</p><p><strong>책 자체는 얇지는 않지만 각 파트 별로 여러개의 규칙으로 구성되어 있고, 각 규칙들은 정말 길어봐야 5~6장 정도의 분량이기 때문에 짬내서 읽기에도 좋았던것 같다.</strong><br>Java를 사용해 개발하고 있는 개발자 분들 중 읽어 보시지 않은 분들이 계시다면 꼭 추천드리고 싶은 책이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/post/2018-08-05/effective_java.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Java 개발자라면 꼭 읽어보아야 한다는 &lt;code&gt;Effective Java&lt;/code&gt; 책이다.&lt;br&gt;Java 언어를 
      
    
    </summary>
    
      <category term="Book" scheme="https://jongmin92.github.io/categories/Book/"/>
    
    
      <category term="book" scheme="https://jongmin92.github.io/tags/book/"/>
    
      <category term="java" scheme="https://jongmin92.github.io/tags/java/"/>
    
      <category term="review" scheme="https://jongmin92.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>Intellij IDEA 단축키</title>
    <link href="https://jongmin92.github.io/2018/07/31/Tip/intellij-shortcut/"/>
    <id>https://jongmin92.github.io/2018/07/31/Tip/intellij-shortcut/</id>
    <published>2018-07-31T13:00:00.000Z</published>
    <updated>2018-07-31T14:29:14.819Z</updated>
    
    <content type="html"><![CDATA[<p>산뜻한 월요일 출근길 아침에 한통의 메시지를 받았다.</p><p><img src="/images/post/2018-07-31/message.png" alt=""></p><p>얼마전에 요런 이벤트에 응모했는데</p><p><img src="/images/post/2018-07-31/event.png" alt=""></p><p>오오…? 당첨된 것이다. 신가하게 개발 서적 혹은 강의 관련된 이벤트에 자주 당첨되는것 같다. 자세히 보니 5명 뽑는 이벤트에 15명이 지원한건가…<br>그래도 당첨됐다는 사실에 기뻤다!<br>평소에 자주보는 페이지이기도 하고 위의 IntelliJ 강의는 처음 나왔을 때, 들어보고 싶었다는 생각이 있었지만 공부할게 너무 많아 미뤄놨었는데 마침 당첨된 기념으로 월요일 <strong>퇴근 후 바로 끝장을 보았다.</strong></p><h1 id="어디에-도움이-될까"><a href="#어디에-도움이-될까" class="headerlink" title="어디에 도움이 될까?"></a>어디에 도움이 될까?</h1><p><strong>대부분의 개발자는 자신만의 개발 환경을 구축해서 사용한다.</strong> 예를 들면, 자신만의 dot file 들을 만들어 사용한다던가 IDEA의 세팅들을 커스터마이징해서 사용하는 것들이 있다.<br>나도 처음에는 IDEA의 “자동 정렬”과 같은 가장 간단한 단축키부터 사용하기 시작해 현재는 IntelliJ에 IdeaVim 플러그인 설치해서 사용할 정도로 나만의 개발환경을 구축하는데 적지 않은 시간을 쏟았다.</p><p>처음에는 물론 사용하기 쉽지 않다. 그러나 적응하기 시작하는 순간 엄청난 생산성의 향상을 가져온다. 손이 마우스로 가지 않고 <strong>vim을 사용하면 심지어 방향키 까지도 손이 가지 않는다.</strong></p><p><strong>이런 개발 환경을 구축하는데 있어 한가지 문제가 있다. 어떤 기능들이 있는지 알아야 찾아서 사용할텐데 어떤 기능들이 있는지 조차 파악하기가 마냥 쉬운게 아니라는 것이다.</strong> 대부분 내가 모르는 기능을 누군가 사용할때는 “이런 기능이 있었어?” 라는 반응이 많은데 이게 문제다! 한 번 사용하면 계속 사용하게 되는데 처음 사용하기가 어려운 이유이기도 하다.</p><p>다행히도 위의 강의는 이런 문제를 해소해준다! <strong>IntelliJ를 처음 사용하는 사람도! 이미 사용하고 있던 사람도! 모두 도움이 될 것이다.</strong> 어떤 기능이 있는지, 해당 기능을 어떤 단축키를 통해 사용할 수 있는지 강의를 보고 배워보자!</p><p>강의는 인프런을 통해서 수강할 수 있다. <strong>-&gt; <a href="https://www.inflearn.com/course/intellij-guide/#ref=event%EC%B4%88%EA%B0%9C%EB%AA%A8" target="_blank" rel="noopener">IntelliJ를 시작하는 분들을 위한 가이드</a></strong></p><p>강의를 수강하며 새롭게 알게된 기능중 <code>라인 합치기</code>의 경우 Vim의 <code>Shift + J</code> 단축키를 이용해 사용하고 있었는데, 단순히 두 라인을 합쳐주는 기능하는 걸 넘어서, IntelliJ의 <code>Shift + Cmd + J</code>는 문자열을 합칠 경우 더 유용하게 사용 가능했다. 그래서 Shift + Cmd + J를 Shift + J로 변경해버렸다!</p><h1 id="단축키"><a href="#단축키" class="headerlink" title="단축키"></a>단축키</h1><p>수강하며 실습해 볼 수 있는 단축키 리스트</p><ul><li><strong>코드 템플릿</strong><br>메인 메소드 : psvm<br>System.out.println() : sout</li></ul><ul><li><strong>실행환경 실행</strong><br>현재 포커스 : Ctrl + Shift + R<br>이전 실행 : Ctrl + R</li></ul><ul><li><strong>코드 Edit</strong><br>메인 메소드 실행 :<br>라인 복사 : Cmd + D<br>라인 삭제 : Cmd + 백스페이스<br>라인 합치기 : Ctrl + Shift + J<br>라인 이동 : Shfit + Option + 위 (아래)<br>구문 이동 : Shift + Cmd + 위 (아래)<br>Element 단위 이동 : Option + Shift + Cmd + 좌 (우)<br>인자값 즉시 보기 : Cmd + P<br>코드 구현부 즉시 보기 : Option + Space<br>Doc 즉시 보기 : F1</li></ul><ul><li><strong>포커스</strong><br>단어별 이동 : Option + &lt;, &gt;<br>단어별 선택 : Shift + Option + &lt;, &gt;<br>라인 첫/끝 이동 : Fn + &lt;, &gt;<br>라인 전체 선택 : Shift + Cmd + &lt;, &gt; / Shift + Fn + &lt;, &gt;<br>Page Up/Down : Fn + 위/아래<br>포커스 범위 한 단계씩 늘리기 : Option + 위 (아래)<br>포커스 뒤로/앞으로 가기 : Cmd + [, ]<br>멀티 포커스 : Option + Option + 아래<br>오류 라인 자동 포커스 : F2</li></ul><ul><li><strong>검색</strong><br>현재 파일에서 검색 : Cmd + F<br>현재 파일에서 교체 : Cmd + R<br>전체에서 검색 : Shift + Cmd + F<br>전체에서 교체 : Shift + Cmd + R<br>정규표현식으로 검색, 교체 : Regex 체크<br>파일 검색 : Shift + Cmd + O<br>메소드 검색 : Option + Cmd + O<br>Action 검색 : Shift + Cmd + A<br>최근 열었던 파일 목록 보기 : Cmd + E<br>최근 수정했던 파일 목록 보기 : Shift + Cmd + E</li></ul><ul><li><strong>자동완성</strong><br>스마트 자동 완성 : Shift + Ctrl + Space<br>스태틱 메소드 자동 완성 : Ctrl + Space + Space<br>Getter/Setter/생성자 자동 완성 : Cmd + N<br>Override 메소드 자동완성 : Ctrl + I<br>Live Template 목록 보기 : Cmd + J</li></ul><ul><li><strong>리팩토링</strong><br>변수 추출하기 : Cmd + Option + V<br>파라미터 추출하기 : Cmd + Option + P<br>메소드 추출하기 : Cmd + Option + M<br>이너클래스 추출하기 : F6<br>이름 일괄 변경하기 : Shift + F6<br>타입 일괄 변경하기 : Shift + Cmd + F6<br>Import 정리하기 : Ctrl + Option + O<br>코드 자동 정렬하기 : Cmd + Option + L</li></ul><ul><li><strong>디버깅</strong><br>Debug 모드로 실행하기 (현재 위치의 메소드) : Shift + Ctrl + D<br>Debug 모드로 실행하기 (이전에 실행한 메소드) : Ctrl + D<br>Resume (다음 브레이크 포인트로 이동하기) : Cmd + Option + R<br>Step Over (현재 브레이크에서 다음 한줄로 이동하기) : F8<br>Step Into (현재 브레이크의 다음 메소드로 이동) : F7<br>Step Out (현재 메소드의 밖으로 이동) : Shift + F8<br>Evaluate Expression (브레이크된 상태에서 코드 사용하기) : Option + F8<br>Watch (브레이크 이후의 코드 변경 확인하기) : 단축키 X</li></ul><ul><li><strong>Git</strong><br>Git View On : Cmd + 9<br>Git Option Popup : Ctrl + V<br>Git History : Ctrl + V =&gt; 4<br>Branch : Ctrl + V =&gt; 7<br>Commit : Cmd + K<br>Push : Shift + Cmd + K<br>Pull : Shift + Cmd + A =&gt; git pull<br>Github 연동하기 : Shift + Cmd + A =&gt; share GitHub</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;산뜻한 월요일 출근길 아침에 한통의 메시지를 받았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/post/2018-07-31/message.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;얼마전에 요런 이벤트에 응모했는데&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/i
      
    
    </summary>
    
      <category term="Tip" scheme="https://jongmin92.github.io/categories/Tip/"/>
    
    
      <category term="IntelliJ" scheme="https://jongmin92.github.io/tags/IntelliJ/"/>
    
      <category term="단축키" scheme="https://jongmin92.github.io/tags/%EB%8B%A8%EC%B6%95%ED%82%A4/"/>
    
  </entry>
  
  <entry>
    <title>람다 &amp; 스트림</title>
    <link href="https://jongmin92.github.io/2018/07/03/Java/java-lambda-stream/"/>
    <id>https://jongmin92.github.io/2018/07/03/Java/java-lambda-stream/</id>
    <published>2018-07-03T13:35:00.000Z</published>
    <updated>2018-07-04T16:40:01.333Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>해당 포스팅의 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788995379431" target="_blank" rel="noopener">Java의 정석 2권 - Chapter 14 람다 &amp; 스트림</a>에 있는 내용을 요약한 것입니다. 해당 책으로 복습하며 정리한 내용이고 문제가 된다면 바로 해당 포스팅을 삭제하도록 하겠습니다.</strong></p></blockquote><h1 id="람다와-스트림"><a href="#람다와-스트림" class="headerlink" title="람다와 스트림"></a>람다와 스트림</h1><h2 id="람다식이란"><a href="#람다식이란" class="headerlink" title="람다식이란?"></a>람다식이란?</h2><p><strong><code>람다식(Lambda expression)</code>은 간단히 말해서 메서드를 하나의 ‘식(expression)’으로 표현한 것이다.</strong> 람다식은 함수를 간략하면서도 명확한 식으로 표현할 수 있게 해준다.</p><p>메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 ‘익명 함수(annonymous function)’이라고도 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.setAll(arr, i -&gt; (<span class="keyword">int</span>)(Math.random()*<span class="number">5</span>)+<span class="number">1</span>); <span class="comment">// arr=[1,5,2,1,1]</span></span><br></pre></td></tr></table></figure><p>위의 문장에서  ‘i -&gt; (int)(Math.random()*5)+1)’이 람다식이다. 이 람다식이 하는 일을 메서드로 표현하면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.random()*<span class="number">5</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 메서드보다 람다식이 간결하고 이해하기 쉽다. 게다가 모든 메서드는 클래스에 포함되어야 하므로 클래스도 새로 만들어야 하고, 객체도 생성해야만 비로소 이 메서드를 호출할 수 있다. 그러나 람다식은 이 모든 과정없이 오직 <strong>람다식 자체만으로도 이 메서드의 역할을 대신할 수 있다.</strong></p><p><strong>또한, 람다식은 메서드의 매개변수로 전달되어지는 것이 가능하고, 메서드의 결과로 반환될 수도 있다. 람다식으로 인해 메서드를 변수처럼 다루는 것이 가능해진 것이다.</strong></p><h2 id="람다식-작성하기"><a href="#람다식-작성하기" class="headerlink" title="람다식 작성하기"></a>람다식 작성하기</h2><p>랃마식은 ‘익명 함수’답게 메서드에서 이름과 반환타입을 제거하고 매개변수 선언부와 몸통{} 사이에 ‘-&gt;’를 추가한다.</p><p>반환값이 있는 경우, return문 대신 ‘식(expression)’으로 대신 할 수 있다. 식의 연산결과가 자동으로 반환값이 된다. 이때는 ‘문장(statement)’이 아닌 ‘식’이므로 끝에 ‘;’을 붙이지 않는다.</p><p>람다식에 선언된 매개변수의 타입은 추론이 가능한 경우는 생략할 수 있는데, 대부분의 경우에 생략가능하다. 람다식에 반환타입이 없는 이유도 항상 추론이 가능하기 때문이다.</p><p>매개변수가 하나뿐인 경우에는 괄호()를 생략할 수 있다. 단, 매개변수의 타입이 있으면 괄호()를 생략할 수 없다.</p><p>마찬가지로 괄호{}안의 문장이 하나일 때는 괄호{}를 생략할 수 있다. 이 때 문장의 끝에 ‘;’를 붙이지 않아야 한다. 그러나 괄호{} 안의 문장이 return문일 경우 괄호{}를 생략할 수 없다.</p><h2 id="함수형-인터페이스funtional-interface"><a href="#함수형-인터페이스-Funtional-Interface" class="headerlink" title="함수형 인터페이스(Funtional Interface)"></a>함수형 인터페이스(Funtional Interface)</h2><p>자바에서 모든 메서드는 클래스 내에 포함되어야 한다. 사실 람다식은 익명 클래스의 객체와 동일하다.</p><p>하나의 메서드가 선언된 인터페이스를 정의해서 람다식을 다루는 것은 기존의 자바의 규칙들을 어기지 않으면서도 자연스럽다. 그래서 인터페이스를 통해 람다식을 다루기로 결정되었으며, 람다식을 다루기 위한 인터페이스를 <code>함수형 인터페이스(functional interface)</code>라고 부른다.</p><p>단, 함수형 인터페이스에는 오직 하나의 추상 메서드만 정의되어 있어야 한다는 제약이 있다. 그래야 람다식과 인터페이스의 메서드가 1:1로 연결 될 수 있기 때문이다. 반면에 static 메서드와 default 메서드의 개수에는 제약이 없다.</p><blockquote><p><strong><code>@FunctionalInterface</code></strong>를 붙이면, 컴파일러가 함수형 인터페이스를 올바르게 정의했는지 확인해주므로, 꼭 붙이는 것이 좋다.</p></blockquote><p><strong>함수형 인터페이스 타입의 매개변수와 반환타입</strong><br>함수형 인터페이스 MyFunction이 아래와 같이 정의되어 있을 때,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>;<span class="comment">// 추상 메서드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>메서드의 매개변수가 MyFunction 타입이면, 이 메서드를 호출할 때 람다식을 참조하는 참조변수를 매개변수로 지정해야한다는 뜻이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aMethod</span><span class="params">(MyFunction f)</span> </span>&#123;</span><br><span class="line">    f.myMethod();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">MyFunction f = () -&gt; System.out.println(<span class="string">"myMethod()"</span>);</span><br><span class="line">aMethod(f);</span><br></pre></td></tr></table></figure><p>또는 참조변수 없이 직접 람다식을 매개변수로 지정하는 것도 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aMethod(() -&gt; System.out.println(<span class="string">"myMethod()"</span>));</span><br></pre></td></tr></table></figure><p>메서드의 반환타입이 함수형 인터페이스라면, 이 함수형 인터페이스의 추상 메서드와 동등한 람다식을 가리키는 참조변수를 반환하거나 람다식을 직접 반환할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyFunction <span class="title">mymethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyFunction f = () -&gt; &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>람다식을 참조변수로 다룰 수 있다는 것은 메서드를 통해 람다식을 주고받을 수 있다는 것을 의미한다. 즉, 변수처럼 메서드를 주고받는 것이 가능해진 것이다. (사실상 메서드가 아니라 객체를 주고받는 것이라 달라진 것은 없다.)</p><p><strong>람다식의 타입과 형변환</strong><br>함수형 인터페이스로 람다식을 참조할 수 있는 것일 뿐, 람다식의 타입이 함수형 인터페이스의 타입과 일치하는 것은 아니다. 람다식은 익명 객체이고 익명 객체는 타입이 없다. 정확히는 타입은 있지만 컴파일러가 임의로 이름을 정하기 때문에 알 수 없는 것이다. 그래서 대입 연산자의 양변의 타입을 일치시키기 위해 형변환이 필요하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyFunction f = (Myfunction)(() -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>람다식은 MyFunction 인터페이스를 직접 구현하지 않았지만, 이 인터페이스를 구현한 클래스의 객체와 완전히 동일하기 때문에 위처럼 형변환을 허용한다. 그리고 이 형변환은 생략가능하다.</p><p>람다식은 이름이 없을 뿐 객체인데도, Object 타입으로 형변환 할 수 없다. 람다식은 오직 함수형 인터페이스로만 형변환이 가능하다.</p><p>일반적인 익명 객체라면, 객체의 타입이 <strong>‘외부클래스이름$번호’</strong>와 같은 형식으로 타입이 결정되었을 텐데, 람다식의 타입은 <strong>‘외부클래스이름$$Lambda$번호’</strong>와 같은 형식으로 되어 있다.</p><p><strong>외부 변수를 참조하는 람다식</strong><br>람다식도 익명 객체, 즉 익명 클래스의 인스턴스이므로 람다식에서 외부에 선언된 변수에 접근하는 규칙은 익명 클래스와 동일하다.</p><p>람다식 내에서 참조하는 지역변수는 final이 붙지 않았어도 상수로 간주한다.(인스턴스 변수는 변경 가능) 람다식 내에서 지역변수를 참조하면 람다식 내에서나 다른 어느 곳에서도 이 변수의 값을 변경할 수 없다.</p><h2 id="javautilfunction-패키지"><a href="#java-util-function-패키지" class="headerlink" title="java.util.function 패키지"></a>java.util.function 패키지</h2><p>java.util.function 패키지에 일반적으로 자주 쓰이는 형식의 메서드를 함수형 인터페이스로 미리 정의해 놓았다. 매번 새로운 함수형 인터페이스를 정의하지 말고, 가능하면 이 패키지의 인터페이스를 활용하는 것이 좋다.</p><p>그래야 함수형 인터페이스에 정의된 메서드 이름도 통일되고, 재사용성이나 유지보수 측면에서도 좋다. 자주 쓰이는 가장 기본적인 함수형 인터페이스는 다음과 같다.</p><ul><li>java.lang.Runnable<ul><li>메서드 : void run()</li><li>매개변수도 없고, 반환값도 없음.</li></ul></li><li>Supplier&lt;T&gt;<ul><li>메서드 : T get()</li><li>매개변수는 없고, 반환값만 있음.</li></ul></li><li>Consumer&lt;T&gt;<ul><li>메서드 : void accept(T t)</li><li>Supplier와 반대로 매개변수만 있고, 반환값이 없음</li></ul></li><li>Function&lt;T, R&gt;<ul><li>메서드 : R apply(T t)</li><li>일반적인 함수, 하나의 매개변수를 받아서 결과를 반환</li></ul></li><li>Predicate&lt;T&gt;<ul><li>메서드 : boolean test(T t)</li><li>조건식을 표현하는데 사용됨.</li></ul></li></ul><blockquote><p>타입 문자 ‘T’는 ‘Type’을, ‘R’은 ‘Return Type’을 의미한다.</p><p>인터페이스 이름 앞에 접두사 ‘Bi’가 붙으면 매개변수가 두 개인 함수형 인터페이스이다.</p><p>3개 이상의 매개변수를 갖는 함수형 인터페이스를 선언한다면 직접 만들어서 서야한다.</p></blockquote><p>컬렉션 프레임웍의 인터페이스에 디폴트 메서드가 추가되었다.</p><ul><li>Collection<ul><li>boolean removeIf(Predicate&lt;E&gt; filter)<br>: 조건에 맞는 요소를 삭제</li></ul></li><li>List<ul><li>void replaceAll(UnaryOperator&lt;E&gt; operator)<br>: 모든 요소를 변환하여 대체</li></ul></li><li>Iterable<ul><li>void forEach(Consumer&lt;T&gt; action)<br>: 모든 요소에 작업 action을 수행</li></ul></li><li>Map<ul><li>V compute(K key, BiFunction&lt;K,V,V&gt; f)<br>: 지정된 키의 값에 작업 f를 수행</li><li>V computeIfAbsent(K key, BiFunction&lt;K,V&gt; f)<br>: 키가 없으면, 작업 f 수행 후 추가</li><li>V computeIfPresentt(K key, BiFunction&lt;K,V,V&gt; f)<br>: 지정된 키가 있을 때, 작업 f 수행</li><li>V merge(K key, V value, BiFunction&lt;V,V,V&gt; f)<br>: 모든 요소에 병합작업 f를 수행</li><li>void forEach(BiConsumer&lt;K,V&gt; action)<br>: 모든 요소에 작업 action을 수행</li><li>void replaceAll(BiFunction&lt;K,V,V&gt; f)<br>: 모든 요소에 치환작업 f를 수행</li></ul></li></ul><p>래퍼클래스를 사용하는 것은 비효율적이다. 그래서 보다 효율적으로 처리할 수 있도록 기본형을 사용하는 함수형 인터페이스들이 제공된다.</p><ul><li>DoubleToIntfunction : AToBFunction은 입력이 A타입 출력이 B타입</li><li>ToIntFunction&lt;T&gt; : ToBFunction은 출력이 B타입이다. 입력은 generic 타입</li><li>intFunction&lt;R&gt; : AFunction은 입력이 A타입이고 출력은 generic 타입</li><li>ObjintConsumer&lt;T&gt; : ObjAFunction은 입력이 T, A타입이고 출력은 없다.</li></ul><h2 id="function의-합성과-predicate의-결합"><a href="#Function의-합성과-Predicate의-결합" class="headerlink" title="Function의 합성과 Predicate의 결합"></a>Function의 합성과 Predicate의 결합</h2><p>java.util.function 패키지의 함수형 인터페이스에는 추상형메서드 외에도 디폴트 메서드와 static 메서드가 정의되어 있다.</p><p><strong>Function의 합성</strong><br>함수 f, g가 있을 때, <strong>f.andThen(g)</strong>는 함수 f를 먼저 적용하고, 그 다음에 함수 g를 적용한다. 그리고 <strong>f.compose(g)</strong>는 반대로 g를 먼저 적용하고 f를 적용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; f = (s) -&gt; Integer.parseInt(s, <span class="number">16</span>);</span><br><span class="line">Function&lt;Integer, String&gt; g = (i) -&gt; Integer.toBinaryString(i);</span><br><span class="line">Function&lt;String, String&gt; h = f.andThen(g);</span><br><span class="line">Function&lt;Integer, Integer&gt; i = f.compose(g);</span><br></pre></td></tr></table></figure><p><strong>Predicate의 결합</strong><br>여러 조건식을 논리 연산자로 연결해서 하나의 식을 구성할 수 있는 것처럼, 여러 Predicate를 and(), or(), negate()로 연결해서 하나의 새로운 Predicate를 결합할 수 있다.</p><h2 id="메서드-참조"><a href="#메서드-참조" class="headerlink" title="메서드 참조"></a>메서드 참조</h2><p>람다식을 더욱 간결하게 표현할 수 있는 방법이 있다. 람다식이 하나의 메서드만 호출하는 경우에는 <code>메서드 참조</code>라는 방법으로 람다식을 간략히 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 변환 전</span></span><br><span class="line">Function&lt;String, Integer&gt; f = (String s) -&gt; Integer.parseInt(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 변환 후</span></span><br><span class="line">Function&lt;String, Integer&gt; f = Integer::parseInt;</span><br></pre></td></tr></table></figure><blockquote><p>하나의 메서드만 호출하는 람다식은 ‘클래스이름::메서드이름’ 또는 ‘참조변수::메서드이름’</p><p>으로 바꿀 수 있다.</p></blockquote><p>메서드 참조는 람다식을 마치 static 변수처럼 다룰 수 있게 해준다. 메서드 참조는 코드를 간략히 하는데 유용해서 많이 사용된다.</p><h1 id="스트림stream"><a href="#스트림-stream" class="headerlink" title="스트림(stream)"></a>스트림(stream)</h1><h2 id="스트림이란"><a href="#스트림이란" class="headerlink" title="스트림이란?"></a>스트림이란?</h2><p><strong><code>스트림</code>은 데이터 소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메서드들을 정의해 놓았다. 데이터 소스를 추상화했다는 것은, 데이터 소스가 무엇이던 간에 같은 방식으로 다룰 수 있게 되었다는 것과 코드의 재사용성이 높아진다는 것을 의미한다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] strArr = &#123;<span class="string">"aaa"</span>, <span class="string">"bbb"</span>, <span class="string">"ccc"</span>&#125;;</span><br><span class="line">List&lt;String&gt; strList = Arrays.asList(strArr);</span><br><span class="line"></span><br><span class="line">stream&lt;String&gt; strStream1 = strList.stream();</span><br><span class="line">stream&lt;String&gt; strStream2 = Arrays.stream(strArr);</span><br><span class="line"></span><br><span class="line">strStream1.sorted().forEach(System.out::println);</span><br><span class="line">strStream2.sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>스트림은 데이터 소스를 변경하지 않는다.</strong><br>스트림은 데이터 소스로부터 데이터를 읽기만할 뿐, 데이터 소스를 변경하지 않는다. 필요하다면, 결과를 컬렉션이나 배열에 담아서 반환할 수도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; sortedList = strStream2.sorted().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><strong>스트림은 일회용이다.</strong><br>스트림은 Iterator처럼 일회용이다. 한번 사용하면 닫혀서 다시 사용할 수 없다. 필요하다면 스트림을 다시 생성해야 한다.</p><p><strong>스트림은 작업을 내부 반복으로 처리한다.</strong><br>내부 반복이라는 것은 반복문을 메서드의 내부에 숨길 수 있다는 것을 의미한다. forEach()는 스트림에 정의된 메서드 중의 하나로 매개변수에 대입된 람다식을 데이터 소스의 모든 요소에 적용한다. (forEach()는 메서드 안에 for문을 넣어버린 것이다.)</p><p><strong>스트림의 연산</strong><br>스트림이 제공하는 다양한 연산을 이용해서 복잡한 작업들을 간단히 처리할 수 있다.</p><ul><li>중간 연산 : 연산 결과가 스트림인 연산. 스트림에 연속해서 중간 연산을 할 수 있음</li><li>최종 연산 : 연산 결과가 스트림이 아닌 연산. 스트림의 요소를 소모하므로 단 한번만 가능</li></ul><p><strong>지연된 연산</strong><br>스트림 연산에서 한 가지 중요한 점은 최종 연산이 수행되기 전까지는 중간 연산이 수행되지 않는다는 것이다. 중간 연산을 호출하는 것은 단지 어떤 작업이 수행되어야하는지를 지정해주는 것일 뿐이다. 최종 연산이 수행되어야 비로소 스트림의 요소들이 중간 연산을 거쳐 최종 연산에서 소모된다.</p><p><strong>병렬 스트림</strong><br>스트림으로 데이터를 다룰 때의 장점 중 하나가 병렬 처리가 쉽다는 것이다. 병렬 스트림은 내부적으로 fork&amp;join을 이용해서 자동적으로 연산을 병렬로 수행한다. 모든 스트림은 기본적으로 병렬 스트림이 아니므로 병렬 스트림을 사용하려면 parallelStream() 메서드를 사용해 병렬 스트림으로 전환해야 한다.</p><h2 id="스트림-만들기"><a href="#스트림-만들기" class="headerlink" title="스트림 만들기"></a>스트림 만들기</h2><p>스트림의 소스가 될 수 있는 대상은 배열, 컬렉션, 임의의 수 등 다양하다.</p><p><strong>컬렉션</strong><br>컬렉션의 최고 조상인 Collection에 stream()이 정의되어 있다. 그래서 Collection의 자손인 List와 Set을 구현한 컬렉션 클래스들은 모두 이 메서드로 스트림을 생성할 수 있다. stream()은 해당 컬렉션을 소스로 하는 스트림을 반환한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; Collection.stream()</span><br></pre></td></tr></table></figure><p><strong>배열</strong><br>배열을 소스로 하는 스트림을 생성하는 메서드는 다음과 같이 Stream과 Arrays에 static 메서드로 정의되어 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; Stream.of(T... values)</span><br><span class="line">Stream&lt;T&gt; Stream.of(T[])</span><br><span class="line">Stream&lt;T&gt; Arrays.stream(T[])</span><br><span class="line">Stream&lt;T&gt; Arrays.stream(T[] array, <span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endExclusive)</span><br></pre></td></tr></table></figure><p>그리고 int, long, double과 같은 기본형 배열을 소스로 하는 스트림을 생성하는 메서드도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntStream IntStream.of(<span class="keyword">int</span> ...values) <span class="comment">// 가변인자</span></span><br><span class="line">IntStream IntStream.of(<span class="keyword">int</span>[])</span><br><span class="line">IntStream Arrays.stream(<span class="keyword">int</span>[])</span><br><span class="line">IntStream Arrays.stream(<span class="keyword">int</span>[] array, <span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endExclusive)</span><br></pre></td></tr></table></figure><p><strong>특정 범위의 정수</strong><br>IntStream과 LongStream은 지정된 범위의 연속된 정수를 스트림으로 생성해서 반환하는 range()와 rangeClosed()를 가지고 있다.</p><p><strong>임의의 수</strong><br>난수를 생성하는데 사용하는 Random 클래스에는 해당 타입의 난수들로 이루어지는 스트림을 반환하는 인스턴스 메서드들이 포함되어 있다.</p><h2 id="스트림의-중간연산"><a href="#스트림의-중간연산" class="headerlink" title="스트림의 중간연산"></a>스트림의 중간연산</h2><p><strong>스트림 자르기 - skip(), limit()</strong><br>skip()과 limit()은 스트림의 일부를 잘라낼 때 사용한다.</p><p><strong>스트림의 요소 걸러내기 - filter(), distinct()</strong><br>distinct()는 스트림에서 중복된 요소들을 제거하고, filter()는 주어진 조건(Predicate)에 맞지 않는 요소를 걸러낸다.</p><p><strong>정렬 - sorted()</strong><br>스트림을 정렬할 때는 sorted()를 사용하면 된다.</p><p>sorted()는 지정된 Comparator로 스트림을 정렬하는데, Comparator대신 int값을 반환하는 람다식을 사용하는 것도 가능하다. Comparator를 지정하지 않으면 스트림 요소의 기본 정렬 기준(Comparable)으로 정렬한다. 단, 스트림의 요소가 Comparable을 구현한 클래스가 아니면 예외가 발생한다.</p><p>JDK 1.8부터 Comparator 인터페이스에 static 메서드와 디폴트 메서드가 많이 추가되었는데, 이 메서드들을 이용하면 정렬이 쉬워진다. 이 메서드들은 모두 Comparator&lt;T&gt;를 반환한다.</p><p><strong>변환 - map()</strong><br>스트림의 요소에 저장된 값 중에서 원하는 필드만 뽑아내거나 특정 형태로 변환해야 할 때가 있다. 이 때 사용하는 것이 바로 map()이다. 이 메서드의 선언부는 아래와 같으며, 매개변수로 T타입을 R타입으로 변환해서 반환하는 함수를 지정해야한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends R&gt; mapper)</span></span></span><br></pre></td></tr></table></figure><p><strong>조회 - peek()</strong><br>연산과 연산 사이에 올바르게 처리되었는지 확인하고 싶다면, peek()를 사용한다. forEach()와 달리 스트림의 요소를 소모하지 않으므로 연산 사이에 여러 번 끼워 넣어도 문제가 되지 않는다.</p><p>filter()나 map()의 결과를 확인할 때 유용하게 사용될 수 있다.</p><p><strong>mapToInt(), mapToLong(), mapToDouble()</strong><br>map()은 연산의 결과로 Stream&lt;T&gt; 타입의 스트림을 반환하는데, 스트림의 요소를 숫자로 변환하는 경우 IntStream과 같은 기본형 스트림으로 변환하는 것이 더 유용할 수 있다.</p><p>count()만 지원하는 Stream&lt;T&gt;와 달리 IntStream과 같은 기본형 스트림은 아래와 같이 숫자를 다루는데 편리한 메서드들을 제공한다.</p><ul><li>Int sum() : 스트림의 모든 요소의 총합</li><li>OptionalDouble average() : sum() / (double)count()</li><li>OptionalInt max() : 스트림의 요소 중 제일 큰 값</li><li>OptionalInt min() : 스트림의 요소 중 제일 작은 값</li></ul><p>위의 메서드들은 최종연산이기 때문에 호출 후 스트림이 닫힌다는 점을 주의해야 한다.</p><p>sum()과 average()를 모두 호출해야할 때, 스트림을 또 생성해야하므로 불편하다. 그래서 summaryStatistics()라는 메서드가 따로 제공된다.</p><p>반대로 IntStream을 Stream&lt;T&gt;로 변환할 때는 mapToObj()를, Stream&lt;Integer&gt;로 변환할 때는 boxed()를 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream = <span class="keyword">new</span> Random().ints(<span class="number">1</span>, <span class="number">46</span>); <span class="comment">// 1~45 사이의 정수</span></span><br><span class="line">Stream&lt;String&gt; lottoStream = intStream.distinct().limit(<span class="number">6</span>).sorted().mapToObj(i -&gt; i + <span class="string">","</span>);</span><br><span class="line">lottoStream.forEach(System.out::print);</span><br></pre></td></tr></table></figure><p><strong>flatMap() - Stream&lt;T[]&gt;를 Stream&lt;T&gt;로 변환</strong><br>스트림의 요소가 배열이거나 map()의 연산결과가 배열인 경우, 즉 스트림의 타입이 Stream&lt;T[]&gt;인 경우, Stream&lt;T&gt;로 다루는 것이 더 편리할 때가 있다. 그럴 때는 map()대신 flatMap()을 사용하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String[]&gt; strArrStrm = Stream.of(</span><br><span class="line"><span class="keyword">new</span> String[]&#123;<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> String[]&#123;<span class="string">"ABC"</span>, <span class="string">"GHI"</span>, <span class="string">"JKLMN"</span>&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; strStrm = strArrStrm.flatMap(Arrays::stream);</span><br></pre></td></tr></table></figure><p>요소의 타입이 Stream&lt;String&gt;인 스트림(Stream&lt;Stream&lt;String&gt;&gt;)이 있을때, 이 스트림을 Stream&lt;T&gt;으로 변환하려면 다음과 같이 map()과 flatMap()을 함께 사용해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; strStream = strStrm</span><br><span class="line">.map(s -&gt; s.toArray(String[]::<span class="keyword">new</span>)) <span class="comment">// Stream&lt;Stream&lt;String&gt;&gt; -&gt; Stream&lt;String[]&gt;</span></span><br><span class="line">.flatMap(Arrays::stream); <span class="comment">// Stream&lt;String[]&gt; -&gt; Stream&lt;String&gt;</span></span><br></pre></td></tr></table></figure><p>toArray()는 스트림을 배열로 변환해서 반환한다. 매개변수를 지정하지 않으면 Object[]을 반환하므로 특정 타입의 생성자를 지정해줘야 한다. 위에서는 String배열의 생성자(String[]::new)를 지정하였다.</p><h2 id="optionallttgt와-optionalint"><a href="#Optional-lt-T-gt-와-OptionalInt" class="headerlink" title="Optional&lt;T&gt;와 OptionalInt"></a>Optional&lt;T&gt;와 OptionalInt</h2><p>최종 연산의 결과 타입이 Optional인 경우가 있다. <code>Optional&lt;T&gt;</code>은 지네릭 클래스로 ‘T타입의 객체’를 감싸는 래퍼 클래스이다. 그래서 Optional타입의 객체에는 모든 타입의 참조변수를 담을 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value; <span class="comment">// T타입의 참조변수</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>최종 연산의 결과를 그냥 반환하는게 아니라 Optional 객체에 담아서 반환한다. 이처럼 객체에 담아서 반환을 하면, 반환된 결과가 null인지 매번 if문으로 체크하는 대신 Optional에 정의된 메서드를 통해서 간단히 처리할 수 있다.</p><blockquote><p>Objects클래스에 isNull(), nonNull(), requireNonNull()과 같은 메서드가 있는 것도 널 체크를 위한 if문을 메서드 안으로 넣어서 코드의 복잡도를 낮추기 위한 것이다.</p></blockquote><p><strong>Optional 객체 생성하기</strong><br>Optional 객체를 생성할 때는 of() 또는 ofNullable()을 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line">Optional&lt;String&gt; optVal = Optional.of(str);</span><br></pre></td></tr></table></figure><p>만일 참조변수의 값이 null일 가능성이 있으면, of()대신 ofNullable()을 사용해야 한다. of()는 매개변수의 값이 null이면 NullPointerException을 발생하기 때문이다.</p><p>Optional&lt;T&gt;타입의 참조변수를 기본값으로 초기화 할 때는 empty()를 사용한다. null로 초기화하는 것이 가능하지만, empty()로 초기화하는 것이 바람직하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optVal = <span class="keyword">null</span>; <span class="comment">// null로 초기화</span></span><br><span class="line">Optional&lt;String&gt; optVal = Optional.&lt;String&gt;empty(); <span class="comment">// 빈 객체로 초기화</span></span><br></pre></td></tr></table></figure><p><strong>Optional 객체의 값 가져오기</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optVal = Optional.of(<span class="string">"abc"</span>);</span><br><span class="line">String str1 = optVal.get(); <span class="comment">// optVal에 저장된 값을 반환. null이면 예외 발생</span></span><br><span class="line">String str2 = optVal.orElse(<span class="string">""</span>); <span class="comment">// optVal에 저장된 값이 null일 때는, ""을 반환</span></span><br></pre></td></tr></table></figure></p><p><strong>orElse()</strong>의 변형으로 null을 대체할 값을 반환하는 람다식을 지정할 수 있는 <strong>orElseGet()</strong>과 null일 때 지정된 예외를 발생시키는 <strong>orElseThrow()</strong>가 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str3 = optVal2.orElseGet(String::<span class="keyword">new</span>); <span class="comment">// () -&gt; new String()과 동일</span></span><br><span class="line">String str4 = optVal2.orElseThrow(NullPointerException::<span class="keyword">new</span>); <span class="comment">// null이면 예외 발생</span></span><br></pre></td></tr></table></figure><p><strong>Stream처럼 Optional 객체에도 filter()와 map(), 그리고 flatMap()을 사용할 수 있다.</strong></p><p><strong>isPresent()</strong>는 Optional 객체의 값이 null이면 false를, 아니면 true를 반환한다. <strong>ifPresent()</strong>은 값이 있으면 주어진 람다식을 실행하고 , 없으면 아무 일도 하지 않는다. ifPresent()는 Optional&lt;T&gt;를 반환하는 findAny()나 findFirst()와 같은 최종 연산과 잘 어울린다.</p><h2 id="스트림의-최종-연산"><a href="#스트림의-최종-연산" class="headerlink" title="스트림의 최종 연산"></a>스트림의 최종 연산</h2><p>최종 연산은 스트림의 요소를 소모해서 결과를 만들어낸다. 그래서 <strong>최종 연산후에는 스트림이 닫히게 되고 더 이상 사용할 수 없다. 최종 연산의 결과는 스트림 요소의 합과 같은 단일 값이거나, 스트림의 요소가 담긴 배열 또는 컬렉션일 수 있다.</strong></p><p><strong>forEach()</strong><br>반환 타입이 void이므로 스트림의 요소를 출력하는 용도로 많이 사용된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br></pre></td></tr></table></figure><p><strong>조건 검사 - allMatch(), anyMatch(), noneMatch(), findFirst(), findAny()</strong><br>스트림의 요소에 대해 지정된 조건에 모든 요소가 일치하는지, 일부가 일치하는지 아니면 어떤 요소도 일치하지 않는지 확인하는데 사용할 수 있는 메서드들이다. 이 메서드들은 모두 매개변수로 Predicate를 요구하며, 연산결과로 boolean을 반환한다.</p><p><strong>통계 - count(), sum(), average(), max(), min()</strong><br>IntStream과 같은 기본형 스트림에는 스트림의 요소들에 대한 통계 정보를 얻을 수 있는 메서드들이 있다. 대부분의 경우 위의 메서드를 사용하기보다 기본형 스트림으로 변환하거나 reduce()와 collect()를 사용해 통계 정보를 얻는다.</p><p><strong>리듀싱 - reduce()</strong><br>스트림의 요소를 줄여나가면서 연산을 수행하고 최종결과를 반환한다. 처음 두 요소를 가지고 연산한 결과를 가지고 그 다음 요소와 연산한다. 그래서 매개변수의 타입이 BinaryOperator&lt;T&gt;인 것이다. 이 과정에서 스트림의 요소를 하나씩 소모하게 되며, 스트림의 모든 요소를 소모하게 되면 그 결과를 반환한다.</p><p>최종 연산 count()와 sum()  등은 내부적으로 모두 reduce()를 이용해서 작성되어 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = intStream.reduce(<span class="number">0</span>, (a,b) -&gt; a + <span class="number">1</span>); <span class="comment">// count()</span></span><br><span class="line"><span class="keyword">int</span> sum = intStream.reduce(<span class="number">0</span>, (a,b) -&gt; a + b); <span class="comment">// sum()</span></span><br><span class="line"><span class="keyword">int</span> max = intStream.reduce(Integer.MIN_VALUE, (a,b) -&gt; a&gt;b ? a:b); <span class="comment">// max()</span></span><br><span class="line"><span class="keyword">int</span> min = intStream.reduce(Integer.MAX_VALUE, (a,b) -&gt; a&lt;b ? a:b); <span class="comment">// min()</span></span><br></pre></td></tr></table></figure><h2 id="collect"><a href="#Collect" class="headerlink" title="Collect()"></a>Collect()</h2><p><strong><code>collect()</code>는 스트림의 요소를 수집하는 최종 연산으로 리듀싱(reducing)과 유사하다. </strong>collect()가 스트림의 요소를 수집하려면, 어떻게 수집할 것인가에 대한 방법이 정의되어 있어야 하는데, 이 방법을 정의한 것이 바로 컬렉터(collector)이다.</p><p>컬렉터는 Collector 인터페이스를 구현한 것으로, 직접 구현할 수도 있고 미리 작성된 것을 사용할 수도 있다. Collectors 클래스는 미리 작성된 다양한 종류의 컬렉터를 반환하는 static 메서드를 갖고 있다.</p><ul><li>collect() : 스트림의 최종연산, 매개변수로 컬렉터를 필요로 한다.</li><li>Collector : 인터페이스, 컬렉터는 이 인터페이스를 구현해야 한다.</li><li>Collectors : 클래스, static 메서드로 미리 작성된 컬렉터를 제공한다.</li></ul><p><strong>스트림을 컬렉션과 배열로 변환 - toList(), toSet(), toMap(), toCollection(), toArray()</strong><br>List나 Set이 아닌 특정 컬렉션을 지정하려면, toCollection()에 해당 컬렉션의 생성자 참조를 매개변수로 넣어주면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = stuStream.map(Student::getName)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">ArrayList&lt;String&gt; list = names.stream()</span><br><span class="line">    .collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure><p>Map은 키와 값의 쌍으로 저장해야하므로 객체의 어떤 필드를 키로 사용할지와 값으로 사용할지를 지정해줘야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Person&gt; map = personStream.collect(Collectors.toMap(p-&gt;p.getRegId(), p-&gt;p));</span><br></pre></td></tr></table></figure><p>스트림에 저장된 요소들을 ‘T[]’ 타입의 배열로 변환하려면, toArray()를 사용하면 된다. 단, 해당 타입의 생성자 참조를 매개변수로 지정해줘야 한다. 만일 매개변수를 지정하지 않으면 반환되는 배열의 타입은 ‘Object[]’이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student[] stuNames = studentStream.toArray(Student[]::<span class="keyword">new</span>); <span class="comment">// OK</span></span><br><span class="line">Student[] stuNames = studentStream.toArray(); <span class="comment">// 에러</span></span><br><span class="line">Object[] stuNames = studentStream.toArray(); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p><strong>통계 - countint(), summingInt(), averagingInt(), maxBy(), minBy()</strong><br>최종 연산들이 제공하는 통계 정보를 collect()로 똑같이 얻을 수 있다.</p><p><strong>리듀싱 - reducing()</strong><br>리듀싱 역시 collect()로 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream = <span class="keyword">new</span> Random().ints(<span class="number">1</span>, <span class="number">46</span>).distinct().limit(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">OptionalInt max = intStream.reduce(Integer::max);</span><br><span class="line">Optional&lt;Integer&gt; max = intStream.boxed().collect(reducing(Integer::max));</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> sum = intStream.reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br><span class="line"><span class="keyword">long</span> sum = intStream.boxed().collect(reducing(<span class="number">0</span>, (a, b) -&gt; a + b));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> grandTotal = stuStream.map(Student::getTotalScore).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="keyword">int</span> grandTotal = stuStream.collect(reducing(<span class="number">0</span>, Student::getTotalScore, Integer::sum));</span><br></pre></td></tr></table></figure><p><strong>문자열 결합 - joining()</strong><br>문자열 스트림의 모든 요소를 하나의 문자열로 연결해서 반환한다. 구분자를 지정해줄 수도 있고, 접두사와 접미사도 가능하다. 스트림의 요소가 String이나 StringBuffer처럼 CharSequence의 자손인 경우에만 결합이 가능하므로 스트림의 요소가 문자열이 아닌 경우에는 먼저 map()을 이용해서 스트림의 요소를 문자열로 변환해야 한다.</p><p>만일 map()없이 스트림에 바로 joining()하면, 스트림의 요소에 toString()을 호출한 결과를 결합한다.</p><p><strong>그룹화와 분할 - groupingBy, partitioningBy()</strong><br>그룹화는 스트림의 요소를 특정 기준으로 그룹화하는 것을 의미하고, 분할은 스트림의 요소를 두 가지, 지정된 조건에 일치하는 그룹과 일치하지 않는 그룹으로의 분할을 의미한다. 스트림을 두 개의 그룹으로 나눠야 한다면, partitioningBy()로 분할하는 것이 더 빠르다. 그 외에는 groupingBy()를 쓰면 된다. 그룹화와 분할의 결과는 Map에 반환된다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788995379431" target="_blank" rel="noopener">Java의 정석 - 2</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;해당 포스팅의 내용은 &lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788995379431&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://jongmin92.github.io/categories/Programming/Java/"/>
    
    
      <category term="Java" scheme="https://jongmin92.github.io/tags/Java/"/>
    
      <category term="Lambda" scheme="https://jongmin92.github.io/tags/Lambda/"/>
    
      <category term="Stream" scheme="https://jongmin92.github.io/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>Collection Framework</title>
    <link href="https://jongmin92.github.io/2018/06/10/Java/java-collection-framework/"/>
    <id>https://jongmin92.github.io/2018/06/10/Java/java-collection-framework/</id>
    <published>2018-06-10T10:15:00.000Z</published>
    <updated>2018-06-10T10:24:33.974Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>해당 포스팅의 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788995379431" target="_blank" rel="noopener">Java의 정석 2권 - Chapter 11 컬렉션 프레임웍</a>에 있는 내용을 요약한 것입니다. 해당 책으로 복습하며 정리한 내용이고 문제가 된다면 바로 해당 포스팅을 삭제하도록 하겠습니다.</strong></p></blockquote><h1 id="컬렉션-프레임웍"><a href="#컬렉션-프레임웍" class="headerlink" title="컬렉션 프레임웍"></a>컬렉션 프레임웍</h1><p>Java API 문서에서는 <code>컬렉션 프레임웍</code>을 <strong>‘데이터 군(group)을 다루고 표현하기 위한 단일화된 구조’</strong>라고 정의하고 있다.</p><p>JDK 1.2부터 컬렉션 프레임웍이 등장하면서 다양한 종류의 컬렉션 클래스가 추가되고 모든 컬렉션 클래스를 표준화된 방식으로 다룰 수 있도록 체계화되었다.</p><h2 id="컬렉션-프레임웍의-핵심-인터페이스"><a href="#컬렉션-프레임웍의-핵심-인터페이스" class="headerlink" title="컬렉션 프레임웍의 핵심 인터페이스"></a>컬렉션 프레임웍의 핵심 인터페이스</h2><p>컬렉션 프리임웍에서는 컬렉션(데이터 그룹)을 크게 3가지 타입으로 구분하여 3가지 인터페이스를 정의했다. 그리고 인터페이스 중 List와 Set의 공통된 부분을 다시 뽑아서 새로운 인터페이스은 Collection을 추가로 정의하였다.</p><p>인터페이스 List와 Set을 구현한 컬렉션 클래스들은 서로 많은 공통부분이 있어서, 공통된 부분을 다시 뽑아 Collection 인터페이스를 정의할 수 있었지만 Map 인터페이스는 이들과는 전혀 다른 형태로 컬렉션을 다루기 때문에 같은 상속계층도에 포함되지 못했다.</p><ul><li><strong>List</strong> : 순서가 있는 데이터의 집합. 데이터의 중복을 허용한다.<ul><li>구현 클래스 : ArrayList, LinkedList, Stack, Vector 등</li></ul></li><li><strong>Set</strong> :  순서를 유지하지 않는 데이터의 집함. 데이터의 중복을 허용하지 않는다.<ul><li>구현 클래스 : HashSet, TreeSet 등</li></ul></li><li><strong>Map</strong> : 키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터의 집합. 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.<ul><li>구현 클래스 : HashMap, TreeMap, Hashtable, Properties 등</li></ul></li></ul><blockquote><p>Vector, Stack, Hashtable, Properties와 같은 클래스들은 컬렉션 프레임웍이 만들어지기 이전부터 존재하던 것이기 때문에 컬렉션 프레임웍의 명명법을 따르지 않는다.</p><p>Vector나 Hashtable과 같은 기존의 컬렉션 클래스들은 호환을 위해, 설계를 변경해서 남겨두었지만 가능하면 사용하지 않는 것이 좋다. 그 대신 새로 추가된 ArrayList와 HashMap을 사용하자.</p></blockquote><h3 id="collection-인터페이스"><a href="#Collection-인터페이스" class="headerlink" title="Collection 인터페이스"></a>Collection 인터페이스</h3><p>List와 Set의 조상인 Collection 인터페이스에는 다음과 같은 메서드들이 정의되어 있다. <strong>Collection 인터페이스는 컬렉션 클래스에 저장된 데이터를 읽고, 추가하고 삭제하는 등 컬렉션을 다루는데 가장 기본적인 메서드들을 정의하고 있다.</strong></p><ul><li>boolean add(Object o) : 지정된 객체(o)를 Collection에 추가한다.</li><li>boolean addAll(Collection c) : 지정된 Collection(c)의 객체들을 Collection에 추가한다.</li><li>void clear() : Collection의 모든 객체를 삭제한다.</li><li>boolean contains(Object o) : 지정된 객체(o)가 Collection에 포함되어 있는지 확인한다.</li><li>boolean equals(Object o) : 동일한 Collection인지 비교한다.</li><li>int hashCode() : Collection의 hash code를 반환한다.</li><li>boolean isEmpty() : Collection이 비어있는지 확인한다.</li><li>Iterator iterator() : Collection의 Iterator를 얻어서 반환한다.</li><li>boolean remove(Object o) : 지정된 객체를 삭제한다.</li><li>int size() : Collection에 저장된 객체의 개수를 반환한다.</li><li>Object[] toArray() : Collection에 저장된 객체를 객체배열(Object[])로 반환한다.</li><li>Object[] toArray(Object[] a) : 지정된 배열에 Collection의 객체를 저장해서 반환한다.</li></ul><h3 id="list-인터페이스"><a href="#List-인터페이스" class="headerlink" title="List 인터페이스"></a>List 인터페이스</h3><p><strong><code>List</code> 인터페이스는 중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현하는데 사용된다.</strong></p><ul><li>void add(int index, Object element) : 지정된 위치(index)에 객체(element) 또는 컬렉션에 포함된 객체들을 추가한다.</li><li>Object get(int index) : 지정된 위치(index)에 있는 객체를 반환한다.</li><li>int indexOf(Object o) : 지정된 객체의 위치(index)를 반환한다. (List의 첫 번째 요소부터 순방향으로 찾는다.)</li><li>lastIndexOf(Object o) : 지정된 객체의 위치(index)를 반환한다. (List의 마지막 요소부터 역방향으로 찾는다.)</li><li>ListIterator listIterator() : List의 객체에 접근할 수 있는 ListIterator를 반환한다.</li><li>Object remove(int index) : 지정된 위치(index)에 있는 객체를 삭제하고 삭제된 객체를 반환한다.</li><li>Object set(int index, Object element) : 지정된 위치(index)에 객체(element)를 저장한다.</li><li>void sort(Comparator c) : 지정된 비교자(comparator)로 List를 정렬한다.</li><li>List subList(int fromIndex, int toIndex) : 지정된 범위(fromIndex 부터 toIndex)에 있는 객체를 반환한다.</li></ul><h3 id="set-인터페이스"><a href="#Set-인터페이스" class="headerlink" title="Set 인터페이스"></a>Set 인터페이스</h3><p><strong><code>Set</code> 인터페이스는 중복을 허용하지 않고 저장순서가 유지되지 않는 컬렉션 클래스를 구현하는데 사용된다.</strong></p><h3 id="map-인터페이스"><a href="#Map-인터페이스" class="headerlink" title="Map 인터페이스"></a>Map 인터페이스</h3><p><strong><code>Map</code> 인터페이스는 키(key)와 값(value)을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는 데 사용된다.</strong> 키는 중복될 수 없지만 값은 중복을 허용한다. 구현 클래스로는 Hashtable, HashMap, LinkedHashMap, SortedMap, TreeMap 등이 있다.</p><ul><li>void clear() : Map의 모든 객체를 삭제한다.</li><li>boolean containsKey(Object key) : 지정된 key객체와 일치하는 Map의 Key객체가 있는지 확인한다.</li><li>boolean containsValue(Object value) : 지정된 value객체와 일치하는 Map의 Value객체가 있는지 확인한다.</li><li>Set entrySet() : Map에 저장되어 있는 key-value 쌍을 Map.Entry 타입의 객체로 저장한 Set으로 반환한다.</li><li>booelan equals(Object o) : 동일한 Map인지 비교한다.</li><li>Object get(Object key) : 지정한 key객체에 대응하는 value객체를 찾아서 반환한다.</li><li>int hashCode() : 해시코드를 반환한다.</li><li>boolean isEmpty() : Map이 비어있는지 확인한다.</li><li>Set keySet() : Map에 저장된 모든 Key객체를 반환한다.</li><li>Object put(Object key, Object value) : Map에 value객체를 key객체에 연결(mapping)하여 저장한다.</li><li>void putAll(Map t) : 지정된 Map의 모든 key-value 쌍을 추가한다.</li><li>Object remove(Object key) : 지정한 key객체와 일치하는 key-value객체를 삭제한다.</li><li>int size() : Map에 저장된 key-value 쌍의 개수를 반환한다.</li><li>Collection values() : Map에 저장된 모든 value객체를 반환한다.</li></ul><p><strong>Map 인터페이스에서 값(value)은 중복을 허용하기 때문에 Collection 타입으로 반환하고, 키(key)는 중복을 허용하지 않기 때문에 Set 타입으로 반환한다.</strong></p><h3 id="mapentry-인터페이스"><a href="#Map-Entry-인터페이스" class="headerlink" title="Map.Entry 인터페이스"></a>Map.Entry 인터페이스</h3><p><strong><code>Map.Entry</code> 인터페이스는 Map 인터페이스의 내부 인터페이스이다.</strong> 내부 클래스와 같이 인터페이스도 인터페이스 안에 인터페이스를 정의하는 내부 인터페이스(inner interface)를 정의하는 것이 가능하다.</p><p>Map에 저장되는 key-value 쌍을 다루기 위해 내부적으로 Entry 인터페이스를 정의해 놓았다.</p><ul><li>boolean equals(Object o) : 동일한 Entry인지 비교한다.</li><li>Object getKey() : Entry의 key객체를 반환한다.</li><li>Object getValue() : Entry의 value객체를 반환한다.</li><li>int hashCode() : Entry의 해시코드를 반환한다.</li><li>Object setValue(Object value) : Entry의 value객체를 지정된 객체로 바꾼다.</li></ul><h2 id="arraylist"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p><strong>List 인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고 중복을 허용한다는 특징을 갖는다.</strong></p><p>ArrayList는 기존의 Vector를 개선한 것으로  Vector와 구현원리와 기능적인 측면은 동일하다.</p><p><strong>ArrayList는 Object배열을 이용해서 데이터를 순차적으로 저장한다. 계속 배열에 순서대로 저장되며, 배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장된다.</strong></p><p>(Vector는 capacity가 부족할 경우 자동적으로 기존의 크기보다 2배의 크기로 증가된다. 그러나 생성자 Vector(int initialCapacity, int capacityIncrement)를 사용해서 인스턴스를 생성한 경우에는 지정해준 capacityIncrement만큼 증가하게 된다.)</p><p><strong>배열은 크기를 변경할 수 없기 때문에 ArrayList나 Vector 같이 배열을 이용한 자료구조는 데이터를 읽어오고 저장하는 데는 효율이 좋지만, 용량을 변경해야 할 때는 새로운 배열을 생성한 후 기존의 배열로부터 새로 생성된 배열로 데이터를 복사해야하기 때문에 상당히 효율이 떨어진다는 단점을 가지고 있다.</strong></p><h2 id="linkedlist"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><strong>배열은 가장 기본적인 형태의 자료구조로 구조가 간단하며 사용하기 쉽고 데이터를 읽어오는데 걸리는 시간(접근시간, access time)이 가장 빠르다는 장점을 가지고 있지만 다음과 같은 단점도 가지고 있다.</strong></p><ol><li><strong>크기를 변경할 수 없다.</strong><ul><li>크기를 변경할 수 없으므로 새로운 배열을 생성해서 데이터를 복사하는 작업이 필요 하다.</li><li>실행속도를 향상시키기 위해서는 충분히 큰 크기의 배열을 생성해야 하므로 메모리가 낭비된다.</li></ul></li><li><strong>비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.</strong><ul><li>차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠르지만,</li><li>배열의 중간에 데이터를 추가하려면, 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야 한다.</li></ul></li></ol><p>이러한 배열의 단점을 보완하기 위해서 링크드 리스트(linked list)라는 자료구조가 고안되었다. 배열은 모든 데이터가 연속적으로 존재하지만 링크드 리스트는 불연속적으로 존재하는 데이터를 서로 연결(link)한 형태로 구성되어 있다.</p><p>링크드 리스트의 각 요소(node)들은 자신과 연결된 다음 요소에 대한 참조(주소값)와 데이터로 구성되어 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Node next;  <span class="comment">// 다음 요소의 주소를 저장</span></span><br><span class="line">    Object obj; <span class="comment">// 데이터를 저장</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>링크드 리스트는 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전요소에 대한 접근은 어렵다. 이 점을 보완한 것이 더블 링크드 리스트(이중 연결리스트, doubly linked list)이다.</p><p><strong>더블 링크드 리스트는 링크드 리스트보다 각 요소에 대한 접근과 이동이 쉽기 때문에 링크드 리스트보다 더 많이 사용된다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Node next;     <span class="comment">// 다음 요소의 주소를 저장</span></span><br><span class="line">Node previous; <span class="comment">// 이전 요소의 주소를 저장</span></span><br><span class="line">    Object obj;    <span class="comment">// 데이터를 저장</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>더블 링크드 리스트의 접근성을 보다 향상시킨 것이 ‘더블 써큘러 링크드 리스트(이중 연결형 연결 리스트)’이다. 단순히 더블 링크드 리스트의 첫 번째 요소와 마지막 요소를 서로 연결시킨 것이다.</p><p>실제로 LinkedList 클래스는 이름과 달리 ‘링크드 리스트’가 아닌 ‘더블 링크드 리스트’로 구현되어 있는데, 이는 링크드 리스트의 단점인 낮은 접근성(accessability)을 높이기 위한 것이다.</p><ol><li><p><strong>순차적으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠르다.</strong><br>만약 ArrayList의 크기가 충분하지 않으면, 새로운 크기의 ArrayList를 생성하고 데이터를 복사하는 일이 발생하게 되므로 순차적으로 데이터를 추가해도 ArrayList보다 LinkedList가 더 빠를 수 있다.<br>순차적으로 삭제한다는 것은 마지막 데이터부터 역순으로 삭제해나간다는 것을 의미하며, ArrayList는 마지막 데이터부터 삭제할 경우 각 요소들의 재배치가 필요하지 않기 때문에 상당히 빠르다. (단지 마지막 요소의 값을 null로만 바꾸면 되기 때문이다.)</p></li><li><p><strong>중간 데이터를 추가/삭제하는 경우에는 LinkedList가 ArrayList보다 빠르다.</strong><br>LinkedList는 각 요소간의 연결만 변경해주면 되기 때문에 처리속도가 상당히 빠르다. 반면에 ArrayList는 각 요소들을 재배치하여 추가할 공간을 확보하거나 빈 공간을 채워야하기 때문에 처리속도가 늦다. 사실 데이터의 개수가 그리 크지 않다면 어느 것을 사용해도 큰 차이가 나지는 않는다.</p></li><li><p><strong>데이터의 개수가 많아질수록 데이터를 읽어 오는 시간, 즉 접근시간(access time)은 ArrayList가 LinkedList보다 빠르다.</strong><br>배열의 경우 만일 n번째 원소의 값을 얻어 오고자 한다면 단순히 아래와 같은 수식을 계산함으로써 해결된다. (배열은 각 요소들이 연속적으로 메모리상에 존재하기 때문이다.)</p><blockquote><p>n번째 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기</p></blockquote><p>그러나, LinkedList는 불연속적으로 위치한 각 요소들이 서로 연결된 것이 아니기 때문에 처음부터 n번째 데이터까지 차례대로 따라가야만 원하는 값을 얻을 수 있다.</p></li></ol><h2 id="stack과-queue"><a href="#Stack과-Queue" class="headerlink" title="Stack과 Queue"></a>Stack과 Queue</h2><p>순차적으로 데이터를 추가하고 삭제하는 스택에는 ArrayList와 같은 배열기반의 컬렉션 클래스가 적합하지만, 큐는 데이터를 꺼낼 때 항상 첫 번째 저장된 데이터를 삭제하므로, ArrayList와 같은 배열기반의 컬렉션 클래스를 사용한다면 데이터를 꺼낼 때마다 빈 공간을 채우기 위해 데이터의 복사가 발생하므로 비효율적이다. 그래서 큐는 ArrayList보다 데이터의 추가/삭제가 쉬운 LinkedList로 구현하는 것이 더 적합하다.</p><ul><li>Stack의 메서드<ul><li>boolean empty() : Stack이 비어있는지 알려준다.</li><li>Object peek() : Stack의 맨 위에 저장된 객체를 반환. pop()과 달리 Stack에서 객체를 꺼내지는 않음.</li><li>Object pop() : Stack의 맨 위에 저장된 객체를 꺼낸다.</li><li>Object push(Object item) : Stack에 객체(item)를 저장한다.</li><li>int search(Object o) : Stack에서 주어진 객체(o)를 찾아서 그 위치를 반환. 못찾으면 -1을 반환.</li></ul></li><li>Queue의 메서드<ul><li>boolean add(Object o) : 지정된 객체를 Queue에 추가한다.</li><li>Object remove() : Queue에서 객체를 꺼내 반환.</li><li>Object element() : 삭제없이 요소를 읽어온다.</li><li>boolean offer(Object o) : Queue에 객체를 저장.</li><li>Object poll() : Queue에서 객체를 꺼내서 반환. 비어있으면 null을 반환</li><li>Object peek() : 삭제없이 요소를 읽어 온다. Queue가 비어있으면 null을 반환</li></ul></li></ul><p><strong>자바에서는 스택을 Stack클래스로 구현하여 제공하고 있지만 큐는 Queue인터페이스로만 정의해 놓았을 뿐 별도의 클래스를 제공하고 있지 않다. 대신 Queue인터페이스를 구현한 클래스들이 있어서 이 들 중의 하나를 선택해서 사용하면 된다.</strong></p><h3 id="priorityqueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>Queue인터페이스의 구현체 중의 하나로, 저장한 순서에 관계없이 우선순위(priority)가 높은 것부터 꺼내게 된다는 특징이 있다. 그리고 null은 저장할 수 없다.</p><h3 id="dequedouble-ended-queue"><a href="#Deque-Double-Ended-Queue" class="headerlink" title="Deque(Double-Ended Queue)"></a>Deque(Double-Ended Queue)</h3><p>Queue의 변형으로, 한 쪽 끝으로만 추가/삭제할 수 있는 Queue와 달리, Deque은 양쪽 끝에 추가/삭제가 가능하다. Deque의 조상은 Queue이며, 구현체로는 ArrayDeque와 LinkedList 등이 있다.</p><p>덱은 스택과 큐를 하나로 합쳐놓은 것과 같으며 스택으로 사용할 수도 있고, 큐로 사용할 수도 있다.</p><h2 id="iterator-listiterator-enumeration"><a href="#Iterator-ListIterator-Enumeration" class="headerlink" title="Iterator, ListIterator, Enumeration"></a>Iterator, ListIterator, Enumeration</h2><p><strong>Iterator, ListIterator, Enumeration은 모두 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스이다.</strong> Enumeration은 Iterator의 구버젼이며, ListIterator는 Iterator의 기능을 향상 시킨 것이다.</p><h3 id="iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a><strong>Iterator</strong></h3><p><strong>컬렉션 프레임웍에서는 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화하였다. 컬렉션에 저장된 각 요소에 접근하는 기능을 가진 Iterator인터페이스를 정의하고, Collection인터페이스에는 Iterator를 반환하는 iterator()를 정의하고 있다.</strong></p><p><strong><code>iterator()</code>는 Collection인터페이스에 정의된 메서드이므로 Collection인터페이스의 자손인 List와 Set에도 포함되어 있다.</strong> 그래서 List나 Set인터페이스를 구현하는 컬렉션은 iterator()가 각 컬렉션의 특징에 알맞게 작성되어 있다.</p><ul><li>boolean hasNext() : 읽어 올 요소가 남아있는지 확인한다.</li><li>Object next() : 다음 요소를 읽어 온다. next()를 호출하기 전에 hasNext()를 호출해서 읽어 올 요소가 있는지 확인하는 것이 안전하다.</li><li>void remove() : next()로 읽어 온 요소를 삭제한다.</li></ul><h3 id="listiterator와-enumeration"><a href="#ListIterator와-Enumeration" class="headerlink" title="ListIterator와 Enumeration"></a><strong>ListIterator와 Enumeration</strong></h3><p><code>Enumeration</code>은 컬렉션 프레임웍이 만들어지기 이전에 사용하던 것으로 Iterator의 구버젼이라고 생각하면 된다.</p><p><code>ListIterator</code>는 Iterator를 상속받아서 기능을 추가한 것으로, 컬렉션의 요소에 접근할 때 Iterator는 단방향으로만 이동할 수 있는 데 반해 ListIterator는 양방향으로의 이동이 가능하다. 다만 List인터페이스를 구현한 컬렉션에서만 사용할 수 있다.</p><h2 id="arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>Arrays클래스에는 배열을 다루는데 유용한 메서드가 정의되어 있다.  Arrays에 정의된 메서드는 모두 static메서드이다.</p><h3 id="배열의-복사-copyof-copyofragne"><a href="#배열의-복사-copyOf-copyOfRagne" class="headerlink" title="배열의 복사 - copyOf(), copyOfRagne()"></a><strong>배열의 복사 - copyOf(), copyOfRagne()</strong></h3><p><strong><code>copyOf()</code>는 배열 전체를, <code>copyOfRange()</code>는 배열의 일부를 복사해서 새로운 배열을 만들어 반환한다.</strong> copyOfRange()에 지저왼 범위의 끝은 포함되지 안는다.</p><h3 id="배열-채우기-fill-setall"><a href="#배열-채우기-fill-setAll" class="headerlink" title="배열 채우기 - fill(), setAll()"></a>배열 채우기 - fill(), setAll()</h3><p><strong><code>fill()</code>은 배열의 모든 요소를 지정된 값으로 채운다. <code>setAll()</code>은 배열을 채우는데 사용할 함수형 인터페이스를 매개변수로 받는다.</strong> 이 메서드를 호출할 때는 함수형 인터페이스를 구현한 객체를 매개변수로 지정하던가 아니면 람다식을 지정해야 한다.</p><h3 id="배열의-정렬과-검색-sort-binarysearch"><a href="#배열의-정렬과-검색-sort-binarySearch" class="headerlink" title="배열의 정렬과 검색 - sort(), binarySearch()"></a>배열의 정렬과 검색 - sort(), binarySearch()</h3><p><strong><code>sort()</code>는 배열을 정렬할 때, 그리고 배열에 저장된 요소를 검색할 때는 <code>binarySearch()</code>를 사용한다.</strong> binarySearch()는 배열에서 지정된 값이 저장된 위치(index)를 찾아서 반환하는데, 반드시 배열이 정렬된 상태이어야 올바른 결과를 얻는다. (검색한 값과 일치하는 요소가 여러 개 있다면, 이 중 어떤 것의 위치가 반환될지는 알 수 없다.)</p><h3 id="문자열의-비교와-출력-equals-tostring-deepequals-deeptostring"><a href="#문자열의-비교와-출력-equals-toString-deepEquals-deepToString" class="headerlink" title="문자열의 비교와 출력 - equals(), toString(), deepEquals(), deepToString()"></a>문자열의 비교와 출력 - equals(), toString(), deepEquals(), deepToString()</h3><p><code>toString()</code>은 배열의 모든 요소를 문자열로 편하게 출력할 수 있다. toString은 일차원 배열에만 사용할 수 있으므로, 다차원 배열에서는 deepToString()을 사용해야 한다. <code>deepToString()</code>은 배열의 모든 요소를 재귀적으로 접근해서 문자열을 구성하므로 2차원뿐만 아니라 3차원 이상의 배열에 대해서도 동작한다.</p><p><code>equals()</code>는 두 배열에 저장된 모든 요소를 비교해서 같으면 true, 다르면 false를 반환한다. equals()도 일차원 배열에만 사용가능하므로, 다차원 배열의 비교에는 <code>deepEquals()</code>를 사용해야 한다.</p><h3 id="배열을-list로-변환-aslistobject-a"><a href="#배열을-List로-변환-asList-Object…-a" class="headerlink" title="배열을 List로 변환 - asList(Object… a)"></a>배열을 List로 변환 - asList(Object… a)</h3><p><strong><code>asList()</code>는 배열을 List에 담아서 반환한다.</strong> 한 가지 주의할 점은 asList()가 반환한 List의 크기를 변경할 수 없다는 것이다. 저장된 내용은 변경 가능하나, 추가 또는 삭제가 불가능하다. 만약 크기를 변경할 수 있는 List가 필요하다면 다음과 같이 하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure><h3 id="parallelxxx-spliterator-stream"><a href="#parallelXXX-spliterator-stream" class="headerlink" title="parallelXXX(), spliterator(), stream()"></a>parallelXXX(), spliterator(), stream()</h3><p><code>parallel</code>로 시작하는 이름의 메서드는 빠른 결과를 얻기 위해 여러 쓰레드가 작업을 나누어 처리하도록 한다. <code>spliterator()</code>는 여러 쓰레드가 처리할 수 있게 하나의 작업을 여러 작업으로 나누는 Spliterator를 반환하며, <code>stream()</code>은 컬렉션을 스트림으로 변환한다.</p><h2 id="comparator와-comparable"><a href="#Comparator와-Comparable" class="headerlink" title="Comparator와 Comparable"></a>Comparator와 Comparable</h2><p><strong><code>Comparator</code>와 <code>Comparable</code>은 모두 인터페이스로 컬렉션을 정렬하는데 필요한 메서드를 정의하고 있으며, Comparable을 구현하고 있는 클래스들은 같은 타입의 인터페이스끼리 서로 비교할 수 있는 클래스들(주로 wrapper클래스)이 있으며, 기본적으로 오름차순으로 구현되어 있다. 그래서 Comparable을 구현한 클래스는 정렬이 가능하다는 것을 의미한다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Comparator의 compare()와 Comparable의 compareTo()는 두 객체를 비교한다는 같은 기능을 목적으로 만들어 졌다. compareTo()는 반환값은 int지만 실제로는 비교하는 두 객체가 같으면 0, 비교하는 값보다 작으면 음수, 크면 양수를 반환하도록 구현해야한다. compare()도 객체를 비교해서 음수, 0, 양수 중의 하나를 반환하도록 구현해야한다.</p><blockquote><p>Comparable : 기본 정렬기준(오름차순)을 구현하는데 사용.</p><p>Comparator : 기본 정렬기준 외에 다른 기준으로 정렬하고자할 때 사용</p></blockquote><p>Arrays.sort()는 배열을 정렬할 때, Comparator를 지정해주지 않으면 저장하는 객체에 구현된 내용에 따라 정렬된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span> <span class="comment">// 객체 배열에 저장된 객체가 구현한 Comparable에 의한 정렬</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a, Comparator c)</span> <span class="comment">// 지정한 Comparator에 의한 정렬</span></span></span><br></pre></td></tr></table></figure><h2 id="hashset"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p><strong><code>HashSet</code>은 Set인터페이스를 구현한 가장 대표적인 컬렉션이며, Set인터페이스의 특징대로 HashSet은 중복된 요소를 저장하지 않는다.</strong></p><p>ArrayList와 같이 List인터페이스를 구현한 컬렉션과 달리 HashSet은 저장순서를 유지하지 않으므로 저장순서를 유지하고자 한다면 LinkedHashSet을 사용해야 한다.</p><blockquote><p>HashSet은 내부적으로 HashMap을 이용해서 만들어졌으며, HashSet이란 이름은 해싱(hasing)을 이용해서 구현했기 때문에 붙여진 것이다.</p></blockquote><p>HashSet의 add메서드는 새로운 요소를 추가하기 전에 기존에 저장된 요소와 같은 것인지 판별하기 위해 추가하려는 요소의 equals()와 hashCode()를 호출하기 때문에 equals()와 hashCode()를 목적에 맞게 오버라이딩해야 한다.</p><p><strong>오버라이딩을 통해 작성된 <code>hashCode()</code>는 다음의 세 가지 조건을 만족 시켜야 한다.</strong></p><ol><li>실행 중인 애플리케이션 내의 동일한 객체에 대해서 여러 번 hashCode()를 호출해도 동일한 int 값을 반환해야 한다. 하지만, 실행시마다 동일한 int값을 반환할 필요는 없다.<br>(String 클래스는 문자열의 내용으로 해시코드를 만들어 내기 때문에 내용이 같은 문자열에 대한 hashCode() 호출은 항상 동일한 해시코드를 반환한다. 반면에 Object클래스는 객체의 주소로 해시코드를 만들어 내기 때문에 실행할 때마다 해시코드값이 달라질 수 있다.)</li><li>equals메서드를 이용한 비교에 의해서 true를 얻은 두 객체에 대해 각각 hashCode()를 호출해서 얻은 결과는 반드시 같아야 한다.</li><li>equals메서드를 호출했을 때 false를 반환하는 두 객체는 hashCode() 호출에 대해 같은 int값을 반환하는 경우가 있어도 괜찮지만, 해싱(hashing)을 사용하는 컬렉션의 성능을 향상시키기 위해서는 다른 int값을 반환하는 것이 좋다.</li></ol><h2 id="treeset"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p><strong><code>TreeSet</code>은 이진 검색 트리(binary search tree)라는 자료구조의 형태로 데이터를 저장하는 컬렉션 클래스이다. 이진 검색 트리는 정렬, 검색, 범위검색(range search)에 노은 성능을 보이는 자료구조이며 TreeSet은 이진 검색 트리의 성능을 향상시킨 ‘레드-블랙 트리(Red-Black tree)’로 구현되어 있다.</strong></p><p>Set인터페이스를 구현했으므로 중복된 데이터의 저장을 허용하지 않으며 정렬된 위치에 저장하므로 저장순서를 유지하지도 않는다.</p><h2 id="hashmap과-hashtable"><a href="#HashMap과-Hashtable" class="headerlink" title="HashMap과 Hashtable"></a>HashMap과 Hashtable</h2><p>Hashtable과 HashMap의 관계는 Vector와 ArrayList의 관계와 같아서 Hashtable보다는 새로운 버전인 HashMap을 사용할 것을 권한다.</p><p><strong><code>HashMap</code>은 Map을 구현했으므로 Map의 특징인 키(key)와 값(value)을 묶어서 하나의 데이터(entry)로 저장한다는 특징을 갖는다. 그리고 해싱(hashing)을 사용하기 때문에 많은 양의 데이터를 검색하는데 있어서 뛰어난 성능을 보인다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span> <span class="keyword">extends</span> <span class="title">AbstractMap</span> <span class="keyword">implements</span> <span class="title">Map</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> Entry[] table;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object key;</span><br><span class="line">        Object value;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap은 Entry라는 내부 클래스를 다시 정의하고, 다시 Entry타입의 배열을 선언하고 있다. 키(key)와 값(value)은 별개의 값이 아니라 서로 관련된 값이기 때문에 각각의 배열로 선언하기 보다는 하나의 클래스로 정의해서 하나의 배열로 다루는 것이 데이터의 무결성적인 측면에서 더 바람직하기 때문이다.</p><p>HashMap은 키와 값을 각각 Object타입으로 저장한다. 즉 어떠한 객체도 저장할 수 있지만 키는 주로 String을 대문자 또는 소문자로 통일해서 사용하곤 한다.</p><ul><li>Set entrySet() : HashMap에 저장된 키와 값을 엔트리(키와 값의 결합)의 형태로 Set에 저장해서 반환</li><li>Object get(Object key) : 지정된 키(key)의 값(객체)을 반환. 못찾으면 null 반환</li><li>Set keySet() : HashMap에 저장된 모든 키가 저장된 Set을 반환</li><li>Object put(Object key, Object value) : 지정된 키와 값을 HashMap에 저장</li><li>Collection values() : HashMap에 저장된 모든 값을 컬렉션의 형태로 반환</li></ul><h3 id="해싱과-해시함수"><a href="#해싱과-해시함수" class="headerlink" title="해싱과 해시함수"></a>해싱과 해시함수</h3><p><strong><code>해싱</code>이란 해시함수(hash function)을 이용해서 데이터를 해시테이블(hash table)에 저장하고 검색하는 기법을 말한다. 해시함수는 데이터가 저장되어 있는 곳을 알려주기 때문에 다량의 데이터 중에서도 원하는 데이터를 빠르게 찾을 수 있다.</strong></p><p>해싱에서 사용하는 자료구조는 배열과 링크드 리스트의 조합으로 되어 있다.</p><p>저장할 데이터의 키를 해시함수에 넣으면 배열의 한 요소를 얻게 되고, 다시 그 곳에 연결되어 있는 링크드 리스트에 저장하게 된다.</p><ol><li>검색하고자 하는 값의 키로 해시함수를 호출한다.</li><li>해시함수의 계산결과인 해시코드를 이용해서 해당 값이 저장되어 있는 링크드 리스트를 찾는다.</li><li>링크드 리스트에서 검색한 키와 일치하는 데이터를 찾는다.</li></ol><p>링크드 리스트는 검색에 불리한 자료구조이기 때문에 링크드 리스트의 크기가 커질수록 검색속도가 떨어지게 된다.</p><p>하나의 링크드 리스트에 최소한의 데이터만 저장되려면, 저장될 데이터의 크기를 고려해서 HashMap의 크기를 적절하게 지정해주어야 하고, 해시함수가 서로 다른 키에 대해서 중복된 해시코드의 반환을 최소화해야 한다. 그래야 HashMap에서 빠른 검색시간을 얻을 수 있다.</p><p>실제로는 HashMap과 같이 해싱을 구현한 컬렉션 클래스에는 Object클래스에 정의된 hashCode()를 해시함수로 사용한다. Object클래스에 정의된 hashCode()는 객체의 주소를 이용하는 알고리즘으로 해시코드를 만들어 내기 때문에 모든 객체에 대헤 hashCode()를 호출한 결과가 서로 다른 좋은 방법이다.</p><p>String클래스의 경우 Object로부터 상속받은 hashCode()를 오버라이딩해서 문자열의 내용으로 해시코드를 만들어 낸다. 그래서 서로 다른 String인스턴스일지라도 같은 내용의 문자열을 가졌다면 hashCode()를 호출하면 같은 해시코드를 얻는다.</p><p>HashSet과 마찬가지로 HashMap에서도 서로 다른 두 객체에 대해 equals()로 비교한 결과가 true인 동시에 hashCode()의 반환값이 같아야 같은 객체로 인식한다. (이미 존재하는 키에 대한 값을 저장하면 기존의 값을 새로운 값으로 덮어쓴다.)</p><p>그래서 새로운 클래스를 정의할 때 equals()를 오버라이딩해다 한다면 hashCode()도 같이 오버라이딩해서 equals()의 결과가 true인 두 객체의 해시코드가 항상 같도록 해주어야 한다.</p><p>그렇지 않으면 HashMap과 같이 해싱을 구현한 컬렉션 클래스에서는 equals()의 호출결과가 true지만 해시코드가 다른 두 객체를 서로 다른 것으로 인식하고 따로 저장할 것이다.</p><h2 id="treemap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p><code>TreeMap</code>은 이진검색트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장한다. 그래서 검색과 정렬에 적합한 컬렉션 클래스이다.</p><p>검색에 관한 대부분의 경우에서는 HashMap이 TreeMap보다 더 뛰어나므로 HashMap을 사용하는 것이 좋다. 다만 범위검색이나 정렬이 필요한 경우에는 TreeMap을 사용하자.</p><h2 id="properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p><code>Properties</code>는 HashMap의 구버전인 Hashtable을 상속받아 구현한 것으로, Hashtable은 키와 값을 (Object, Object)의 형태로 저장하는데 비해 Properties는 (String, String)의 형태로 저장하는 보다 단순화된 컬렉션클래스이다.</p><p><strong>주로 애플리케이션의 환경설정과 관련된 속성(property)을 저장하는데 사용되며 데이터를 파일로부터 읽고 쓰는 편리한 기능을 제공한다.</strong></p><h2 id="collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>Arrays가 배열과 관련된 메서드를 제공하는 것처럼, Collections는 컬렉션과 관련된 메서드를 제공한다. fill(), copy(), sort(), binarySearch() 등의 메서드는 두 클래스에 포함되어 있으며 같은 기능을 한다.</p><h3 id="컬렉션의-동기화"><a href="#컬렉션의-동기화" class="headerlink" title="컬렉션의 동기화"></a>컬렉션의 동기화</h3><p>멀티 쓰레드 프로그래밍에서는 하나의 객체를 여러 쓰레드가 동시에 접근할 수 있기 때문에 데이터의 일관성(consistency)을 유지하기 위해서는 공유되는 객체의 동기화(synchronization)가 필요하다.</p><p>Vector와 Hashtable과 같은 구버전(JDK1.2 이전)의 클래스들은 자체적으로 동기화처리가 되어 있는데, 멀티쓰레드 프로그래밍이 아닌 경우에는 불필요한 기능이 되어 성능을 떨어뜨리는 요인이 된다.</p><p>그래서 새로 추가된 ArrayList와 HashMap과 같은 컬렉션은 동기화를 자체적으로 처리하지 않고 필요한 경우에만 java.util.Collections클래스의 동기화 메서드를 이용해서 동기화처리가 가능하도록 변경하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Collection <span class="title">synchronizedCollection</span><span class="params">(Collection c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List <span class="title">synchronizedList</span><span class="params">(List list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Set <span class="title">synchronizedSet</span><span class="params">(Set s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Map <span class="title">synchronizedMap</span><span class="params">(Map m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SortedSet <span class="title">synchronizedSortedSet</span><span class="params">(SortedSet s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SortedMap <span class="title">synchronizedSortedMap</span><span class="params">(SortedMap m)</span></span></span><br></pre></td></tr></table></figure><h3 id="변경불가-컬렉션-만들기"><a href="#변경불가-컬렉션-만들기" class="headerlink" title="변경불가 컬렉션 만들기"></a>변경불가 컬렉션 만들기</h3><p>컬렉션에 저장된 데이터를 보호하기 위해서 컬렉션을 변경할 수 없게 읽기전용으로 만들어야 할 때가 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Collection <span class="title">unmodifiableCollection</span><span class="params">(Collection c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List <span class="title">unmodifiableList</span><span class="params">(List list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Set <span class="title">unmodifiableSet</span><span class="params">(Set s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Map <span class="title">unmodifiableMap</span><span class="params">(Map m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SortedSet <span class="title">unmodifiableSortedSet</span><span class="params">(SortedSet s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SortedMap <span class="title">unmodifiableSortedMap</span><span class="params">(SortedMap m)</span></span></span><br></pre></td></tr></table></figure><h2 id="컬렉션-클래스-정리-amp-요약"><a href="#컬렉션-클래스-정리-amp-요약" class="headerlink" title="컬렉션 클래스 정리 &amp; 요약"></a>컬렉션 클래스 정리 &amp; 요약</h2><ul><li><strong>ArrayList</strong> : 배열기반, 데이터의 추가와 삭제에 불리, 순차적인 추가/삭제는 제일 빠름. 임의의 요소에 대한 접근성이 뛰어남.</li><li><strong>LinkedList</strong> : 연결기반, 데이터의 추가와 삭제에 유리. 임의의 요소에 대한 접근성이 좋지 않다.</li><li><strong>HashMap</strong> : 배열과 연결이 결합된 형태. 추가, 삭제, 검색, 접근성이 모두 뛰어남. 검색에는 최고성능을 보인다.</li><li><strong>TreeMap</strong> : 연결기반, 정렬과 검색(특히 범위검색)에 적합. 검색성능은 HashMap보다 떨어짐.</li><li><strong>Stack</strong> : Vector를 상속받아 구현</li><li><strong>Queue</strong> : LinkedList가 Queue인터페이스를 구현</li><li><strong>Properties</strong> : Hashtable을 상속받아 구현(String, String)</li><li><strong>HashSet</strong> : HashMap을 이용해서 구현</li><li><strong>TreeSet</strong> : TreeMap을 이용해서 구현</li><li><strong>LinkedHashMap, LinkedHashSet</strong> : HashMap과 HashSet에 저장순서유지기능을 추가하였음.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;해당 포스팅의 내용은 &lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788995379431&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://jongmin92.github.io/categories/Programming/Java/"/>
    
    
      <category term="Java" scheme="https://jongmin92.github.io/tags/Java/"/>
    
      <category term="Collection" scheme="https://jongmin92.github.io/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>날짜와 시간 &amp; 형식화</title>
    <link href="https://jongmin92.github.io/2018/06/06/Java/java-date-time/"/>
    <id>https://jongmin92.github.io/2018/06/06/Java/java-date-time/</id>
    <published>2018-06-06T13:35:00.000Z</published>
    <updated>2018-06-10T10:25:35.354Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>해당 포스팅의 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788995379431" target="_blank" rel="noopener">Java의 정석 2권 - Chapter 10 날짜와 시간 &amp; 형식화</a>에 있는 내용을 요약한 것입니다. 해당 책으로 복습하며 정리한 내용이고 문제가 된다면 바로 해당 포스팅을 삭제하도록 하겠습니다.</strong></p></blockquote><h1 id="날짜와-시간-amp-형식화"><a href="#날짜와-시간-amp-형식화" class="headerlink" title="날짜와 시간 &amp; 형식화"></a>날짜와 시간 &amp; 형식화</h1><h2 id="타임존-포함-iso-8601-문자열의-표현"><a href="#타임존-포함-ISO-8601-문자열의-표현" class="headerlink" title="타임존 포함 ISO 8601 문자열의 표현"></a>타임존 포함 ISO 8601 문자열의 표현</h2><p>날짜/시간 및 타임존을 다루는 국제적인 규약은 다양하다. <strong>RFC 822, 1036, 1123, 2822, 3339, ISO 8601</strong> 등이 있다. 여기서는 <code>ISO 8601</code>과 <code>RFC 3339</code>와 관련된 표기법을 알아본다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 로컬 시간을 의미하는 ISO 8601 문자열</span><br><span class="line">2017-11-06T15:00:00.000</span><br><span class="line"></span><br><span class="line">// UTC(GMT) 시간을 의미하는 ISO 8601 문자열</span><br><span class="line">2017-11-06T06:00:00.000Z</span><br><span class="line"></span><br><span class="line">// 로컬 시간을 의미하면서 UTC(GMT) 대비 +09:00 임을 의미하는 ISO 8601 문자열</span><br><span class="line">2017-11-06T15:00:00.000+09:00</span><br></pre></td></tr></table></figure><ul><li><code>2017-11-06T15:00:00.000</code>은 <strong>ISO 8601</strong>의 기본 형식이다. 해당 시간이 로컬 시간 임을 의미한다.</li><li><code>2017-11-06T06:00:00.000Z</code>와 같이 뒤에 <code>Z</code> 식별자를 추가하면 해당 시간이 <strong>UTC(GMT)</strong> 시간 임을 의미한다.</li><li><code>2017-11-06T15:00:00.000+09:00</code>와 같이 뒤에 <strong>Z</strong> 대신 <code>+HH:mm</code> 식별자를 추가하면 해당 시간이 로컬 시간이면서 <strong>UTC(GMT)</strong>와 <strong>09:00</strong> 만큼 차이가 남을 의미한다. 이 형식의 장점은 인간이 손쉽게 추가적인 계산 없이 로컬 시간을 인지하면서 추가적으로 타임존 정보까지 제공하기 때문에 가장 인간친화적이라고 할 수 있다.</li></ul><h2 id="날짜와-시간"><a href="#날짜와-시간" class="headerlink" title="날짜와 시간"></a>날짜와 시간</h2><p><code>Date</code>는 날짜와 시간을 다룰 목적으로 JDK 1.0부터 제공되어온 클래스이다. Date 클래스는 기능이 부족했기 때문에, <code>Calendar</code>라는 새로운 클래스를 그 다음 버젼인 JDK 1.1부터 제공하기 시작했다. Calendar는 Date보다는 훨씬 나았지만 몇 가지 단점들이 있었고, JDK 1.8부터 <code>java.time 패키지</code>로 기존의 단점들을 개선한 새로운 클래스들이 추가되었다.</p><blockquote><p>Date 클래스는 java.util 패키지에 속해있다.</p></blockquote><p><strong>Date와 Calendar간의 변환</strong></p><p>Calendar가 새로 추가되면서 Date는 대부분의 메서드가 ‘deprecated’되었으므로 잘 사용되지 않는다. 그럼에도 불구하고 여전히 Date를 필요로 하는 메서드들이 존재하기 때문에 Calendar를 Date로 또는 그 반대로 변환할 일이 생긴다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. Calendar를 Date로 변환</span><br><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line">Date d1 = <span class="keyword">new</span> Date(cal.getTimeInMillis()); <span class="comment">// Date(long date)</span></span><br><span class="line">Date d2 = cal.getTime();</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. Date를 Calendar로 변환</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line">cal.setTime(d);</span><br></pre></td></tr></table></figure><p>Calendar.getInstance()를 통해서 얻은 인스턴스는 기본적으로 현재 시스템의 날짜와 시간에 대한 정보를 담고 있다. (GregorianCalendar, BuddhistCalendar)</p><h2 id="형식화-클래스"><a href="#형식화-클래스" class="headerlink" title="형식화 클래스"></a>형식화 클래스</h2><p>자바의 형식화 클래스는 java.text 패키지에 포함되어 있으며 숫자, 날짜, 텍스트 데이터를 일정한 형식에 맞게 표현할 수 있는 방법을 객체지향적으로 설계하여 표준화하였다. 형식화 클래스는 형식화에 사용될 패턴을 정의하는데, 데이터를 정의된 패턴에 맞춰 형식화할 수 있을 뿐만 아니라 역으로 형식화된 데이터에서 원래의 데이터를 얻어낼 수도 있다. 즉, 형식화된 데이터의 패턴만 정의해주면 복잡한 문자열에서도 substring()을 사용하지 않고도 쉽게 원하는 값을 얻어낼 수 있다는 것이다.</p><h3 id="decimalformat"><a href="#DecimalFormat" class="headerlink" title="DecimalFormat"></a>DecimalFormat</h3><p>형식화 클래스 중에서 숫자를 형식화 하는데 사용되는 것이 DecimalFormat이다. DecimalFormat을 이용하면 숫자 데이터를 정수, 부동소수점, 금액 등의 다양한 형식으로 표현할 수 있으며, 반대로 일정한 형식의 테스트 데이터를 숫자로 쉽게 변환하는 것도 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> number = <span class="number">1234567.89</span>;</span><br><span class="line">DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">"#.#E0"</span>);</span><br><span class="line">String result = df.format(number);</span><br></pre></td></tr></table></figure><blockquote><p>Number 클래스는 Integer, Double과 같은 숫자를 저장하는 래퍼 클래스의 조상이며, doubleValue()는 Number에 저장된 값을 double형의 값으로 변환하여 반환한다. 이 외에도 intValue(), floatValue()등의 메서드가 Number클래스에 정의되어 있다.</p></blockquote><h3 id="simpledateformat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><p>Date와 Calendar만으로는 날짜 데이터를 원하는 형태로 다양하게 출력하는 것은 불편하고 복잡하다. 그러나 SimpleDateFormat을 사용하면 이러한 문제들이 간단하게 해결된다.</p><blockquote><p>DateFormat은 추상클래스로 SimpleDateFormat의 조상이다. DateFormat는 추상클래스이므로 인스턴스를 생성하기 위해서는 getDateInstance()와 같은 static 메서드를 이용해야 한다. getDateInstance()에 의해서 반환되는 것은 DateFormat을 상속받아 완전하게 구현한 SimpleDateFormat 인스턴스이다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date today = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat dt = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 오늘 날짜를 yyyy-MM-dd 형태로 변환하여 반환한다.</span></span><br><span class="line">String result = df.format(today);</span><br></pre></td></tr></table></figure><p>Date 인스턴스만 format 메서드에 사용될 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy년 MM월 dd일"</span>);</span><br><span class="line">Date d = df.parse(<span class="string">"2018년 6월 6일"</span>);</span><br></pre></td></tr></table></figure><p>parse(String source)를 사용하여 날짜 데이터의 출력형식을 변환하는 방법을 보여주는 예제이다. Integer의 parseInt()가 문자열을 정수로 변환하는 것처럼 SimpleDateFormat의 parse(String source)는 문자열(source)을 날짜(Date인스턴스)로 변환해주기 때문에 매우 유용하게 쓰일 수 있다.</p><h3 id="choiceformat"><a href="#ChoiceFormat" class="headerlink" title="ChoiceFormat"></a>ChoiceFormat</h3><p>ChoiceFormat은 특정 범위에 속하는 값을 문자열로 변환해준다. 연속적 또는 불연속적인 범위의 값들을 처리하는 데 있어서 if문이나 switch문은 적절하지 못한 경우가 많다. 이럴때 ChoiceFormat을 잘 사용하면 복잡하게 처리될 수밖에 없었던 코드를 간단하고 직관적으로 만들 수 있다.</p><h3 id="messageformat"><a href="#MessageFormat" class="headerlink" title="MessageFormat"></a>MessageFormat</h3><p>MessageFormat은 데이터를 정해진 양식에 맞게 출력할 수 있도록 도와준다. 데이터가 들어갈 자리를 마련해 놓은 양식을 미리 작성하고 프로그램을 이용해서 다수의 데이터를 같은 양식으로 출력할 때 사용하면 좋다. 하나의 데이터를 다양한 양식으로 출력할 때 사용한다.</p><p>그리고 SimpleDateFormat의 parse처럼 MessageFormat의 parse를 이용하면 지정된 양식에서 필요한 데이터만을 손쉽게 추출해 낼 수도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String msg = <span class="string">"Name: &#123;0&#125; \nTel: &#123;1&#125; \nnAge:&#123;2&#125; \nBirthday:&#123;3&#125;"</span>;</span><br><span class="line">Object[] arguments = &#123;<span class="string">"이름"</span>, <span class="string">"01-234-5678"</span>, <span class="string">"27"</span>, <span class="string">"04-27"</span>&#125;;</span><br><span class="line"></span><br><span class="line">String result = MessageFormat.format(msg, arguments);</span><br></pre></td></tr></table></figure><p>MessageFormat에 사용될 양식인 문자열 msg를 작성할 때 ‘{숫자}’로 표시된 부분이 데이터가 출력될 자리이다.</p><p>데이터를 양식에 넣어서 출려하는것 뿐만 아니라, parse(String source)를 이용해서 출력된 데이터로부터 필요한 데이터만을 뽑아낼 수 있다.</p><h2 id="javatime-패키지"><a href="#Java-time-패키지" class="headerlink" title="Java.time 패키지"></a>Java.time 패키지</h2><p>java의 탄생부터 지금까지 날짜와 시간을 다루는데 사용해왔던, Date와 Calendar가 가지고 있던 단점들을 해소하기 위해 JDK1.8부터 ‘java.time 패키지’가 추가되었다. 이 패키지는 다음과 같이 4개의 하위 패키지를 가지고 있다.</p><ul><li>java.time : 날짜와 시간을 다루는데 필요한 핵심 클래스들을 제공<ul><li>java.time.chrono : 표준(ISO)이 아닌 달력 시스템을 위한 클래스들을 제공</li><li>java.time.format : 날짜와 시간을 파싱하고, 형식화하기 위한 클래스들을 제공</li><li>java.time.temporal : 날짜와 시간의 필드(field)와 단위(unit)를 위한 클래스들을 제공</li><li>java.time.zone : 시간대(time-zone)와 관련된 클래스들을 제공</li></ul></li></ul><p>위의 패키지들에 속한 클래스들의 가장 큰 특징은 String 클래스처럼 <strong>불변(immutable)</strong>이라는 것이다. 그래서 날짜나 시간을 변경하는 메서드들은 기존의 객체를 변경하는 대신 항상 변경된 새로운 객체를 반환한다. 기존 Calendar 클래스는 변경 가능하므로, 멀티 쓰레드 환경에서 안전하지 못하다.</p><blockquote><p>멀티 쓰레드 환경에서는 동시에 여러 쓰레드가 같은 개겣에 접근할 수 있기 때문에, 변경 가능한 객체는 데이터가 잘못될 가능성이 있으며, 이를 쓰레드에 안전(thread-safe)하지 않다고 한다.</p></blockquote><h3 id="javatime-패키지의-핵심-클래스"><a href="#java-time-패키지의-핵심-클래스" class="headerlink" title="java.time 패키지의 핵심 클래스"></a>java.time 패키지의 핵심 클래스</h3><p><strong>날짜와 시간을 하나로 표현하는 Calendar 클래스와 달리, java.time 패키지에서는 날짜와 시간을 별도의 클래스로 분리해 놓았다.</strong> 시간을 표현할 때는 <code>LocalTime</code> 클래스를 사용하고, 날짜를 표현할 때는 <code>LocalDate</code> 클래스를 사용한다. 그리고 날짜와 시간이 모두 필요할 때는 <code>LocalDateTime</code> 클래스를 사용하면 된다.</p><blockquote><p>LocalDate + LocalTime -&gt; LocalDateTime<br>     날짜                시간               날짜 &amp; 시간</p></blockquote><p>여기에 시간대(time-zone)까지 다뤄야 한다면, <code>ZonedDateTime</code> 클래스를 사용한다.</p><blockquote><p>LocalDateTime + 시간대 -&gt; ZonedDateTime</p></blockquote><p>Calendar는 ZonedDateTime처럼, 날짜와 시간 그리고 시간대까지 모두 가지고 있다. Date와 유사한 클래스로는 <code>Instant</code>가 있는데, 이 클래스는 날짜와 시간을 초 단위(정확히는 나노초)로 표현한다. <strong>날짜와 시간을 초단위로 표현한 값을 <code>타임스탬프(time-stamp)</code> 라고 부르는데, 이 값은 날짜와 시간을 하나의 정수로 표현할 수 있으므로 날짜와 시간의 차이를 계산하거나 순서를 비교하는데 유리해서 데이터베이스에 많이 사용한다.</strong></p><p><strong>객체 생성하기 - now(), of()</strong></p><p>java.time 패키지에 속한 클래스의 객체를 생성하는 가장 기본적인 방법은 now()와 of()를 사용하는 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.now(); <span class="comment">// 2018-06-06</span></span><br><span class="line">LocalTime time = LocalTime.now(); <span class="comment">// 02:34:50.223</span></span><br><span class="line">LocalDateTime dateTime = LocalDateTime.now(); <span class="comment">// 2018-06-06T02:34:50.223</span></span><br><span class="line">ZonedDateTime dateTimeInKr = ZonedDateTime.now(); <span class="comment">// 2018-06-06T02:34:50.223+09:00[Asia/Seoul]</span></span><br></pre></td></tr></table></figure><h3 id="localdate와-localtime"><a href="#LocalDate와-LocalTime" class="headerlink" title="LocalDate와 LocalTime"></a>LocalDate와 LocalTime</h3><p><code>LocalDate</code>와 <code>LocalTime</code>은 java.time 패키지의 가장 기본이 되는 클래스이며, 나머지 클래스들은 이들의 확장이므로 이 두 클래스만 잘 이해하고 나면 나머지는 아주 쉬워진다.</p><p>객체를 생성하는 방법은 현재의 날짜와 시간을 LocalDate와 LocalTime으로 각각 반환하는 now()와 지정된 날짜와 시간으로 LocalDate와 LocalTime 객체를 생성하는 of()가 있다.</p><ul><li>특정 필드의 값 가져오기 - get(), getXXX()</li><li>필드의 값 변경하기 - with(), plus(), minus()</li><li>날짜와 시간의 비교 - isAfter(), isBefore(), isEqual()</li></ul><h3 id="instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><p><code>Instant</code>는 에포크 타임(EPOCH TIME, 1970-01-01 00:00:00 UTC)부터 경과된 시간을 나노초 단위로 표현한다. 사람이 보기에는 불편하지만, 단일 진법으로 다루기 때문에 계산에는 편리하다. 사람이 사용하는 날짜와 시간에는 여러 진법이 섞여있어서 계산하기 어렵다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Instant now = Instant.now();</span><br><span class="line">Instant now2 = Instant.ofEpochSecond(now.getEpochSecond());</span><br><span class="line">Instant now3 = Instant.ofEpochSecond(now.getEpochSecond(), now.getNano());</span><br></pre></td></tr></table></figure><p>Instant를 생성할 때는 위와 같이 now()와 ofEpochSecond()를 사용한다. 그리고 필드에 저장된 값을 가져올 때는 다음과 같이 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long epochSec = now.getEpochSecond();</span><br><span class="line">int nano = now.getNano();</span><br></pre></td></tr></table></figure><p>위의 코드처럼, Instant는 시간을 초 단위와 나노초 단위로 나누어 저장한다. 오라클 데이터베이스의 타임스탬프(timestamp)처럼 밀리초 단위의 EPOCH TIME을 필요로 하는 경우를 위해 toEpochMilli()가 정의되어 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">toEpochMilli</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>Instant는 항상 UTC(+00:00)를 기준으로 하기 때문에, LocalTime과 차이가 있을 수 있다.</strong> 예를 들어 한국은 시간대가 ‘+09:00’이므로 Instant와 LocalTime간에는 9시간의 차이가 있다. 시간대를 고려해야하는 경우 OffsetDateTime을 사용하는 것이 더 나은 선택일 수 있다.</p><blockquote><p>UTC는 ‘Coordinated Universal Time’의 약어로 ‘세계 협정시’이라고 하며, 1972년 1월 1일부터 시행된 국제 표준시이다. 이전에 사용되던 GMT(Greenwich Mean Time)와 UTC는 거의 같지만, UTC가 좀 더 정확하다.</p></blockquote><h3 id="localdatetime과-zoneddatetime"><a href="#LocalDateTime과-ZonedDateTime" class="headerlink" title="LocalDateTime과 ZonedDateTime"></a>LocalDateTime과 ZonedDateTime</h3><p>LocalDateTime에 시간대(time-zone)를 추가하면, ZonedDateTime이 된다. 기존에는 TimeZone클래스로 시간대를 다뤘지만 새로운 시간 패키지에서는 ZoneId라는 클래스를 사용한다. ZoneId는 일광 절약시간(DST, Daylight Saving Time)을 자동적으로 처리해주므로 더 편리하다.</p><p>LocalDate에 시간 정보를 추가하는 atTime()을 쓰면 LocalDateTime을 얻을 수 있는 것처럼, LocalDateTime에 atZone()으로 시간대 정보를 추가하면, ZonedDateTime을 얻을 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZoneId zid = ZoneId.of(<span class="string">"Asia/Seoul"</span>);</span><br><span class="line">zonedDateTime zdt = dateTime.atZone(zid);</span><br><span class="line">Syste.out.println(zdt); <span class="comment">// 2018-06-06T14:23:50.235+09:00[Asia/Seoul]</span></span><br></pre></td></tr></table></figure><p>만일 현재 특정 시간대의 시간, 예를 들어 뉴욕을 알고 싶다면 다음과 같이 하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZoneId nyId = ZoneId.of(<span class="string">"America/New_York"</span>);</span><br><span class="line">ZonedDateTime nyTime = ZonedDateTime.now().withZoneSameInstant(nyId);</span><br></pre></td></tr></table></figure><p><strong>ZoneOffSet</strong></p><p>UTC로부터 얼마만큼 떨어져 있는지를 ZoneOffSet으로 표현한다. 위의 결과에서 알 수 있듯이 서울은 ‘+9’이다. 즉, UTC보다 9시간(32400초=60*60*9)이 빠르다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZoneOffset krOffset = ZonedDateTime.now().getOffset();</span><br><span class="line"><span class="keyword">int</span> krOffsetInSec = KrOffset.get(ChronoField.OFFSET_SECONDS); <span class="comment">// 32400초</span></span><br></pre></td></tr></table></figure><p><strong>OffsetDateTime</strong></p><p>ZonedDateTime은 ZoneId로 구역을 표현하는데, ZoneId가 아닌 ZoneOffset을 사용하는 것이 OffSetDateTime이다. ZoneId는 일광절약시간처럼 시간대와 관련된 규칙들을 포함하고 있는데, ZoneOffset은 단지 시간대를 시간의 차이로만 구분한다. 컴퓨터에게 일광절약시간처럼 계절별로 시간을 더했다 뺐다 하는 것과 같은 행위는 위험하다. 아무런 변화 없이 일관된 시간체계를 유지하는 것이 더 안전하다. <strong>같은 지역 내의 컴퓨터 간에 데이터를 주고 받을 때, 전송시간을 표현하기에 LocalDateTime이면, 충분하겠지만, 서로 다른 시간대에 존재하는 컴퓨터간의 통신에는 OffsetDateTime이 필요하다.</strong></p><blockquote><p><strong>일광 절약 시간제</strong>(Daylight saving time, DST) 또는 <strong>서머 타임</strong>(summer time)은 하절기에 표준시를 원래 시간보다 한 시간 앞당긴 시간을 쓰는 것을 말한다. 즉, 0시에 일광 절약 시간제를 실시하면 1시로 시간을 조정해야 하는 것이다. 실제 낮 시간과 사람들이 활동하는 낮 시간 사이의 격차를 줄이기 위해 사용한다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime zdt = ZondedDateTime.of(date, time, zid);</span><br><span class="line">OffsetDateTime odt = offsetDateTime.of(date, time, krOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZonedDatetime -&gt; OffsetDateTime</span></span><br><span class="line">OffsetDateTime odt = zdt.toOffsetDateTime();</span><br></pre></td></tr></table></figure><p>OffsetDateTime을 ZonedDateTime처럼, LocalDate와 LocalTime에 ZonedOffset을 더하거나, ZonedDateTime에 toOffsetDateTime()을 호출해서 얻을 수도 있다.</p><p>지금까지의 내용을 예제로 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LocalDate ld = LocalDate.now();</span><br><span class="line">LocalTime lt = LocalTime.now();</span><br><span class="line">System.out.println(<span class="string">"LocalDate : "</span> + ld);</span><br><span class="line">System.out.println(<span class="string">"LocalTime : "</span> +lt);</span><br><span class="line"></span><br><span class="line">LocalDateTime dt = LocalDateTime.of(ld, lt);</span><br><span class="line">System.out.println(<span class="string">"LocalDateTime : "</span> + dt);</span><br><span class="line"></span><br><span class="line">ZoneId zid = ZoneId.of(<span class="string">"Asia/Seoul"</span>);</span><br><span class="line">ZonedDateTime zdt = dt.atZone(zid);</span><br><span class="line">System.out.println(<span class="string">"ZonedDateTime1 : "</span> + zdt);</span><br><span class="line"></span><br><span class="line">ZonedDateTime seoulTime = ZonedDateTime.now();</span><br><span class="line">System.out.println(<span class="string">"ZonedDateTime2 : "</span> + seoulTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 특정 구역 시간의 다른 구역 시간 구하기</span></span><br><span class="line">ZoneId nyId = ZoneId.of(<span class="string">"America/New_York"</span>);</span><br><span class="line">ZonedDateTime nyTime = ZonedDateTime.now().withZoneSameInstant(nyId);</span><br><span class="line">System.out.println(<span class="string">"ZonedDateTime3 : "</span> + nyTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 출력 결과</span></span><br><span class="line">LocalDate : <span class="number">2018</span>-<span class="number">06</span>-<span class="number">06</span></span><br><span class="line">LocalTime : <span class="number">10</span>:<span class="number">28</span>:<span class="number">37.743</span></span><br><span class="line">LocalDateTime : <span class="number">2018</span>-<span class="number">06</span>-<span class="number">06</span>T10:<span class="number">28</span>:<span class="number">37.743</span></span><br><span class="line">ZonedDateTime1 : <span class="number">2018</span>-<span class="number">06</span>-<span class="number">06</span>T10:<span class="number">28</span>:<span class="number">37.743</span>+<span class="number">09</span>:<span class="number">00</span>[Asia/Seoul]</span><br><span class="line">ZonedDateTime2 : <span class="number">2018</span>-<span class="number">06</span>-<span class="number">06</span>T10:<span class="number">28</span>:<span class="number">37.744</span>+<span class="number">09</span>:<span class="number">00</span>[Asia/Seoul]</span><br><span class="line">ZonedDateTime3 : <span class="number">2018</span>-<span class="number">06</span>-<span class="number">05</span>T21:<span class="number">28</span>:<span class="number">37.747</span>-<span class="number">04</span>:<span class="number">00</span>[America/New_York]</span><br></pre></td></tr></table></figure><h3 id="temporaladjusters"><a href="#TemporalAdjusters" class="headerlink" title="TemporalAdjusters"></a>TemporalAdjusters</h3><p>plus(), minus()와 같은 메서드로 날짜와 시간을 계산하기에는 불편한 경우가 있다. (Ex. 이번 달의 3번째 금요일) 그래서 자주 쓰일만한 날짜 계산들을 대신 해주는 메서드를 정의해놓은 것이 TemporalAdjusters 클래스이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate nextMonday = today.with(TemporalAdjusters.next(DayofWeek.MONDAY))l</span><br></pre></td></tr></table></figure><p>with()는 LocalTime, LocalDateTime, ZonedDateTime, Instant 등 대부분의 날짜와 시간에 관련된 클래스에 포함되어 있다.</p><h3 id="period와-duration"><a href="#Period와-Duration" class="headerlink" title="Period와 Duration"></a>Period와 Duration</h3><p><code>Period</code>는 날짜의 차이를, <code>Duration</code>은 시간의 차이를 계산하기 위한 것이다.</p><p><strong>between()</strong></p><p>두 날짜 date1과 date2의 차이를 나타내는 Period는 between()으로 얻을 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">LocalDate date2 = LocalDate.of(<span class="number">2018</span>, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">Period pe = Period.between(date1, date2)</span><br></pre></td></tr></table></figure><p>date1이 date2보다 날짜 상으로 이전이면 양수로, 이후면 음수로 Period에 저장된다. 그리고 시간차이를 구할 때는 Duration을 사용한다는 것을 제외하고는 Period와 똑같다.</p><p>Period, Duration에서 특정 필드의 값을 얻을 때는 get()을 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> year = pe.get(ChronoUnit.YEARS); <span class="comment">// int getYears()</span></span><br><span class="line"><span class="keyword">long</span> month = pe.get(ChronoUnit.MONTHS); <span class="comment">// int getMonths()</span></span><br><span class="line"><span class="keyword">long</span> day = pe.get(ChronoUnit.DAYS); <span class="comment">// int getDays()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> sec = du.get(ChronoUnit.SECONDS); <span class="comment">// long getSeconds()</span></span><br><span class="line"><span class="keyword">long</span> nano = du.get(ChronoUnit.NANOS); <span class="comment">// int getNano()</span></span><br></pre></td></tr></table></figure><p><strong>between()과 until()</strong></p><p>until()은 between()과 거의 같은 일을 한다. between()은 static 메서드이고, until()은 인스턴스 메서드라는 차이가 있다.</p><p>Period는 년월일을 분리해서 저장하기 때문에, D-day를 구하려는 경우에는 두 개의 매개변수를 받는 until()을 사용하는 것이 낫다.</p><h3 id="파싱과-포맷"><a href="#파싱과-포맷" class="headerlink" title="파싱과 포맷"></a>파싱과 포맷</h3><p>날짜와 시간을 원하는 형식으로 출력하고 해석(파싱)을 위한 형식화(formatting)와 관련된 클래스들은 java.time.format 패키지에 들어 있다. 그 중에서 <code>DateTimeFormatter</code>가 핵심이다. 이 클래스에는 자주 쓰이는 다양한 형식들을 기본적으로 정의하고 있으며, 그 외의 형식이 필요하다면 직접 정의해서 사용할 수도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">String yyyymmdd = DateTimeFormatter.ISO_LOCAL_DATE.format(date); <span class="comment">// "2016-06-06"</span></span><br><span class="line">String yyyymmdd = date.format(DateTimeFormatter.ISO_LOCAL_DATE); <span class="comment">// "2018-06-06</span></span><br></pre></td></tr></table></figure><p>날짜와 시간의 형식화에는 format()이 사용되는데, 이 메서드는 DateTimeFormatter뿐만 아니라 LocalDate나 LocalTime같은 클래스에도 있다. 같은 기능을 하기 때문에 상황에 따라 편한 쪽을 선택해서 사용하면 된다.</p><p><strong>문자열을 날짜와 시간으로 파싱하기</strong></p><p>문자열을 날짜 또는 시간으로 변환하려면 static 메서드 parse()를 사용하면 된다. 자주 사용되는 기본적인 형식의 문자열은 ISO_LOCAL_DATE와 같은 형식화 상수를 사용하지 않고도 파싱이 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.parse(<span class="string">"2018-06-06"</span>, DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">LocalDate newDate = LocalDate.parse(<span class="string">"2018-06-06"</span>);</span><br><span class="line">LocalTime newTime = LocalTime.parse(<span class="string">"23:59:59"</span>);</span><br><span class="line">LocalDateTime newDateTime = LocalDateTime.parse(<span class="string">"2018-06-06T23:59:59"</span>);</span><br></pre></td></tr></table></figure><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="http://jsonobject.tistory.com/403" target="_blank" rel="noopener">Java 8, 타임존이 포함된 ISO 8601 문자열을 LocalDateTime으로 변환하기</a></li><li><a href="https://wickso.me/2018/02/20/time-zone-with-java8/#Java8%EC%9D%98-%ED%83%80%EC%9E%84%EC%A1%B4" target="_blank" rel="noopener">Java8에서 타임존(Time-Zone) 다루기</a></li><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788995379431" target="_blank" rel="noopener">Java의 정석 - 2</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;해당 포스팅의 내용은 &lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788995379431&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://jongmin92.github.io/categories/Programming/Java/"/>
    
    
      <category term="Java" scheme="https://jongmin92.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>토비의 스프링 8장 (스프링이란 무엇인가?)</title>
    <link href="https://jongmin92.github.io/2018/05/20/Spring/toby-8/"/>
    <id>https://jongmin92.github.io/2018/05/20/Spring/toby-8/</id>
    <published>2018-05-20T12:00:00.000Z</published>
    <updated>2018-05-21T08:15:52.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="스프링이란-무엇인가"><a href="#스프링이란-무엇인가" class="headerlink" title="스프링이란 무엇인가?"></a>스프링이란 무엇인가?</h1><h2 id="스프링의-정의"><a href="#스프링의-정의" class="headerlink" title="스프링의 정의"></a>스프링의 정의</h2><p>스프링이란 어떤 것이다라고 한마디로 정의하기는 쉽지 않다. 스프링에 대해 가장 잘 알려진 정의는 이렇다.</p><p><strong>자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크</strong></p><p>정의를 봐도 스프링이 무엇인지 감이 바로 오지는 않는다. 하지만 이 정의에는 스프링의 중요한 특징이 잘 담겨 있다.</p><ul><li><p><strong>애플리케이션 프레임워크</strong></p><p>일반적으로 라이브러리나 프레임워크는 특정 업무 분야나 한 가지 기술에 특화된 목표를 가지고 만들어진다. 그러나 애플리케이션 프레임워크는 조금 다르다.<br>애플리케이션 프레임워크는 특정 계층이나, 기술, 업무 분야에 국한되지 않고 애플리케이션의 전 영역을 포괄하는 범용적인 프레임워크를 말한다. 애플리케이션 프레임워크는 애플리케이션 개발의 전 과정을 빠르고 편리하며 효율적으로 진행하는데 일차적인 목표를 두는 프레임워크다.<br>단지 여러 계층의 다양한 기술을 한데 모아뒀기 때문에 애플리케이션 프레임워크라고 불리는 건 아니다. 애플리케이션의 전 영역을 관통하는 일관된 프로그래밍 모델과 핵심 기술을 바탕으로 해서 각 분야의 특성에 맞는 필요를 채워주고 있기 때문이다.</p></li><li><p><strong>경량급</strong></p><p>스프링이 경량급이라는 건 스프링 자체가 아주 가볍다거나 작은 규모의 코드로 이뤄졌다는 뜻은 아니다.<br>그럼에도 가볍다고 하는 이유는 불필요하게 무겁지 않다는 의미다. 특히 스프링이 처음 등장하던 시절의 자바 주류 기술이었던 예전의 EJB 같은 과도한 엔지니어링이 적용된 기술과 스프링을 대비시켜 설명하려고 사용했던 표현이다.<br>스프링은 가장 단순한 서버환경인 톰캣(Tomcat)이나 제티(Jetty)에서도 완벽하게 동작한다. 단순한 개발툴과 기본적인 개발환경으로도 엔터프라이즈 개발에서 필요로 하는 주요한 기능을 갖춘 애플리케이션을 개발하기에 충분하다. 스프링의 장점은 그런 가볍고 단순한 환경에서도 복잡한 EJB와 고가의 WAS를 갖춰야만 가능했던 엔터프라이즈 개발의 고급 기술을 대부분 사용할 수 있다는 점이다.<br>결과적으로 스프링은 EJB를 대표로 하는 기존의 많은 기술이 불필요하게 무겁고 복잡했음을 증명한 셈이고, 그런 면에서 스프링은 군더더기 없이 깔끔한 기술을 가진 ‘경량급’ 프레임워크라고 불린 것이다.<br>만들어진 코드가 지원하는 기술수준은 비슷하더라도 그것을 훨씬 빠르고 간편하게 작성하게 해줌으로써 생산성과 품질 면에서 유리하다는 것이 바로 경량급이라는 말로 표현되는 스프링의 특징이다.</p></li><li><p><strong>자바 엔터프라이즈 개발을 편하게</strong></p><p>스프링은 근본적인 부분에서 엔터프라이즈 개발의 복잡함을 제거해내고 진정으로 개발을 편하게 해주는 해결책을 제시한다. 단순히 편리한 몇 가지 도구나 기능을 제공해주는 차원이 아니다.<br>편리한 애플리케이션 개발이란 개발자가 복잡하고 실수하기 쉬운 로우레벨 기술에 많은 신경을 쓰지 않으면서도 애플리케이션의 핵심인 사용자의 요구사항, 즉 비즈니스 로직을 빠르고 효과적으로 구현하는 것을 말한다.</p></li><li><p><strong>오픈소스</strong></p></li></ul><h2 id="스프링의-목적"><a href="#스프링의-목적" class="headerlink" title="스프링의 목적"></a>스프링의 목적</h2><p>스프링을 사용해서 엔터프라이즈 애플리케이션 개발을 편하게 하려는 이유는 뭘까? 원래 엔터프라이즈 개발이란 편하지 않기 때문이다.</p><h3 id="엔터프라이즈-개발의-복잡함"><a href="#엔터프라이즈-개발의-복잡함" class="headerlink" title="엔터프라이즈 개발의 복잡함"></a>엔터프라이즈 개발의 복잡함</h3><p>자바 엔터프라이즈(JavaEE) 개발이 실패하는 가장 대표적인 이유는 ‘엔터프라이즈 시스템 개발이 너무 복잡해져서’였다.</p><h4 id="복잡합의-근본적인-이유"><a href="#복잡합의-근본적인-이유" class="headerlink" title="복잡합의 근본적인 이유"></a><strong>복잡합의 근본적인 이유</strong></h4><p>엔터프라이즈 시스템 개발이 복잡한 원인은 크게 두 가지가 있다. (엔터프라이즈 시스템이란 서버에서 동작하며 기업과 조직의 업무를 처리해주는 시스템을 말한다.)</p><ul><li><strong>기술적인 제약조건과 요구사항이 늘어가기 때문이다.</strong></li><li><strong>엔터프라이즈 애플리케이션이 구현해야 할 핵심기능인 비즈니스 로직의 복잡함이 증가하기 때문이다.</strong></li></ul><p>전통적인 자바 엔터프라이즈 개발 기법은 대부분 비즈니스 로직의 복잡한 구현 코드와 엔터프라이즈 서비스를 이용하는 기술적인 코드가 자꾸 혼재될 수 밖에 없는 방식이었다. 결국 개발자가 동시에 그 두 가지를 모두 신경 써서 개발해야 하는 과도한 부담을 줬고, 그에 따라 전체적인 복잡함은 몇 배로 가중됐다.</p><h3 id="복잡함을-해결하려는-도전"><a href="#복잡함을-해결하려는-도전" class="headerlink" title="복잡함을 해결하려는 도전"></a>복잡함을 해결하려는 도전</h3><h4 id="제거될-수-없는-근본적인-복잡함"><a href="#제거될-수-없는-근본적인-복잡함" class="headerlink" title="제거될 수 없는 근본적인 복잡함"></a>제거될 수 없는 근본적인 복잡함</h4><p>엔터프라이즈 개발의 근본적인 복잡함의 원인은 제거할 대상은 아니다. 현실적으로는 불가능하기 때문이다.</p><p>근본적으로 엔터프라이즈 개발에 나타나는 복잡함의 원인은 제거 대상이 아니다. 대신 그 복잡함을 효과적으로 상대할 수 있는 전략과 기법이 필요하다. 문제는 비즈니스 로직의 복잡함을 효과적으로 다루기 위한 방법과 기술적인 복잡함을 효과적으로 처리하는 데 적용되는 방법이 다르다는 점이다. 따라서 두 가지 복잡함이 코드에 한데 어우러져 나타나는 전통적인 개발 방식에서는 효과적으로 복잡함을 다루기가 힘들다. 따라서 가장 먼저 할 일은 성격이 다른 이 두 가지 복잡함을 분리해내는 것이다.</p><h3 id="복잡함을-상대하는-스프링의-전략"><a href="#복잡함을-상대하는-스프링의-전략" class="headerlink" title="복잡함을 상대하는 스프링의 전략"></a>복잡함을 상대하는 스프링의 전략</h3><p>스프링의 기본적인 전략은 비즈니스 로직을 담은 애플리케이션 코드와 엔터프라이즈 기술을 처리하는 코드를 분리시키는 것이다. 이 분리를 통해 두 가지 복잡함의 문제를 효과적으로 공략하게 해준다.</p><h4 id="기술적-복잡함을-상대하는-전략"><a href="#기술적-복잡함을-상대하는-전략" class="headerlink" title="기술적 복잡함을 상대하는 전략"></a>기술적 복잡함을 상대하는 전략</h4><p>기술적인 복잡함을 분리해서 생각하면 그것을 효과적으로 상대할 수 있는 적절한 전략을 발견할 수 있다. 스프링은 엔터프라이즈 기술을 적용했을 때 발생하는 복잡함의 문제를 두 가지로 분류하고 각각에 대한 적절한 대응 방법을 제공한다.</p><ul><li><p><strong>첫 번째 문제 : 기술에 대한 접근 방식이 일관성이 없고, 특정 환경에 종속적이다.</strong></p><p>일관성 없는 기술과 서버환경의 변화에 대한 스프링의 공략 방법은 바로 서비스 추상화다. 앞에서 보았던 트랜잭션 추상화, OXM 추상화, 데이터 액세스에 관한 일관된 예외변환 기능, 데이터 액세스 기술에 독립적으로 적용 가능한 트랜잭션 동기화 기법 등이 대포적인 예다. 기술적인 복잡합은 일단 추상화를 통해 로우레벨의 기술 구현 부분과 기술을 사용하는 인터페이스를 분리하고, 환경과 세부기술에 독립적인 접근 인터페이스를 제공하는 것이 가장 좋은 해결책이다.</p></li><li><p><strong>두 번째 문제 : 기술적인 처리를 담당하는 코드가 성격이 다른 코드에 섞여서 등장한다.</strong></p><p>책임에 따라 계층을 구분하고 그 사이에 서로의 기술과 특성에 의존적인 인터페이스나 예외처리 등을 최대한 제거한다고 할지라도 근본적으로 엔터프라이즈 서비스를 적용하는 한 이런 문제는 쉽게 해결할 수 없다. 이런 기술과 비즈니스 로직의 혼재로 발생하는 복잡함을 해결하기 위한 스프링의 접근 방법은 바로 AOP다.<br>AOP는 최후까지 애플리케이션 로직을 담당하는 코드에 남아 있는 기술 관련 코드를 깔끔하게 분리해서 별도의 모듈로 관리하게 해주는 강력한 기술이다.</p></li></ul><h4 id="비즈니스와-애플리케이션-로직의-복잡함을-상대하는-전략"><a href="#비즈니스와-애플리케이션-로직의-복잡함을-상대하는-전략" class="headerlink" title="비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략"></a>비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략</h4><p>비즈니스 로직의 복잡함을 상대하는 전략은 자바라는 객체지향 기술 그 자체다. 스프링은 단지 객체지향 언어의 장점을 제대로 살리지 못하게 방해했던 요소를 제거하도록 도와줄 뿐이다.</p><h4 id="핵심-도구-객체지향과-di"><a href="#핵심-도구-객체지향과-DI" class="headerlink" title="핵심 도구 : 객체지향과 DI"></a>핵심 도구 : 객체지향과 DI</h4><p>객체지향의 설계 기법을 잘 적용할 수 있는 구조를 만들기 위해 DI 같은 유용한 기술을 편하게 적용하도록 도와주는 것이 스프링의 기본 전략이다.</p><p>지금까지 보았듯이 기술적인 복잡함을 효과적으로 다루게 해주는 기법은 모두 DI를 바탕으로 하고 있다. 서비스 추상화, 템플릿/콜백, AOP와 같은 스프링의 기술은 DI 없이는 존재할 수 없는 것들이다.</p><p>그리고 DI는 객체지향 설계 기술 없이는 그 존재의미가 없다. DI란 특별한 기술이라기보다는 유연하게 확장할 수 있는 오브젝트 설계를 하다 보면 자연스럽게 적용하게 되는 객체지향 프로그래밍 기법일 뿐이다. 스프링은 단지 그것을 더욱 편하고 쉽게 사용하도록 도와줄 뿐이다.</p><p>기술적인 복잡함을 해결하는 문제나 기술적인 복잡함이 비즈니스 로직에 침범하지 못하도록 분리하는 경우에도 DI가 바탕이 된 여러 가지 기법이 활용된다. 반면에 비즈니스 로직 자체의 복잡함을 해결하려면 DI보다는 객체지향 설계 기법이 더 중요하다.</p><h2 id="pojo-프로그래밍"><a href="#POJO-프로그래밍" class="headerlink" title="POJO 프로그래밍"></a>POJO 프로그래밍</h2><p>스프링 핵심 개발자들은 “스프링의 정수(essence)”는 엔터프라이즈 서비스 기능을 POJO에 제공하는 것”이라고 했다. 엔터프라이즈 서비스라고 하는 것은 보안, 트랜잭션과 같은 엔터프라이즈 시스템에서 요구되는 기술을 말한다. 이런 기술을 POJO에 제공한다는 말은, 뒤집어 생각해보면 엔터프라이즈 서비스 기술과 POJO라는 애플리케이션 로직을 담은 코드를 분리했다는 뜻이기도 하다. ‘분리됐지만 반드시 필요한 엔터프라이즈 서비스 기술을 POJO 방식으로 개발된 애플리케이션 핵심 로직을 담은 코드에 제공한다’는 것이 스프링의 가장 강력한 특징과 목표다.</p><h3 id="스프링의-핵심-pojo"><a href="#스프링의-핵심-POJO" class="headerlink" title="스프링의 핵심 : POJO"></a>스프링의 핵심 : POJO</h3><p>스프링 애플리케이션은 POJO를 이용해서 만든 애플리케이션 코드와, POJO가 어떻게 관계를 맺고 동작하는지를 정의해놓은 설계정보로 구분된다. DI의 기본 아이디어는 유연하게 확장 가능한 오브젝트를 만들어두고 그 관계는 외부에서 다이내믹하게 설정해준다는 것이다. 이런 DI의 개념을 애플리케이션 전반에 걸쳐 적용하는 것이 스프링의 프로그래밍 모델이다.</p><p>스프링의 주요 기술인 IoC/DI, AOP, 서비스추상화는 애플리케이션을 POJO로 개발할 수 있게 해주는 가능기술이라고 불린다.</p><h3 id="pojo란-무엇인가"><a href="#POJO란-무엇인가" class="headerlink" title="POJO란 무엇인가?"></a>POJO란 무엇인가?</h3><p><strong><code>POJO</code>는 Plain Old Java Object의 첫 글자를 따서 만든 약자다.</strong></p><h3 id="pojo의-조건"><a href="#POJO의-조건" class="headerlink" title="POJO의 조건"></a>POJO의 조건</h3><p>단순하게 보자면 그냥 평범한 자바오브젝트라고 할 수 있지만 좀 더 명확하게 하자면 적어도 다음의 조건을 충족해야 POJO라고 불릴 수 있다.</p><ul><li><p><strong>특정 규약에 종속되지 않는다.</strong></p><p>POJO는 자바 언어와 꼭 필요한 API 외에는 종속되지 않아야 한다. 따라서 EJB2와 같이 특정 규약을 따라 비즈니스 컴포넌트를 만들어야 하는 경우는 POJO가 아니다. 특정 규약을 따라 만들게 하는 경우는 대부분 규약에서 제시하는 특정 클래스를 상속하도록 요구한다. 그럴 경우 자바의 단일 상속 제한 때문에 더 이상 해당 클래스에 객체지향적인 설계 기법을 적용하기가 어려워지는 문제가 생긴다. 또한 규약이 적용된 환경에 종속적이 되기 때문에 다른 환경으로 이전이 힘들다는 문제점이 있다.</p></li><li><p><strong>특정 환경에 종속되지 않는다.</strong></p><p>어떤 경우는 특정 벤더의 서버나 특정 기업의 프레임워크 안에서만 동작 가능한 코드로 작성되기도 한다. 또 환경에 종속적인 클래스나 API를 직접 쓴 경우도 있다. 순수한 애플리케이션 로직을 담고 있는 오브젝트 코드가 특정 환경에 종속되게 만드는 경우라면 그것 역시 POJO라고 할 수 없다. POJO는 환경에 독립적이어야한다.<br>특히 비즈니스 로직을 담고 있는 POJO 클래스는 웹이라는 환경정보나 웹 기술을 담고 있는 클래스나 인터페이스를 사용해서는 안된다. 비즈니스 로직을 담은 코드에 HttpServletRequest나 HttpSession, 캐시와 관련된 API가 등장하거나 웹 프레임워크의 클래스를 직접 이용하는 부분이 있다면 그것은 진정한 POJO라고 볼 수 없다.<br>단지 자바의 문법을 지키고, 순수하게 JavaSE API만을 사용했다고 해서 그 코드를 POJO라고 할 수는 없다. POJO는 객체지향적인 자바 언어의 기본에 충실하게 만들어져야 하기 때문이다.</p></li></ul><h3 id="pojo의-장점"><a href="#POJO의-장점" class="headerlink" title="POJO의 장점"></a>POJO의 장점</h3><p>POJO가 될 수 있는 조건이 그대로 POJO의 장점이 된다.</p><p>특정한 기술과 환경에 종속되지 않는 오브젝트는 그만큼 깔끔한 코드가 될 수 있다. 로우레벨의 기술과 환경에 종속적인 코드가 비즈니스 로직과 함께 섞여 나오는 것만큼 지저분하고 복잡한 코드도 없다.</p><p>POJO로 개발된 코드는 자동화된 테스트에 매우 유리하다. 환경의 제약은 코드의 자동화된 테스트를 어렵게 한다. 컨테이너에서만 동작을 확인할 수 있는 EJB 2는 테스트하려면 서버의 구동 및 빌드와 배치 과정까지 필요하다. 자동화된 테스트가 불가능한 건 아니지만 매우 복잡하고 번거로우므로 대부분 수동 테스트 방식을 선호한다. 그에 반해 어떤 환경에도 종속되지 않은 POJO 코드는 매우 유연한 방식으로 원하는 레벨에서 코드를 빠르고 명확하게 테스트할 수 있다.</p><p>객체지향적인 설계를 자유롭게 적용할 수 있다는 것도 큰 장점이다.</p><h3 id="pojo-프레임워크"><a href="#POJO-프레임워크" class="headerlink" title="POJO 프레임워크"></a>POJO 프레임워크</h3><p>스프링은 POJO를 이용한 엔터프라이즈 애플리케이션 개발을 목적으로 하는 프레임워크이다. POJO 프로그래밍이 가능하도록 기술적인 기반을 제공하는 프레임워크를 POJO 프레임워크라고 한다. 스프링은 엔터프라이즈 애플리케이션 개발의 모든 영역과 계층에서 POJO 방식의 구현이 가능하게 하려는 목적으로 만들어졌다.</p><p>스프링을 이용하면 POJO 프로그래밍의 장점을 그대로 살려서 엔터프라이즈 애플리케이션의 핵심 로직을 객체지향적인 POJO를 기반으로 깔끔하게 구현하고, 동시에 엔터프라이즈 환경의 각종 서비스와 기술적인 필요를 POJO 방식으로 만들어진 코드에 적용할 수 있다.</p><p>스프링은 비즈니스 로직의 복잡함과 엔터프라이즈 기술의 복잡함을 분리해서 구성할 수 있게 도와준다. 하지만 자신은 기술영역에만 관여하지 비즈니스 로직을 담당하는 POJO에서는 모습을 감춘다. 데이터 액세스 로직이나 웹 UI 로직을 다룰 때만 최소한의 방법으로 관여한다. POJO 프레임워크로서 스프링은 자신을 직접 노출하지 않으면서 애플리케이션을 POJO로 쉽게 개발할 수 있게 지원해준다.</p><h2 id="스프링의-기술"><a href="#스프링의-기술" class="headerlink" title="스프링의 기술"></a>스프링의 기술</h2><h3 id="제어의-역전ioc-의존관계-주입di"><a href="#제어의-역전-IoC-의존관계-주입-DI" class="headerlink" title="제어의 역전(IoC) / 의존관계 주입(DI)"></a>제어의 역전(IoC) / 의존관계 주입(DI)</h3><p>왜 두 개의 오브젝트를 분리해서 만들고, 인터페이스를 두고 느슨하게 연결한 뒤, 실제 사용할 대상은 DI를 통해 외부에서 지정하는 것일까? 직접 자신이 사용할 오브젝트를 new 키워드로 생성해서 사용하는 강한 결합을 쓰는 방법보다 나은 점은 무엇일까?</p><p>가장 간단한 답변은 <strong>‘유연한 확징이 가능하게 하기 위함’</strong>이다. DI는 개방 폐쇄 원칙(OCP)이라는 객체지향 설계 원칙으로 잘 설명될 수 있다. 유연한 확장이라는 장점은 OCP의 ‘확장에는 열려 있다(개방)’에 해당한다. DI는 역시 OCP의 ‘변경에는 닫혀 있다(폐쇄)’라는 말로도 설명이 가능하다. 폐쇄 관점에서 볼 때 장점은 ‘재사용이 가능하다’라고 볼 수 있다.</p><h4 id="di의-활용-방법"><a href="#DI의-활용-방법" class="headerlink" title="DI의 활용 방법"></a>DI의 활용 방법</h4><ul><li><p><strong>핵심기능의 변경</strong></p><p>DI의 가장 대표적인 적용 방법은 바로 의존 대상의 구현을 바꾸는 것이다. 디자인 패턴의 전략 패턴이 대표적인 예다. 실제 의존하는 대상이 가진 핵심기능을 DI 설정을 통해 변경하는 것이 대표적인 DI의 활용 방법이다.</p></li><li><p><strong>핵심기능의 동적인 변경</strong></p><p>두 번째 활용 방법은 첫 번째랑 비슷하게 의존 오브젝트의 핵심 기능 자체를 바꾸는 것이다. DI도 기본적으로는 런타임 시에 동적으로 의존 오브젝트를 연결해주는 것이긴 하지만, 일단 DI 되고 나면 그 후로는 바뀌지 않는다. 즉 동적인 방식으로 연결되지만 한 번 DI되면 바뀌지 않는 정적인 관계를 맺어주는 것이다. 하지만 DI를 잘 활용하면 애플리케이션이 동작하는 중간에 그 의존 대상을 다이내믹하게 변경할 수 있다.</p></li><li><p><strong>부가기능의 추가</strong></p><p>세 번째 활용 방법은 핵심기능은 그대로 둔 채로 부가기능을 추가하는 것이다. 데코레이터 패턴을 생각해보면 된다. 인터페이스를 두고 사용하게 하고, 실제 사용할 오브젝트는 외부에서 주입하는 DI를 적용해두면 데코레이터 패턴을 쉽게 적용할 수 있다. 그래서 핵심기능과 클라이언트 코드에는 전혀 영향을 주지 않으면서 부가적인 기능을 얼마든지 추가할 수 있다.</p></li><li><p><strong>인터페이스의 변경</strong></p><p>사용하려고 하는 오브젝트가 가진 인터페이스가 클라이언트와 호환되지 않는 경우가 있다. 이렇게 클라이언트가 사용하는 인터페이스와 실제 오브젝트 사이에 인터페이스가 일치하지 않는 경우에도 DI가 유용하다. 디자인 패턴에서 말하는 오브젝트 방식의 어댑터 패턴의 응용이라고 볼 수 있다.<br>이를 좀 더 일반화해서 아예 인터페이스가 다른 다양한 구현을 같은 방식으로 사용하도록, 중간에 인터페이스 어댑터 역할을 해주는 레이어를 하나 추가하는 방법도 있다. 서비스 추상화(PSA)가 그런 방법이다. PSA는 클라이언트가 일관성 있게 사용할 수 있는 인터페이스를 정의해주고 DI를 통해 어댑터 역할을 하는 오브젝트를 이용하게 해준다. 이를 통해 다른 인터페이스를 가진 로우레벨의 기술을 변경하거나 확장해가면서 사용할 수 있는 것이다.</p></li><li><p><strong>프록시</strong></p><p>필요한 시점에서 실제 사용할 오브젝트를 초기화하고 리소스를 준비하게 해주는 지연된 로딩(lazy loading)을 적용하려면 프록시가 필요하다. 원격 오브젝트를 호출할 때 마치 로컬에 존재하는 오브젝트처럼 사용할 수 있게 해주는 원격 프록시를 적용하려고 할 때도 프록시가 필요하다. 두 가지 방법 모두 DI를 필요로 한다.</p></li><li><p><strong>템플릿과 콜백</strong></p><p>템플릿/콜백 패턴은 DI의 특별한 적용 방법이다. 반복적으로 등장하지만 항상 고정적인 작업 흐름과 그 사이에서 자주 바뀌는 부분을 분리해서 템플릿과 콜백으로 만들 고 이를 DI 원리를 응용해 적용하면 지저분하게 매번 만들어야 하는 코드를 간결하게 만들 수 있다.</p></li><li><p><strong>싱글톤과 오브젝트 스코프</strong></p><p>DI가 필요한 중요한 이유 중 한 가지는 DI 할 오브젝트의 생명주기를 제어할 수 있다는 것이다. DI를 프레임워크로 이용한다는 건 DI 대상 오브젝트를 컨테이너가 관리한다는 의미다. 오브젝트의 생성부터 관계 설정, 이용, 소멸에 이르기까지의 모든 과정을 DI 컨테이너가 주관하기 때문에 그 오브젝트의 스코프를 자유롭게 제어할 수 있다.<br>스프링의 DI는 기본적으로 싱글톤으로 오브젝트를 만들어서 사용하게 한다. 컨테이너가 알아서 싱글톤으로 만들고 관리하기 때문에 클래스 자체는 싱글톤을 고려하지 않고 자유롭게 설계해도 된다는 장점이 있다.</p></li><li><p><strong>테스트</strong></p><p>다른 오브젝트와 협력해서 동작하는 오브젝트를 효과적으로 테스트하는 방법은 가능한 한 고립시키는 것이다. 즉 다른 오브젝트와의 사이에서 일어나는 일을 테스트를 위해 조작할 수 있도록 만든다. 그래야만 테스트 대상인 오브젝트의 기능에 충실하게 테스트가 가능하다. 복잡한 테스트할 대상에 의존하는 오브젝트를, 테스트를 목적으로 만들어진 목 오브젝트로 대체하면 유용하다.</p></li></ul><h3 id="애스펙트-지향-프로그래밍aop"><a href="#애스펙트-지향-프로그래밍-AOP" class="headerlink" title="애스펙트 지향 프로그래밍(AOP)"></a>애스펙트 지향 프로그래밍(AOP)</h3><p>AOP도 스프링의 3개 기술중의 하나다. 사실 애스펙트 지향 프로그래밍은 객체지향 프로그래밍(OOP)처럼 독립적인 프로그래밍 패러다임이 아니다. AOP와 OOP는 서로 배타적이 아니라는 말이다.</p><p>객체지향 기술은 매우 성공적은 프로그래밍 방식임에 분명하다. 하지만 한편으로는 복잡해져 가는 애플리케이션의 요구조건과 기술적인 난해함을 모두 해결하는데 한계가 있기도 하다. AOP는 바로 이러한 객체지향 기술의 한계와 단점을 극복하도록 도와주는 보조적인 프로그래밍 기술이다.</p><p>IOC/DI를 이용해서 POJO에 선언적인 엔터프라이즈 서비스를 제공할 수 있지만 일부 서비스는 순수한 객체지향 기법만으로는 POJO의 조건을 유지한 채로 적용하기 힘들다. 바로 이런 문제를 해결하기 위해 AOP가 필요하다.</p><h4 id="aop-적용-기법"><a href="#AOP-적용-기법" class="headerlink" title="AOP 적용 기법"></a>AOP 적용 기법</h4><p>AOP를 자바 언어에 적용하는 기법은 크게 두 가지로 분류할 수 있다.</p><ul><li><p><strong>스프링과 같이 다이내믹 프록시를 사용하는 방법</strong></p><p>이 방법은 기존 코드에 영향을 주지 않고 부가기능을 적용하게 해주는 데코레이터 패턴을 응용한 것이다. 만들기 쉽고 적용하기 간편하지만 부가기능을 부여할 수 있는 곳은 메소드의 호출이 일어나는 지점뿐이라는 제약이 있다. 인터페이스와 DI를 활용하는 데코레이터 패턴이 기반원리이기 때문이다.</p></li><li><p><strong>자바 언어의 한계를 넘어서는 언어의 확장을 이용하는 방법</strong></p><p>AspectJ라는 유명한 오픈소스 AOP 툴이 있다. AspectJ는 프록시 방식의 AOP에서는 불가능한 다양한 조인포인트를 제공한다. 메소드 호출뿐 아니라 인스턴스 생성, 필드 액세스, 특정 호출 경로를 가진 메소드 호출 등에도 부가기능을 제공할 수 있다. 이런 고급 AOP 기능을 적용하려면 자바 언어와 JDK의 지원만으로는 불가능하다. 그 대신 별도의 AOP 컴파일러를 이용한 빌드 과정을 거치거나, 클래스가 메모리로 로딩될 때 그 바이트 코드를 조작하는 위빙과 같은 별도의 방법을 이용해야 한다.</p></li></ul><h3 id="포터블-서비스-추상화psa"><a href="#포터블-서비스-추상화-PSA" class="headerlink" title="포터블 서비스 추상화(PSA)"></a>포터블 서비스 추상화(PSA)</h3><p>세 번째 기능기술은 환경과 세부 기술의 변화에 관계없이 일관된 방식으로 기술에 접근 할 수 있게 해주는 PSA(Portable Service Abstraction)다. POJO로 개발된 코드는 특정 환경이나 구현 방식에 종속적이지 않아야 한다. 스프링은 JavaEE를 기존 플랫폼으로 하는 자바 엔터프라이즈 개발에 주로 사용된다. 따라서 다양한 JavaEE 기술에 의존적일 수밖에 없다 .특정 환경과 기술에 종속적이지 않다는 게 그런 기술을 사용하지 않는다는 뜻은 아니다. 다만 POJO 코드가 그런 기술에 직접 노출되어 만들어지지 않는다는 말이다. 이를 위해 스프링이 제공하는 대표적인 기술이 바로 일관성 있는 서비스 추상화 기술이다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p><a href="http://www.acornpub.co.kr/book/toby-spring3.1-vol1" target="_blank" rel="noopener">토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;스프링이란-무엇인가&quot;&gt;&lt;a href=&quot;#스프링이란-무엇인가&quot; class=&quot;headerlink&quot; title=&quot;스프링이란 무엇인가?&quot;&gt;&lt;/a&gt;스프링이란 무엇인가?&lt;/h1&gt;&lt;h2 id=&quot;스프링의-정의&quot;&gt;&lt;a href=&quot;#스프링의-정의&quot; cla
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Spring" scheme="https://jongmin92.github.io/categories/Programming/Spring/"/>
    
    
      <category term="Spring" scheme="https://jongmin92.github.io/tags/Spring/"/>
    
      <category term="Toby" scheme="https://jongmin92.github.io/tags/Toby/"/>
    
      <category term="POJO" scheme="https://jongmin92.github.io/tags/POJO/"/>
    
  </entry>
  
  <entry>
    <title>토비의 스프링 6장 (AOP)</title>
    <link href="https://jongmin92.github.io/2018/04/15/Spring/toby-6/"/>
    <id>https://jongmin92.github.io/2018/04/15/Spring/toby-6/</id>
    <published>2018-04-15T14:00:00.000Z</published>
    <updated>2018-05-08T04:55:28.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="aop"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p><strong><code>AOP</code>는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반기술중 하나다.</strong></p><p><strong>AOP를 바르게 이용하려면 OOP를 대체하려고 하는 것처럼 보이는 AOP라는 이름 뒤에 감춰진, 그 필연적인 등장배경과 스프링이 그것을 도입한 이유, 그 적용을 통해 얻을 수 있는 장점이 무엇인지에 대한 충분한 이해가 필요하다.</strong></p><p>스프링에 적용된 가장 인기 있는 AOP의 적용 대상은 바로 선언적 트랜잭션 기능이다. 서비스 추상화를 통해 많은 근본적인 문제를 해결했던 트랜잭션 경계설정 기능을 AOP를 이용해 더욱 세련되고 깔끔한 방식으로 바꿔보자.</p><h2 id="트랜잭션-코드의-분리"><a href="#트랜잭션-코드의-분리" class="headerlink" title="트랜잭션 코드의 분리"></a>트랜잭션 코드의 분리</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgradeLevels</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TransactionStatus status = <span class="keyword">this</span>.transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = userDao.getAll();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canUpgradeLevel(user)) &#123;</span><br><span class="line">                upgradeLevel(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.transactionManager.commit(status);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionManager.rollback(status);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>얼핏 보면 트랜잭션 경계설정 코드와 비즈니스 로직 코드가 복잡하게 얽혀 있는듯이 보이지만, 자세히 살펴보면 뚜렷하게 두 가지 종류의 코드가 구분되어 있음을 알 수 있다. 비즈니스 로직 코드를 사이에 두고 트랜잭션 시작과 종료를 담당하는 코드가 앞뒤에 위치하고 있다.</p><p>또, 이 코드의 특징은 트랜잭션 경계설정의 코드와 비즈니스 로직 코드 간에 서로 주고받는 정보가 없다는 점이다. 다만 이 비즈니스 로직을 담당하는 코드가 트랜잭션의 시작과 종료 작업 사이에서 수행돼야 한다는 사항만 지켜지면 된다.</p><h3 id="di를-이용한-클래스의-분리"><a href="#DI를-이용한-클래스의-분리" class="headerlink" title="DI를 이용한 클래스의 분리"></a>DI를 이용한 클래스의 분리</h3><h4 id="di-적용을-이용한-트랜잭션-분리"><a href="#DI-적용을-이용한-트랜잭션-분리" class="headerlink" title="DI 적용을 이용한 트랜잭션 분리"></a>DI 적용을 이용한 트랜잭션 분리</h4><p>지금 UserService는 UserServiceTest가 클라이언트가 되어서 사용하고 있다. 현재 구조는 UserService 클래스와 그 사용 클라이언트 간의 관계가 강한 결합도로 고정되어 있다. 그래서 UserService를 인터페이스로 만들고 기존 코드는 UserService 인터페이스의 구현 클래스를 만들어넣도록 한다. 그러면 클라이언트와 결합이 약해지고, 직접 구현 클래스에 의존하고 있지 않기 때문에 유연한 확장이 가능해진다.</p><p>그런데 보통 이렇게 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고 런타임 시에 DI를 통해 적용하는 방법을 쓰는 이유는, 일반적으로 구현 클래스를 바꿔가면서 사용하기 위해서다.</p><p>하지만 꼭 그래야 한다는 제약은 없다. 지금 해결하려고 하는 문제는 UserService에는 순수하게 비즈니스 로직을 담고 있는 코드만 두고 트랜잭션 경계설정을 담당하는 코드를 외부로 빼내려는 것이다.</p><p>그래서 다음과 같은 구조를 생각해볼 수 있다. UserService를 구현한 또 다른 구현 클래스를 만든다. 이 클래스는 사용자 관리 로직을 담고 있는 구현 클래스인 UserServiceImpl을 대신하기 위해 만든 게 아니다. 단지 트랜잭션의 경계설정이라는 책임을 맡고 있을 뿐이다. 그리고 스스로는 비즈니스 로직을 담고 있지 않기 때문에 또 다른 비즈니스 로직을 담고 있는 UserService의 구현 클래스에 실제적인 로직 처리 작업은 위임하는 것이다.</p><h4 id="userservice-인터페이스-도입"><a href="#UserService-인터페이스-도입" class="headerlink" title="UserService 인터페이스 도입"></a>UserService 인터페이스 도입</h4><p>먼저 기존의 UserService 클래스를 UserServiceImpl로 이름을 변경한다. 그리고 클라이언트가 사용할 로직을 담은 핵심 메소드만 UserService 인터페이스로 만든 후 UserServiceImpl이 구현하도록 만든다.</p><p>UserService 인터페이스의 구현 클래스인 UserServiceImpl은 기존 UserService 클래스의 내용을 대부분 그대로 유지하면 된다. 단, 트랜잭션 관련된 코드는 독립시키기로 했으니 모두 제거한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">userService</span> </span>&#123;</span><br><span class="line">    UserDao userDao;</span><br><span class="line">    MailSender mailSender;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgradeLevels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userDao.getAll();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canUpgradeLevel(user)) &#123;</span><br><span class="line">                upgradeLevel(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="분리된-트랜잭션-기능"><a href="#분리된-트랜잭션-기능" class="headerlink" title="분리된 트랜잭션 기능"></a>분리된 트랜잭션 기능</h4><p>비즈니스 트랜잭션 처리를 담은 UserServiceTx를 만들어보자. UserServiceTx는 기본적으로 UserService를 구현하게 만든다. 그리고 같은 인터페이스를 구현한 다른 오브젝트에게 고스란히 작업을 위임하게 만들면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTx</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// UserService를 구현한 다른 오브젝트를 DI 받는다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DI 받은 UserService 오브젝트에 모든 기능을 위임한다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userService.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgradeLevels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userService.upgradeLevels();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceTx는 UserService 인터페이스를 구현했으니, 클라이언트에 대해 UserService 타입 오브젝트의 하나로서 행세할 수 있다. UserServiceTx는 사용자 관리라는 비즈니스 로직을 전혀 갖지 않고 고스란히 다른 UserService 구현 오브젝트에 기능을 위임한다. 이렇게 준비된 UserServiceTx에 트랜잭션의 경계설정이라는 부가적인 작업을 부여해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTx</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    UserService userService;</span><br><span class="line"> PlatformTransactionManager transactionManager;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionManager</span><span class="params">(PlatformTransactionManager transactionManager)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.transactionManager = transactionManager;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userService.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgradeLevels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TransactionStatus status = <span class="keyword">this</span>.transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userService.upgradeLevels();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">this</span>.transactionManager.commit(status);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.transactionManager.rollback(status);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="트랜잭션을-위한-di-설정"><a href="#트랜잭션을-위한-DI-설정" class="headerlink" title="트랜잭션을 위한 DI 설정"></a>트랜잭션을 위한 DI 설정</h4><p>클라이언트가 UserService라는 인터페이스를 통해 사용자 관리 로직을 이용하려고 할 때 먼저 트랜잭션을 담당하는 오브젝트가 사용돼서 트랜잭션에 관련된 작업을 진행해주고, 실제 사용자 관리 로직을 담은 오브젝트가 이후에 호출돼서 비즈니스 로직에 관련된 작업을 수행하도록 만든다.</p><h4 id="트랜잭션-경계설정-코드-분리의-장점"><a href="#트랜잭션-경계설정-코드-분리의-장점" class="headerlink" title="트랜잭션 경계설정 코드 분리의 장점"></a>트랜잭션 경계설정 코드 분리의 장점</h4><ol><li>비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 된다. 트랜잭션의 적용이 필요한지도 신경 쓰지 않아도 된다.</li><li>비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다.</li></ol><h2 id="고립된-단위-테스트"><a href="#고립된-단위-테스트" class="headerlink" title="고립된 단위 테스트"></a>고립된 단위 테스트</h2><p>가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것이다.</p><p>하지만 현재 UserService는 UserDao, TransactionManager, MailSender라는 세 가지 의존관계를 갖고 있다. 따라서 그 세 가지 의존관계를 갖는 오브젝트들이 테스트가 진행되는 동안에 같이 실행된다. UserService라는 테스트 대상이 테스트 단위인 것처럼 보이지만 사실은 그 뒤에 의존관계를 따라 등장하는 오브젝트와 서비스, 환경 등이 모두 합쳐져 테스트 대상이 되는 것이다.</p><h3 id="테스트-대상-오브젝트-고립시키기"><a href="#테스트-대상-오브젝트-고립시키기" class="headerlink" title="테스트 대상 오브젝트 고립시키기"></a>테스트 대상 오브젝트 고립시키기</h3><p>그래서 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다. 테스트를 의존 대상으로부터 분리해서 고립시키는 방법은 테스트를 위한 대역을 사용하는 것이다.</p><h4 id="테스트를-위한-userserviceimpl-고립"><a href="#테스트를-위한-UserServiceImpl-고립" class="headerlink" title="테스트를 위한 UserServiceImpl 고립"></a>테스트를 위한 UserServiceImpl 고립</h4><p>의존 오브젝트나 외부 서비스에 의존하지 않는 고립된 테스트 방식으로 만든 UserServiceImpl은 아무리 그 기능이 수행돼도 그 결과가 DB 등을 통해서 남지 않으니, 기존의 방법으로는 작업 결과를 검증하기 힘들다. upgradeLevels()처럼 결과가 리턴되지 않는 경우는 더더욱 그렇다.</p><p>그래서 이럴 땐 테스트 대상인 UserServiceImpl과 그 협력 오브젝트인 UserDao에게 어떤 요청을 했는지를 확인하는 작업이 필요하다. 테스트 중에 DB에 결과가 반영되지는 않았지만, UserDao의 update() 메소드를 호출하는 것을 확인할 수 있다면, 결국 DB에 그 결과가 반영될 것이라고 결론을 내릴 수 있기 때문이다. UserDao와 같은 역할을 하면서 UserServiceImpl과의 사이에서 주고받은 정보를 저장해뒀다가, 테스트의 검증에 사용할 수 있게 하는 목 오브젝트를 만들 필요가 있다.</p><h4 id="단위-테스트와-통합-테스트"><a href="#단위-테스트와-통합-테스트" class="headerlink" title="단위 테스트와 통합 테스트"></a>단위 테스트와 통합 테스트</h4><p>단위 테스트의 단위는 정하기 나름이다. 사용자 관리 기능 전체를 하나의 단위로 볼 수도 있고 하나의 클래스나 하나의 메소드를 단위로 볼 수도 있다. 중요한 것은 하나의 단위에 초점을 맞춘 테스트라는 점이다.</p><p><strong>‘테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트 하는 것’을 <code>단위 테스트</code>라고 부른다. 반면에 두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트는 <code>통합 테스트</code>라고 부른다. 통합 테스트란 두 개 이상의 단위가 결합해서 동작하면서 테스트가 수행되는 것이라고 보면 된다.</strong> 스프링의 테스트 컨텍스트 프레임워크를 이용해서 컨텍스트에서 생성되고 DI된 오브젝트를 테스트하는 것도 통합 테스트다.</p><p>아래는 단위 테스트와 통합 테스트 중에서 어떤 방법을 쓸지 어떻게 결장할 것인지에 대한 가이드 라인이다.</p><ul><li>항상 단위 테스트를 먼저 고려한다.</li><li>하나의 클래스나 성격과 목적이 같은 긴밀한 클래스 몇 개를 모아서 외부와의 의존관계를 모두 차단하고 필요에 따라 스텁이나 목 오브젝트 등의 테스트 대역을 이용하도록 테스트를 만든다. 단위 테스트는 테스트 작성도 간단하고 실행 속도도 빠르며 테스트 대상 외의 코드나 환경으로부터 테스트 결과에 영향을 받지도 않기 때문에 가장 빠른 시간에 효과적인 태스트를 작성하기에 유리하다.</li><li>외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다.</li><li>단위 테스트로 만들기가 어려운 코드도 있다. 대표적인 게 DAO다. DAO는 그 자체로 로직을 담고 있기보다는 DB를 통해 로직을 수행하는 인터페이스와 같은 역할을 한다. SQL을 JDBC를 통해 실행하는 코드만으로는 고립된 테스트를 작성하기가 힘들다. 작성한다고 해도 가치가 없는 경우가 대부분이다. 따라서 DAO는 DB까지 연동하는 테스트로 만드는 편이 효과적이다. DB를 사용하는 테스트는 DB에 테스트 데이터를 준비하고, DB를 사용하는 테스트는 DB에 테스트 데이터를 준비하고, DB에 직접 확인을 하는 드의 부가적인 작업이 필요하다.</li><li>DAO 테스트는 DB라는 외부 리소스를 사용하기 때문에 통합 테스트로 분류된다. 하지만 코드에서 보자면 하나의 기능 단위를 테스트하는 것이기도 하다. DAO를 테스트를 통해 충분히 검증해두면, DAO를 이용하는 코드는 DAO 역할을 스텁이나 목 오브젝트로 대체해서 테스트할 수 있다. 이후에 실제 DAO와 연동했을 때도 바르게 동작하리라고 확신할 수 있다. 물론 각각의 단위 테스트가 성공했더라도 여러 개의 단위를 연결해서 테스트하면 오류가 발생할 수도 있다. 하지만 충분한 단위 테스트를 거친다면 통합 테스트에서 오류가 발생할 확률도 줄어들고 발생한다고 하더라도 쉽게 처리할 수 있다.</li><li>여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요하다. 다만, 단위 테스트를 충분히 거쳤다면 통합 테스트의 부담은 상대적으로 줄어든다.</li><li>단위 테스트를 만들기가 너무 복잡하다고 판단되는 코드는 처음부터 통합 테스트를 고려해본다. 이때도 통합 테스트에 참여하는 코드 중에서 가능한 한 많은 부분을 미리 단위 테스트로 검증해두는 게 유리하다.</li><li>스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트다. 간으하면 스프링의 지원 없이 직접 코드 레벨의 DI를 사용하면서 단위 테스트를 하는게 좋겠지만 스프링의 설정 자체도 테스트 대상이고, 스프링을 이용해 좀 더 추상적인 레벨에서 테스트해야 할 경우도 종종 있다. 이럴 땐 스프링 테스트 컨텍스트 프레임워크를 이용해 통합 테스트를 작성한다.</li></ul><h4 id="목-프레임워크"><a href="#목-프레임워크" class="headerlink" title="목 프레임워크"></a>목 프레임워크</h4><p><strong>단위 테스트를 만들기 위해서는 스텁이나 목 오브젝트의 사용이 필수적이다. 의존관계가 없는 단순한 클래스나 세부 로직을 검증하기 위해 메소드 단위로 테스트할 때가 아니라면, 대부분 의존 오브젝트를 필요로 하는 코드를 테스트하게 되기 때문이다.</strong></p><p>목 오브젝트를 만드는 일은 번거로울 수 있다. 그러나 이런 번거로운 목 오브젝트를 편리하게 작성하도록 도와주는 다양한 목 오브젝트 지원 프레임워크가 있다.</p><h5 id="mockito-프레임워크"><a href="#Mockito-프레임워크" class="headerlink" title="Mockito 프레임워크"></a>Mockito 프레임워크</h5><p>Mockito라는 프레임워크는 사용하기도 편리하고, 코드도 직관직이라 최근 많은 인기를 끌고 있다.</p><p>Mockito와 같은 목 프레임워크의 특징은 목 클래스를 일일이 준비해둘 필요가 없다는 것이다. 간단한 메소드 호출만으로 다이내믹하게 특정 인터페이스를 구현한 테스트용 목 오브젝트를 만들 수 있다.</p><p>USerDao 인터페이스를 구현한 테스트용 목 오브젝트는 다음과 같이 Mockito의 스태틱 메소드를 한 번 호출해주면 만들어진다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserDao mockUserDao = mock(UserDao.class);</span><br></pre></td></tr></table></figure><p>이렇게 만들어진 목 오브젝트는 아직 아무런 기능이 없다. 여기에 먼저 getAll() 메소드가 불려올 때 사용자 목록을 리턴하도록 스텁 기능을 추가해줘야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">when(mockUserDao.getAll()).thenReturn(<span class="keyword">this</span>.users);</span><br></pre></td></tr></table></figure><p>mockUserDao.getAll()이 호출됐을 때(when), users 리스트를 리턴해주라(thenReturn)는 선언이다.</p><p>Mocktio를 통해 만들어진 목 오브젝트는 메소드의 호출과 관련된 모든 내용을 자동으로 저장해두고, 이를 간단한 메소드로 검증할 수 있게 해준다.</p><p>테스트를 진행하는 동안 mockUserDao의 update() 메소드가 두 번 호출됐는지 확인하고 싶다면, 다음과 같이 검증 코드를 넣어주면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verify(mockUserDao, times(<span class="number">2</span>)).update(any(User.class));</span><br></pre></td></tr></table></figure><p>User 타입의 오브젝트를 파라미터로 받으며 update() 메소드가 두 번 호출됐는지(times(2)) 확인하라(verify)는 것이다.</p><p>Mockito 목 오브젝트는 다음의 네 단계를 거쳐서 사용하면 된다. 두 번째와 네 번째는 각각 필요할 경우에만 사용할 수 있다.</p><ul><li>인터페이스를 이용해 목 오브젝트를 만든다.</li><li>목 오브젝트가 리턴할 값이 있으면 이를 지정해준다. 메소드가 호출되면 예외를 강제로 던지게 만들 수도 있다.</li><li>테스트 대상 오브젝트에 DI 해서 목 오브젝트가 테스트 중에 사용되도록 만든다.</li><li>테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.</li></ul><p>ArgumentCaptor는 목 오브젝트에 전달된 파라미터를 가져와 내용을 검증하기 위해 사용한다. 파라미터를 직접 비교하기 보다는 파라미터의 내부 정보를 확인해야 하는 경우에 유용하다.</p><h2 id="다이내믹-프록시와-팩토리빈"><a href="#다이내믹-프록시와-팩토리빈" class="headerlink" title="다이내믹 프록시와 팩토리빈"></a>다이내믹 프록시와 팩토리빈</h2><h3 id="프록시와-프록시-패턴-데코레이터-패턴"><a href="#프록시와-프록시-패턴-데코레이터-패턴" class="headerlink" title="프록시와 프록시 패턴, 데코레이터 패턴"></a>프록시와 프록시 패턴, 데코레이터 패턴</h3><p>부가기능 외의 나머지 모든 기능은 원래 핵심기능을 가진 클래스로 위임해줘야 한다. 핵심 기능은 부가기능을 가진 클래스의 존재 자체를 모른다. 따라서 부가기능이 핵심기능을 사용하는 구조가 되는 것이다</p><p>문제는 이렇게 구성했더라도 클라이언트가 핵심기능을 가진 클래스를 직접 사용해 버리면 부가기능이 적용될 기회가 없다는 점이다. 그래서 부가기능은 마치 자신이 핵심 기능을 가진 클래스인 것처럼 꾸며서, 클라이언트가 자신을 거쳐서 핵심기능을 사용하도록 만들어야 한다. 그러기 위해서는 클라이언트는 인터페이스를 통해서만 핵심기능을 사용하게 하고, 부가기능 자신도 같은 인터페이스를 구현한 뒤에 자신이 그 사이에 끼어들어야 한다.</p><p>이렇게 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요처을 받아주는 것을 대리자, 대리인과 같은 역할을 한다고 해서 <strong>프록시(proxy)</strong>라고 부른다. 그리고 프록시를 통해 최종적으로 요처을 위임받아 처리하는 실제 오브젝트를 타깃(target) 또는 실체(real subject)라고 부른다.</p><p>프록시의 특징은 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어할 수 있는 위치에 있다는 것이다.</p><p>프록시는 사용 목적에 따라 두 가지로 구분할 수 있다. 첫째는 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서다. 두 번째는 타깃에 부가적인 기능을 부여해주기 위해서다. 두 가지 모두 대리 오브젝트라는 개념의 프록시를 두고 사용한다는 점은 동일하지만, 목적에 따라서 디자인 패턴에서느 다른 패턴으로 구분한다.</p><h4 id="데코레이터-패턴"><a href="#데코레이터-패턴" class="headerlink" title="데코레이터 패턴"></a>데코레이터 패턴</h4><p><strong>데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시에 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴을 말한다.</strong> 다이내믹하게 기능을 부여한다는 의미는 컴파일 시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻이다. 데코레이터 패턴에서는 프록시가 꼭 한 개로 제한되지 않는다. 데코레이터 패턴에서는 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용할 수 있다.</p><p>프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 자신이 최종 타깃으로 위임하는지, 아니면 다음 단계의 데코레이터 프록시로 위임하는지 알지 못한다. 그래서 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성자나 수정자 메소드를 통해 위임 대상을 외부에서 런타임 시에 주입받을 수 있도록 만들어야 한다.</p><p><strong>인터페이스를 통한 데코레이터 정의와 런타임 시의 다이내믹한 구성 방법은 스프링의 DI를 이요하면 아주 편리하다. 데코레이터 빈의 프로퍼티로 같은 인터페이스를 구현한 다른 데코레이터 또는 타깃 빈을 설정하면 된다.</strong></p><p>데코레이터 패턴은 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.</p><h4 id="프록시-패턴"><a href="#프록시-패턴" class="headerlink" title="프록시 패턴"></a>프록시 패턴</h4><p>일반적으로 사용하는 프록시라는 용어와 디자인 패턴에서 말하는 프록시 패턴은 구분할 필요가 있다. 전자는 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법을 말한다면, 후자는 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 가리킨다.</p><p>프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다. 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.</p><p>프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용하는 것이다. 구조적으로 보자면 프록시와 데코레이터는 유사하다. 다만 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다. 생성을 지연하는 프록시라면 구체적인 생성 방법을 알아야 하기 때문에 타깃 클래스에 대한 직접적인 정보를 알아야 한다. 물론 프록시 팽턴이라고 하더라도 인터페이스를 통해 위임하도록 만들 수도 있다. 인터페이스를 토앻 다음 호출 대상으로 접근하게 되면 그 사이에 다른 프록시나 데코레이터가 계속 추가될 수 있기 때문이다.</p><p>앞으로는 타깃과 동일한 인터페이스를 구현하고 클라이언트와 타깃 사이에 존재하면서 기능의 부가 또는 접근 제어를 담당하는 오브젝트를 모두 프록시라고 부르겠다. 하지만 그때마다 사용의 목적이 기능의 부가인지, 접근 제어인지를 구분해보면 각각 어떤 목적으로 프록시가 사용됐는지, 그에 따라 어떤 패턴이 적용됐는지 알 수 있을 것이다.</p><h3 id="다이내믹-프록시"><a href="#다이내믹-프록시" class="headerlink" title="다이내믹 프록시"></a>다이내믹 프록시</h3><p>목 오브젝트를 만드는 불편함을 목 프레임워크를 사용해 편리하게 바꿨던 것처럼 프록시도 일일이 모든 인터페이스를 구현해서 클래스를 새로 정의하지 않고도 편리하게 만들어서 사용할 방법이 있다.</p><p>자바에는 java.lang.reflect 패키지 안에 프록시를 손쉽게 만들 수 있도록 지원해주는 클래스들이 있다. 일일이 프록시 클래스를 정의하지 않고도 몇 가지 API를 이용해 프록시처럼 동작하는 오브젝트를 다이내믹하게 생성하는 것이다.</p><h4 id="프록시의-구성과-프록시-작성의-문제점"><a href="#프록시의-구성과-프록시-작성의-문제점" class="headerlink" title="프록시의 구성과 프록시 작성의 문제점"></a>프록시의 구성과 프록시 작성의 문제점</h4><p>프록시는 다음의 두 가지 기능으로 구성된다.</p><ul><li>타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임한다.</li><li>지정된 요청에 대해서는 부가기능을 수행한다.</li></ul><p>프록시를 만들기가 번거로운 이유는 두 가지가 있다.</p><ul><li>첫째는 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다는 점이다. 부가기능이 필요 없는 메소드도 구현해서 타깃으로 위임하는 코드를 일일이 만들어줘야 한다. 또, 타깃 인터페이스의 메소드가 추가되거나 변경될 때마다 함께 수정해줘야 한다는 부담도 있다.</li><li>두 번째 문제점은 부가기능 코드가 중복될 가능성이 많다는 점이다.</li></ul><p>첫 번째 문제인 인터페이스 메소드의 구현과 위임 기능 문제는 간단해 보이지 않는다. 바로 이런 문제를 해결하는 데 유용한 것이 바로 JDK의 다이내믹 프록시다.</p><h4 id="리플렉션"><a href="#리플렉션" class="headerlink" title="리플렉션"></a>리플렉션</h4><p><strong>다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다. 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것이다.</strong></p><p>자바의 모든 클래스는 그 클래스 자체의 구성정보를 담은 Class 타입의 오브젝트를 하나씩 갖고 있다. ‘클래스이름.class’라고 하거나 오브젝트의 getClass() 메소드를 호출하면 클래스 정보를 담은 Class 타입의 오브젝트를 가져올 수 있다. 클래스 오브젝트를 이용하면 크래스 코드에 대한 메타정보를 가져오거나 오브젝트를 조작할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> springbook.learningtest.jdk;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeMethod</span><span class="params">()</span> <span class="keyword">throws</span> <span class="title">Exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"Spring"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// length()</span></span><br><span class="line">        assertThat(name.length(), is(<span class="number">6</span>));</span><br><span class="line">        </span><br><span class="line">Method lengthMethod = String.class.getMethod(<span class="string">"length"</span>);</span><br><span class="line">        assertThat((Integer)lengthMethod.invoke(name), is(<span class="number">6</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// charAt()</span></span><br><span class="line">        assertThat(name.charAt(<span class="number">0</span>), is(<span class="string">'S'</span>));</span><br><span class="line">        </span><br><span class="line">        Method charAtMethod = String.class.getMethod(<span class="string">"charAt"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        assertThat((Character)charAtMethod.invoke(name, <span class="number">0</span>), is(<span class="string">'S'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="다이내믹-프록시-적용"><a href="#다이내믹-프록시-적용" class="headerlink" title="다이내믹 프록시 적용"></a>다이내믹 프록시 적용</h4><p><img src="/images/post/2018-04-15/dynamic-proxy.png" alt="dynamic-proxy"></p><p><strong>다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트다. 다이내믹 프록시 오브젝트는 타깃의 인터페이스와 같은 타입으로 만들어진다.</strong> 클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있다. 이 덕분에 프록시를 만들 때 인터페이스를 모두 구현해가면서 클래스를 정의하는 수고를 덜 수 있다. 프록시 팩토리에게 인터페이스 정보만 제공해주면 해당 인터페이스를 구현한 클래스의 오브젝트를 자동으로 만들어주기 때문이다.</p><p>다이내믹 프록시가 인터페이스 구현 클래스의 오브젝트는 만들어주지만, 프록시로서 필요한 부가기능 제공 코드는 직접 생성해야 한다. 부가기능은 프록시 오브젝트와 독립적으로 InvocationHandler를 구현한 오브젝트에 담는다. InvocationHandler 인터페이스는 다음과 같은 메소드 한 개만 가진 간단한 인터페이스다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure><p>invoke() 메소드는 리플렉션의 MEthod 인터페이스를 파라미터로 받는다. 메소드를 호출할 때 전달되는 파라미터도 args로 받는다. <strong>다이내믹 프록시 오브젝트는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 InvocationHandler 구현 오브젝트의 invoke() 메소드로 넘기는 것이다. 타깃 인터페이스의 모든 메소드 요청이 하나의 메소드로 집중되기 때문에 중복되는 기능을 효과적으로 제공할 수 있다.</strong></p><p>InvocationHandler 구현 오브젝트가 타깃 오브젝트 레퍼런스를 갖고 있다면 리플렉션을 이용해 간단히 위임 코드를 만들어 낼 수 있다.</p><p>InvocationHandler 인터페이스를 구현한 오브젝트를 제공해주면 다이내믹 프록시가 받는 모든 요청을 InvocationHandler의 invoke() 메소드로 보내준다.</p><p>다이내믹 프록시로부터 요청을 전달받으려면 InvocationHandler를 구현해야 한다. 메소드는 invoke() 하나뿐이다. 다이내믹 프록시가 클라이언트로부터 받는 모든 요청은 incoke() 메소드로 전달된다. 다이내믹 프록시를 통해 요청이 전달되면 리플렉션 API를 이용해 타깃 오브젝트의 메소드를 호출한다. 타깃 오브젝트는 생성자를 통해 미리 전달받아 둔다.</p><p>다이내믹 프록시의 생성은 Proxy 클래스의 newProxyInstance() 스태틱 팩토리 메소드를 이용하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성된 다이내믹 프록시 오브젝트는 Hello 인터페이스를 구현하고 있으므로 Hello 타입으로 캐스팅해도 안전하다.</span></span><br><span class="line">Hello proxiedHello = (Hello)Proxy.newProxyInstance(</span><br><span class="line">    <span class="comment">// 동적으로 생성되는 다이내믹 프록시 클래스의 로딩에 사용할 클래스 로더</span></span><br><span class="line">getClass().getClassLoader(),</span><br><span class="line">    <span class="comment">// 구현할 인터페이스</span></span><br><span class="line">    <span class="keyword">new</span> Class[] &#123; Hello.class &#125;,</span><br><span class="line">    <span class="comment">// 부가기능과 위임 코드를 담은 InvocationHandler</span></span><br><span class="line">    <span class="keyword">new</span> UppercaseHandler(<span class="keyword">new</span> HelloTarget()));</span><br></pre></td></tr></table></figure><h4 id="다이내믹-프록시의-확장"><a href="#다이내믹-프록시의-확장" class="headerlink" title="다이내믹 프록시의 확장"></a>다이내믹 프록시의 확장</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UppercaseHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 어떤 종류의 인터페이스를 구현한 타깃에도 적용 가능하도록 Object 타입으로 수정</span></span><br><span class="line">    Object target;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UppercaseHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> thorws Throwable </span>&#123;</span><br><span class="line">        Object ret = method.invoke(target, args);</span><br><span class="line">        <span class="keyword">if</span> (Ret <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((String)ret).toUpperCase();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="다이내믹-프록시를-이용한-트랜잭션-부가기능"><a href="#다이내믹-프록시를-이용한-트랜잭션-부가기능" class="headerlink" title="다이내믹 프록시를 이용한 트랜잭션 부가기능"></a>다이내믹 프록시를 이용한 트랜잭션 부가기능</h3><h4 id="트랜잭션-invocationhandler"><a href="#트랜잭션-InvocationHandler" class="headerlink" title="트랜잭션 InvocationHandler"></a>트랜잭션 InvocationHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line">    <span class="keyword">private</span> String pattern;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionManager</span><span class="params">(PlatformTransactionManager transactionManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionManager = transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPattern</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().startsWith(pattern)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeInTransaction(method, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeTransaction</span><span class="params">(Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        TransactionStatus = <span class="keyword">this</span>.transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object ret = method.invoke(target, args);</span><br><span class="line">            <span class="keyword">this</span>.transactionManager.commit(status);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.transactionManager.rollback(status);</span><br><span class="line">            <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transactionhandler와-다이내믹-프록시를-이용하는-테스트"><a href="#TransactionHandler와-다이내믹-프록시를-이용하는-테스트" class="headerlink" title="TransactionHandler와 다이내믹 프록시를 이용하는 테스트"></a>TransactionHandler와 다이내믹 프록시를 이용하는 테스트</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgradeAllOrNothing</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    TransactionHandler txHandler = <span class="keyword">new</span> TransactionHandler();</span><br><span class="line">    txHandler.setTarget(testUserService);</span><br><span class="line">    txHandler.setTransactionManager(transactionManager);</span><br><span class="line">    txHandler.setPattern(<span class="string">"upgradeLevels"</span>);</span><br><span class="line">    UserService txUSerService = (UserService)Proxy.newProxyInstance(getClass().getClassLoader(), <span class="keyword">new</span> Class[] &#123;UserService.class &#125;, txHandler);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="다이내믹-프록시를-위한-팩토리-빈"><a href="#다이내믹-프록시를-위한-팩토리-빈" class="headerlink" title="다이내믹 프록시를 위한 팩토리 빈"></a>다이내믹 프록시를 위한 팩토리 빈</h3><p>이제 TransactionHandler와 다이내믹 프록시를 스프링의 DI를 통해 사용할 수 있도록 만들어야 할 차례다.</p><p>스프링의 빈은 기본적으로 클래스 이름과 프로퍼티로 정의된다. 스프링은 지정된 클래스 이름을 가지고 리플렉션을 이용해서 해당 클래스의 오브젝트를 만든다. 클래스의 이름을 갖고 있다면 다음과 같은 방법으로 새로운 오브젝트를 생성할 수 있다. Class의 newInstance() 메소드는 해당 클래스의 파라미터가 없는 생성자를 호출하고, 그 결과 생성되는 오브젝트를 돌려주는 리플렉션 API다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date now = (Date) Class.forName(<span class="string">"java.util.Date"</span>).newInstance();</span><br></pre></td></tr></table></figure><p>스프링은 내부적으로 리플렉션 API를 이용해서 빈 정의에 나오는 클래스 이름을 가지고 빈 오브젝트를 생성한다. 문제는 다이내믹 프록시 오브젝트는 이런 식으로 프록시 오브젝트가 생성되지 않는다는 점이다. 사실 다이내믹 프록시 오브젝트의 클래스가 어떤 것인지 알 수도 없다. 클래스 자체도 내부적으로 다이내믹하게 새로 정의해서 사용하기 때문이다. 따라서 사전에 프록시 오브젝트의 클래스 정보를 미리 알아내서 스프링의 빈에 정의할 방법이 없다. 다이내믹 프록시는 Proxy 클래스의 newProxyInstance()라는 스태틱 팩토리 메소드를 통해서만 만들 수 있다.</p><h4 id="팩토리-빈"><a href="#팩토리-빈" class="headerlink" title="팩토리 빈"></a>팩토리 빈</h4><p>스프링은 클래스 정보를 가지고 디폴트 생성자를 통해 오브젝트를 만드는 방법 외에도 빈을 만들 수 있는 여러 가지 방법을 제공한다. 대표적으로 팩토리 빈을 이용한 빈 생성 방법을 들 수 있다. 팩토리 빈이란 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈을 말한다.</p><p>팩토리 빈을 만드는 방법에는 여러 가지가 있는데, 가장 간단한 방법은 스프링의 FactoryBean이라는 인터페이스를 구현하는 것이다.</p><p>사실 스프링은 private 생성자를 가진 클래스도 빈으로 등록해주면 리플렉션을 이용해 오브젝트를 만들어준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>; <span class="comment">// 빈 오브젝트를 생성해서 돌려준다.</span></span><br><span class="line">    Class&lt;? extends T&gt; getOBjectType(); <span class="comment">// 생성되는 오브젝트의 타입을 알려준다.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>; <span class="comment">// getObject()가 돌려주는 오브젝트가 항상 같은 싱글톤 오브젝트인지 알려준다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="다이내믹-프록시를-만들어주는-팩토리-빈"><a href="#다이내믹-프록시를-만들어주는-팩토리-빈" class="headerlink" title="다이내믹 프록시를 만들어주는 팩토리 빈"></a>다이내믹 프록시를 만들어주는 팩토리 빈</h4><p>Proxy의 newPRoxyInstance() 메소드를 통해서만 생성이 가능한 다이내믹 프록시 오브젝트는 일반적인 방법으로는 스프링의 빈을 등록할 수 없다. 대신 팩토리 빈을 사용하면 다이내믹 프록시 오브젝트를 스프링의 빈으로 만들어줄 수가 있다. 팩토리 빈의 getObject() 메소드에 다이내믹 프록시 오브젝트를 만들어주는 코드를 넣으면 되게 때문이다.</p><p><img src="/images/post/2018-04-15/dynamic-proxy-with-factorybean.png" alt="dynamic-proxy-with-factorybean"></p><p>스프링 빈에는 팩토리 빈과 UserServiceImpl만 빈으로 등록한다. 팩토리 빈은 다이내믹 프록시가 위임할 타깃 오브젝트인 UserServiceImpl에 대한 레퍼런스를 프로퍼티를 통해 DI 받아둬야 한다. 다이내믹 프록시와 함께 생성할 TransactionHandler에게 타깃 오브젝트를 전달해줘야 하기 때문이다. 그 외에도 다이내믹 프록시나 TransactionHandler를 만들 때 필요한 정보는 팩토리 빈의 프로퍼티로 설정해뒀다가 다이내믹 프록시를 만들면서 전달해줘야 한다.</p><h3 id="프록시-팩토리-빈-방식의-장점과-한계"><a href="#프록시-팩토리-빈-방식의-장점과-한계" class="headerlink" title="프록시 팩토리 빈 방식의 장점과 한계"></a>프록시 팩토리 빈 방식의 장점과 한계</h3><p>다이내믹 프록시를 생성해주는 팩토리 빈을 사용하는 방법은 여러 가지 장점이 있다. 한번 부가기능을 가진 프록시를 생성하는 팩토리 빈을 만들어두면 타깃의 타입에 상관없이 재사용할 수 있기 때문이다.</p><h4 id="프록시-팩토리-빈-방식의-장점"><a href="#프록시-팩토리-빈-방식의-장점" class="headerlink" title="프록시 팩토리 빈 방식의 장점"></a>프록시 팩토리 빈 방식의 장점</h4><p>다이내믹 프록시를 이용하면 타깃 인터페이스를 구현하는클래스를 일일이 만드는 번거로움을 제거할 수 있다. 하나의 핸들러 메소드를 구현하는 것만으로도 수많은 메소드에 부가기능을 부여해줄 수 있으니 부가기능 코드의 중복 문제도 사라진다. 다이내믹 프록시에 팩토리 빈을 이용한 DI까지 더해주면 번거로운 다이내믹 프록시 생성 코드도 제거할 수 있다. DI 설정만으로 다양한 타깃 오브젝트에 적용도 가능하다.</p><h4 id="프록시-팩토리-빈의-한계"><a href="#프록시-팩토리-빈의-한계" class="headerlink" title="프록시 팩토리 빈의 한계"></a>프록시 팩토리 빈의 한계</h4><p>프록시를 통해 타깃에 부가기능을 제공하는 것은 메소드 단위로 일어나는 일이다. 하나의 크래스 안에 존재하는 여러 개의 메소드에 부가기능을 한 번에 제공하는 건 어렵지 않게 가능했다. 하지만 한 번에 여러 개의 크래스에 공통적인 부가기능을 제공하는 일은 지금까지 살펴본 방법으로는 불가능하다.</p><p>하나의 타깃에 여러 개의 부가기능을 적용하려고 할 때도 문제다. 프록시 팩토리 빈 설정이 부가기능의 개수만큼 따라 붙어야 한다.</p><h2 id="스프링의-프록시-팩토리-빈"><a href="#스프링의-프록시-팩토리-빈" class="headerlink" title="스프링의 프록시 팩토리 빈"></a>스프링의 프록시 팩토리 빈</h2><h3 id="proxyfactorybean"><a href="#ProxyFactoryBean" class="headerlink" title="ProxyFactoryBean"></a>ProxyFactoryBean</h3><p>자바에는 JDK에서 제공하는 다이내믹 프록시 외에도 편리하게 프록시를 만들 수 있도록 지원해주는 다양한 기술이 존재한다. 따라서 <strong>스프링은 일관된 방법으로 프록시를 만들 수 있게 도와주는 추상 레이어를 제공한다.</strong> 생성된 프록시는 스프링의 빈으로 등록돼야 한다. 스프링은 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈을 제공해준다.</p><p><strong>스프링의 <code>ProxyFactoryBean</code>은 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈이다.</strong> ProxyFactoryBean은 순수하게 프록시를 생성하는 작업만을 담당하고 프록시를 통해 제공해줄 부가기능은 별도의 빈에 둘 수 있다.</p><p>ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다. MethodInterceptor는 InvocationHandler와 비슷하지만 한 가지 다른 점이 있다. InvocationHandler의 invoke() 메소드는 타깃 오브젝트에 대한 정보를 제공하지 않는다. 따라서 타깃은 InvocationHandler를 구현한 크래스가 직접 알고 있어야 한다. 반면에 MethodInterceptor의 invoke() 메소드는 ProxyFactoryBean으로부터 타깃 오브젝트에 대한 정보까지도 함께 제공받는다. 그 차이 덕분에 <strong>MethodInterceptor는 타깃 오브젝트에 상관없이 독립적으로 만들어질 수 있다. 따라서 MethodInterceptor 오브젝트는 타깃이 다른 여러 프록시에서 함께 사용할 수 있고, 싱글톤 빈으로 등록 가능하다.</strong></p><h4 id="어드바이스-타깃이-필요-없는-순수한-부가기능"><a href="#어드바이스-타깃이-필요-없는-순수한-부가기능" class="headerlink" title="어드바이스: 타깃이 필요 없는 순수한 부가기능"></a>어드바이스: 타깃이 필요 없는 순수한 부가기능</h4><p>MethodInvocation은 일종의 콜백 오브젝트로, proceed() 메소드를 실행하면 타깃 오브젝트의 메소드를 내부적으로 실행해주는 기능이 있다. ProxyFactoryBean은 작은 단위의 템플릿/콜백 구조를 응용해서 적용했기 때문에 템플릿 역할을 하는 MethodInvocation을 싱글톤으로 두고 공유할 수 있다.</p><p><strong>MethodInterceptor처럼 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트를 스프링에서는 <code>어드바이스(advice)</code>라고 부른다.</strong></p><p>ProxyFactoryBean은 기본적으로 JDK가 제공하는 다이내믹 프록시를 만들어준다. 경우에 따라서는 CGLib이라고 하는 오픈소스 바이트코드 생성 프레임워크를 이용해 프록시를 만들기도 한다.</p><p>어드바이스는 타깃 오브젝트에 종속되지 않는 순수한 부가기능을 담은 오브젝트라는 사실을 잘 기억해두자.</p><h4 id="포인트컷-부가기능-적용-대상-메소드-선정-방법"><a href="#포인트컷-부가기능-적용-대상-메소드-선정-방법" class="headerlink" title="포인트컷: 부가기능 적용 대상 메소드 선정 방법"></a>포인트컷: 부가기능 적용 대상 메소드 선정 방법</h4><p>MethodInterceptor 오브젝트는 여러 프록시가 공유해서 사용할 수 있다. 그러기 위해서 MethodInterceptor 오브젝트는 타깃 정보를 갖고 있지 않도록 만들었다. 그 덕분에 MethodInterceptor를 스프링의 싱글톤 빈으로 등록할 수 있었다. 그런데 여기에다 트랜잭션 적용 대상 메소드 이름 패턴을 넣어주는 것은 곤란하다. 트랜잭션 적용 메소드 패턴은 프록시마다 다를 수 있기 때문에 여러 프록시가 공유하는 MethodInterceptor에 특정 프록시에만 적용되는 패턴을 넣으면 문제가 된다.</p><p><img src="/images/post/2018-04-15/comparison.png" alt="comparison"></p><p><strong><code>InvocationHandler</code>는 타깃과 메소드 선정 알고리즘 코드에 의존하고 있지만, 스프링의 <code>ProxyFactoryBean</code> 방식은 두 가지 확장 기능인 부가기능(Advice)과 메소드 선정 알고리즘(Pointcut)을 활용하는 유연한 구조를 제공한다.</strong></p><p>스프링은 부가기능을 제공하는 오브젝트를 <strong>어드바이스</strong>라고 부르고, 메소드 선정 알고리즘을 담은 오브젝트를 <strong>포인트컷</strong>이라고 부른다. 어드바이스와 포인트컷은 모두 프록시에 DI로 주입돼서 사용된다. 두 가지 모두 여러 프록시에서 공유가 가능하도록 만들어지기 때문에 스프링의 싱글톤 빈으로 등록이 가능하다.</p><p>프록시는 클라이언트로부터 요청을 받으면 먼저 포인트컷에게 부가기능을 부여할 메소드인지를 확인해달라고 요청한다. 포인트컷은 Pointcut 인터페이스를 구현해서 만들면 된다. 프록시는 포인트컷으로부터 부가기능을 적용할 대상 메소드인지 확인받으면, MethodInterceptor 타입의 어드바이스를 호출한다. 어드바이스는 JDK의 다이내믹 프록시의 InvocationHandler와 달리 직접 타깃을 호출하지 않는다.</p><p>어드바이스가 일종의 템플릿이 되고 타깃을 호출하는 기능을 갖고 있는 MethodInvocation 오브젝트가 콜백이 되는 것이다. 템플릿은 한 번 만들면 재사용이 가능하고 여러 빈이 공유해서 사용할 수 있듯이, 어드바이스도 독립적인 싱글톤 빈으로 등록하고 DI를 주입해서 여러 프록시가 사용하도록 만들 수 있다.</p><p><strong>프록시로부터 어드바이스와 포인트컷을 독립시키고 DI를 사용하게 한 것은 전형적인 전략 패턴 구조다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProxyFactoryBean pfBean = <span class="keyword">new</span> ProxyFactoryBean();</span><br><span class="line">    pfBean.setTarget(<span class="keyword">new</span> HelloTarget());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 메소드 이름을 비교해서 대상을 선정하는 알고리즘을 제공하는 포인트컷 생성</span></span><br><span class="line">    NameMatchMethodPointcut pointcut = <span class="keyword">new</span> NameMatchMethodPointcut();</span><br><span class="line">    <span class="comment">// 이름 비교조건 설정. sayH로 시작하는 모든 메소드를 선택하게 한다.</span></span><br><span class="line">    pointcut.setMappedName(<span class="string">"syaH*"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 포인트컷과 어드바이스를 advisor로 묶어서 한 번에 추가</span></span><br><span class="line">    pfBean.addAdvisor(<span class="keyword">new</span> DefaultPointcutAdvisor(pointcut, <span class="keyword">new</span> UppercaseAdvice()));</span><br><span class="line">    </span><br><span class="line">    Hello proxiedHello = (Hello) pfBean.getObject();</span><br><span class="line">    </span><br><span class="line">    assertThat(proxiedHello.sayHello(<span class="string">"Toby"</span>), is(<span class="string">"HELLO TOBY"</span>));</span><br><span class="line">    assertThat(proxiedHello.sayHi(<span class="string">"Toby"</span>), is(<span class="string">"HI TOBY"</span>));</span><br><span class="line">assertThat(proxiedHello.sayThankYou(<span class="string">"Toby"</span>), is(<span class="string">"Thank You Toby"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProxyFactoryBean에는 여러 개의 어드바이스와 포인트컷이 추가될 수 있다. 포인트컷과 어드바이스를 따로 등록하면 어떤 어드바이스(부가 기능)에 대해  어떤 포인트컷(메소드 선정)을 적용할지 애매해지기 때문이다. 그래서 이 둘을 Advisor 타입의 오브젝트에 담아서 조합을 만들어 등록하는 것이다. 여러 개의 어드바이스가 등록되더라도 각각 다른 포인트컷과 조합될 수 있기 때문에 각기 다른 메소드 선정 방식을 적용할 수 있다. <strong>이렇게 어드바이스와 포인트 컷을 묶은 오브젝트를 인터페이스 이름을 따서 <code>어드바이저</code>라고 부른다.</strong></p><blockquote><p>어드바이저 = 포인트컷(메소드 선정 알고리즘) + 어드바이스(부가기능)</p></blockquote><h4 id="어드바이스와-포인트컷의-재사용"><a href="#어드바이스와-포인트컷의-재사용" class="headerlink" title="어드바이스와 포인트컷의 재사용"></a>어드바이스와 포인트컷의 재사용</h4><p>ProxyFactoryBean은 스프링의 DI와 템플릿/콜백 패턴, 서비스 추상화 등의 기법이 모두 적용된 것이다. 그 덕분에 독립적이며, 여러 프록시가 공유할 수 있는 어드바이스와 포인트컷으로 확장 기능을 분리할 수 있었다.</p><p><img src="/images/post/2018-04-15/proxyfactorybean_advice_pointcut.png" alt="proxyfactorybean_advice_pointcut"></p><h2 id="스프링-aop"><a href="#스프링-AOP" class="headerlink" title="스프링 AOP"></a>스프링 AOP</h2><h3 id="자동-프록시-생성"><a href="#자동-프록시-생성" class="headerlink" title="자동 프록시 생성"></a>자동 프록시 생성</h3><h4 id="중복-문제의-접근-방법"><a href="#중복-문제의-접근-방법" class="headerlink" title="중복 문제의 접근 방법"></a>중복 문제의 접근 방법</h4><p>JDK의 다이내믹 프록시는 특정 인터페이스를 구현한 오브젝트에 대해서 프록시 역할을 해주는 클래스를 런타임 시 내부적으로 만들어준다. 런타임 시에 만들어져 사용되기 때문에 클래스 소스가 따로 남지 않을 뿐이지 타깃 인터페이스의 모든 메소드를 구현하는 클래스가 분명히 만들어진다.</p><p>변하지 않는 타깃으로의 위임과 부가기능 적용 여부 판단이라는 부분은 코드 생성기법을 이용하는 다이내믹 프록시 기술에 맡기고, 변하는 부가기능 코드는 별도로 만들어서 다이내믹 프록시 생성 팩토리에 DI로 제공하는 방법을 사용한 것이다. 좀 독특하긴 하지만 변하는 로직과 변하지 않는 기계적인 코드를 잘 분리해낸 것이다.</p><p>반복적인 프록시의 메소드 구현은 코드 자동생성 기법을 이용해 해결했다면 반복적인 ProxyFactoryBean 설정 문제는 설정 자동등록 기법으로 해결할 수 없을까?</p><p>하지만 지금까지 살펴본 방법에서는 한 번에 여러 개의 빈에 프록시를 적용할 만한 방법은 없었다.</p><h4 id="빈-후처리기를-이용한-자동-프록시-생성기"><a href="#빈-후처리기를-이용한-자동-프록시-생성기" class="headerlink" title="빈 후처리기를 이용한 자동 프록시 생성기"></a>빈 후처리기를 이용한 자동 프록시 생성기</h4><p>스프링은 컨테이너로서 제공하는 기능 중에서 변하지 않는 핵심적인 부분외에는 대부분 확장할 수 있도록 확장 포인트를 제공해준다.</p><p><strong>그 중에서 관심을 가질 만한 확장 포인트는 BeanPostProcessor 인터페이스를 구현해서 만든 빈 후처리기다.</strong> 빈 후처리기는 이름 그대로 스프링 빈 오브젝트로 만들어지고 난 후에, 빈 오브젝트를 다시 가공할 수 있게 해준다.</p><p>스프링은 빈 후처리기 중의 하나로 DefaultAdvisorAutoProxyCreator를 제공한다. <strong>DefaultAdvisorAutoProxyCreator는 어드바이저를 이용한 자동 프록시 생성기다.</strong> 빈 후처리기를 스프링에 적용하는 방법은 간단하다. 빈 후처리기 자체를 빈으로 등록하는 것이다. 스프링은 빈 후처리기가 빈으로 등록되어 있으면 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 후처리 작업을 요청한다. 빈 후처리기는 빈 오브젝트의 프로퍼티를 강제로 수정할 수도 있고 별도의 초기화 작업을 수행할 수도 있다. 심지어는 만들어진 빈오브젝트 자체를 바꿔치기할 수도 있다. 따라서 스프링이 설정을 참고해서 만든 오브젝트가 아닌 다른 오브젝트를 빈으로 등록시키는 것이 가능하다.</p><p>이를 잘 활용하면 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록할 수도 있다.</p><p><strong>DefaultAdvisorAutoProxyCreator 빈 후처리기가 등록되어 있으면 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.</strong> DefaultAdvisorAutoProxyCreator는 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인한다. 프록시 적용 대상이면 그때는 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 하고, 만들어진 프록시에 어드바이저를 연결해준다. 빈 후처리기는 프록시가 생성되면 원래 컨테이너가 전달해준 빈 오브젝트 대신 프록시 오브젝트를 컨테이너에게 돌려준다. 컨테이너는 최종적으로 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용한다.</p><p><strong>적용할 빈을 선정하는 로직이 추가된 포인트컷이 담긴 어드바이저를 등록하고 빈 후처리기를 사용하면 일일이 ProxyFactoryBean 빈을 등록하지 않아도 타깃 오브젝트에 자동으로 프록시가 적용되게 할 수 있다.</strong></p><h4 id="확장된-포인트컷"><a href="#확장된-포인트컷" class="headerlink" title="확장된 포인트컷"></a>확장된 포인트컷</h4><p><strong>포인트컷은 클래스 필터와 메소드 매처 두 가지를 돌려주는 메소드를 갖고 있다. 실제 포인트컷의 선별 로직은 이 두가지 타입의 오브젝트에 담겨 있다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line">    <span class="function">ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>; <span class="comment">// 프록시를 적용할 클래스인지 확인해준다.</span></span><br><span class="line">    <span class="function">MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span></span>; <span class="comment">// 어드바이스를 적용할 메소드인지 확인해준다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>만약 Pointcut 선정 기능을 모두 적용한다면 먼저 프록시를 적용할 클래스인지 판단하고 나서, 적용 대상 클래스인 경우에는 어드바이스를 적용할 메소드인지 확인하는 식으로 동작한다.</strong> 결국 이 두 가지 조건이 모두 충족되는 타깃의 메소드에 어드바이스가 적용되는 것이다.</p><p>모든 빈에 대해 프록시 자동 적용 대상을 선별해야 하는 빈 후처리기인 DefaultAdvisorAutoProxyCreator는 클래스와 메소드 선정 알고리즘을 모두 갖고 있는 포인트컷이 필요하다. 정확히는 그런 포인트컷과 어드바이스가 결합되어 있는 어드바이저가 등록되어 있어야 한다.</p><h3 id="defaultadvisorautoproxycreator의-적용"><a href="#DefaultAdvisorAutoProxyCreator의-적용" class="headerlink" title="DefaultAdvisorAutoProxyCreator의 적용"></a>DefaultAdvisorAutoProxyCreator의 적용</h3><h4 id="클래스-필터를-적용할-포인트컷-작성"><a href="#클래스-필터를-적용할-포인트컷-작성" class="headerlink" title="클래스 필터를 적용할 포인트컷 작성"></a>클래스 필터를 적용할 포인트컷 작성</h4><p>메소드 이름만 비교하던 포인트컷인 NameMatchMethodPointcut을 상속해서 프로퍼티로 주어진 이름 패턴을 가지고 클래스 이름을 비교하는 ClassFilter를 추가하도록 만든다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> springbook.learningtest.jdk.proxy;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameMatchClassMethodPointcut</span> <span class="keyword">extends</span> <span class="title">NameMatchMethodPointcut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMappedClassName</span><span class="params">(String mappedClassName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 모든 클래스를 다 허용하던 디폴트 클래스 필터를 프로퍼티로 받은 클래스 이름을 이용해서 필터를 만들어 덮어씌운다.</span></span><br><span class="line">        <span class="keyword">this</span>.setClassFilter(<span class="keyword">new</span> SimpleClassFilter(mappedClassName));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> Class SimpleClassFilter implements ClassFilter &#123;</span><br><span class="line">        String mappedName;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SimpleClassFilter</span><span class="params">(String mappedName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mappedName = mappedName;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> PatternMatchUtils.simpleMatch(mappedName, clazz.getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="어드바이저를-이용하는-자동-프록시-생성기-등록"><a href="#어드바이저를-이용하는-자동-프록시-생성기-등록" class="headerlink" title="어드바이저를 이용하는 자동 프록시 생성기 등록"></a>어드바이저를 이용하는 자동 프록시 생성기 등록</h4><p>자동 프록시 생성기인 DefaultAdvisorAutoProxyCreator는 등록된 빈 중에서 Advisor 인터페이스를 구현한 것을 모두 찾는다. 그리고 생성되는 모든 빈에 대해 어드바이저의 포인트컷을 적용해보면서 프록시 적용 대상을 선정한다. 빈 클래스가 프록시 선정 대상이라면 프록시를 만들어서 원래 빈 오브젝트와 바꿔치기한다. 원래 빈 오브젝트는 프록시 뒤에 연결돼서 프록시를 통해서만 접근 가능하게 바뀌며, 타깃 빈에 의존한다고 정의한 다른 빈들은 등록시 프록시 오브젝트를 대신 DI 받게 된다. DefaultAdvisorAutoProxyCreator 등록은 다음 한 줄과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span> /&gt;</span><br></pre></td></tr></table></figure><p>다른 빈에서 참조되거나 코드에서 빈 이름으로 조회될 필요가 없는 빈이라면 아이디를 등록하지 않아도 무방하다.</p><h3 id="포인트컷-표현식을-이용한-포인트컷"><a href="#포인트컷-표현식을-이용한-포인트컷" class="headerlink" title="포인트컷 표현식을 이용한 포인트컷"></a>포인트컷 표현식을 이용한 포인트컷</h3><p><strong>스프링은 아주 간단하고 효과적인 방법으로 포인트컷의 클래스와 메소드를 선정하는 알고리즘을 작성할 수 있는 방법을 제공한다. 정규식이나 JSP의 EL과 비슷한 일종의 표현식 언어를 사용해서 포인트컷을 작성할 수 있도록 하는 방법이다. 그래서 이것을 <code>포인트컷 표현식</code>이라고 부른다.</strong></p><h4 id="포인트컷-표현식"><a href="#포인트컷-표현식" class="headerlink" title="포인트컷 표현식"></a>포인트컷 표현식</h4><p>포인트컷 표현식을 지원하는 포인트컷을 적용하려면 AspectJExpressionPointcut 클래스를 사용하면 된다. Pointcut 인터페이스를 구현해야 하는 스프링의 포인트컷은 클래스 선정을 위한 클래스 필터와 메소드 선정을 위한 메소드 매처 두 가지를 각각 제공해야 한다.</p><p>하지만 AspectJExpressionPointcut은 클래스와 메소드의 선정 알고리즘을 포인트컷 표현식을 이용해 한 번에 지정할 수 있게 해준다. 포인트컷 표현식은 자바의 RegEx 클래스가 지원하는 정규식처럼 간단한 문자열로 복잡한 선정조건을 쉽게 만들어낼 수 있는 강력한 표현식을 지원한다. 사실 스프링이 사용하는 포인트컷 표현식은 AspectJ라는 유명한 프로엠워크에서 제공하는 것을 가져와 일부 문법을 확장해서 사용하는 것이다.</p><h4 id="포인트컷-표현식을-이용하는-포인트컷-적용"><a href="#포인트컷-표현식을-이용하는-포인트컷-적용" class="headerlink" title="포인트컷 표현식을 이용하는 포인트컷 적용"></a>포인트컷 표현식을 이용하는 포인트컷 적용</h4><p>포인트컷 표현식은 메소드의 시그니처를 비교하는 방식인 execution() 외에도 몇 가지 표현식 스타일을 갖고 있다. 대표적으로 스프링에서 사용될 때 빈의 이름으로 비교하는 bean()이 있다.</p><p>또 <strong>특정 애노테이션이 타입, 메소드, 파라미터에 적용되어 있는 것을 보고 메소드를 선정하게 하는 포인트컷도 만들 수 있다. 애노테이션만 부여해놓고, 포인트컷을 통해 자동으로 선정해서, 부가기능을 제공하게 해주는 방식은 스프링 내에서도 애용되는 편리한 방법이다.</strong></p><p>클래스 이름은 ServiceImpl로 끝나고 메소드 일므은 upgrade로 시작하는 모든 클래스에 적용되도록 하는 표현식을 만들고 이를 적용한 빈 설정은 다음과 같다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"transactionPointcut"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.aop.aspectj.AspectJExpressionPointcut"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"expression"</span> value<span class="string">"execution(* * .. *ServiceImpl.upgrade*(..))"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="aop란-무엇인가"><a href="#AOP란-무엇인가" class="headerlink" title="AOP란 무엇인가?"></a>AOP란 무엇인가?</h3><h4 id="aop-애스펙트-지향-프로그래밍"><a href="#AOP-애스펙트-지향-프로그래밍" class="headerlink" title="AOP: 애스펙트 지향 프로그래밍"></a>AOP: 애스펙트 지향 프로그래밍</h4><p>부가기능 모듈화 작업은 기존의 객체지향 설계 패러다임과는 구분되는 새로운 특성이 있다고 생각했다. 그래서 이런 부가기능 모듈을 객체지향 기술에서는 주로 사용하는 오브젝트와는 다르게 특별한 이름으로 부르기 시작했다. 그것이 바로 <strong>애스펙트(aspect</strong>)다. <strong>애스펙트란 그 자체로 애플리케이션의 핵심기능을 담고 있지는 않지만, 애플리케이션을 구성하는 중요한 한 가지 요소이고, 핵심기능에 부가되어 의미를 갖는 특별한 모듈을 가리킨다.</strong></p><p>애스펙트는 부가될 기능을 정의한 코드인 어드바이스와, 어드바이스를 어디에 적용할지를 결정하는 포인트컷을 함께 갖고 있다.</p><p>독립된 측면에 존재하는 애스팩트로 분리한 덕에 핵심기능은 순수하게 그 기능을 담은 코드로만 존재하고 독립적으로 살펴볼 수 있도록 구분된 면에 존재하게 된 것이다.</p><p>이렇게 <strong>애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법을 애스펙트 지향 프로그래밍(Aspect Oriented Programming) 또는 약자로 AOP라고 부른다.</strong></p><p>AOP는 OOP를 돕는 보조적인 기술이지 OOP를 완전히 대체하는 새로운 개념은 아니다. AOP는 애스펙트를 분리함으로써 핵심기능을 설계하고 구현할 때 객체지향적인 가치를 지킬 수 있도록 도와주는 것이라고 보면 된다. AOP를 <strong>관점 지향 프로그래밍</strong>이라고도 한다.</p><h3 id="aop-적용기술"><a href="#AOP-적용기술" class="headerlink" title="AOP 적용기술"></a>AOP 적용기술</h3><h4 id="바이트코드-생성과-조작을-통한-aop"><a href="#바이트코드-생성과-조작을-통한-AOP" class="headerlink" title="바이트코드 생성과 조작을 통한 AOP"></a>바이트코드 생성과 조작을 통한 AOP</h4><p>프록시 방식이 아닌 AOP도 있다. AOP 기술의 원조이자, 가장 강력한 AOP 프레임워크로 꼽히는 AspectJ는 프록시를 사용하지 않는 대표적인 AOP 기술이다. AspectJ는 스프링처럼 다이내믹 프록시 방식을 사용하지 않는다.</p><p>AspectJ는 프록시처럼 간접적인 방법이 아니라, 타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 직접적인 방법을 사용한다. 컴파일된 타깃의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 복잡한 방법을 사용한다.</p><p>AspectJ가 프록시 같은 방법이 있지만 컴파일된 클래스 파일 수정이나 바이트코드 조작과 같은 복잡한 방법을 사용하는 것에는 두 가지 이유가 있다.</p><ol><li>바이트코드를 조작해서 타깃 오브젝트를 직접 수정해버리면 스프링과 같은 DI 컨테이너의 도움을 받아서 자동 프록시 생성 방식을 사용하지 않아도 AOP를 적용할 수 있기 때문.</li><li>프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하기 때문. 바이트코드를 직접 조작해서 AOP를 적용하면 오브젝트의 생성, 필드 값이 조회와 조작, 스태틱 초기화 등의 다양한 작업에 부가기능을 부여해줄 수 있다.</li></ol><h2 id="트랜잭션-속성"><a href="#트랜잭션-속성" class="headerlink" title="트랜잭션 속성"></a>트랜잭션 속성</h2><p>트랜잭션이라고 모두 같은 방식으로 동작하는 것이 아니다. DefaultTransactionDefinition이 구현하고 있는 TransactionDefinition 인터페이스는 트랜잭션 동작방식에 영향을 줄 수 있는 4가지 속성을 정의하고 있다.</p><ul><li><strong>트랜잭션 전파</strong><br>트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식</li><li><strong>격리수준</strong><br>모든 DB 트랜잭션은 격리수준(isolation level)을 갖고 있다. 격리수준은 기본적으로 DB에 설정되어 있지만 JDBC 드라이버나 DataSource 등에서 재설정할 수 있고, 필요하다면 트랜잭션 단위로 격리수준을 조정할 수 있다.</li><li><strong>제한시간</strong><br>트랜잭션을 수행하는 제한시간(timeout)을 설정할 수 있다. DefaultTransactionDefinition의 기본 설정은 제한시간이 없다.</li><li><strong>읽기전용</strong><br>읽기전용(read only)으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있다. 또한 데이터 액세스 기술에 따라서 성능이 향상될 수도 있다.</li></ul><h3 id="포인트컷과-트랜잭션-속성의-적용-전략"><a href="#포인트컷과-트랜잭션-속성의-적용-전략" class="headerlink" title="포인트컷과 트랜잭션 속성의 적용 전략"></a>포인트컷과 트랜잭션 속성의 적용 전략</h3><h4 id="프록시-방식-aop는-같은-타깃-오브젝트-내의-메소드를-호출할-때는-적용되지-않는다"><a href="#프록시-방식-AOP는-같은-타깃-오브젝트-내의-메소드를-호출할-때는-적용되지-않는다" class="headerlink" title="프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다"></a>프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다</h4><p>이건 전략이라기보다는 주의사항이다. <strong>프록시 방식의 AOP에서는 프록시를 통한 부가 기능의 적용은 클라이언트로부터 호출이 일어날 때만 가능하다.</strong> 여기서 클라이언트는 인터페이스를 통해 타깃 오브젝트를 사용하는 다른 모든 오브젝트를 말한다. 반대로 타깃 오브젝트가 자기 자신의 메소드를 호출할 떄는 프록시를 통한 부가기능의 적용이 일어나지 않는다. 따라서 같은 오브젝트 안에서의 호출은 새로운 트랜잭션 속성을 부여하지 못한다는 사실을 의식하고 개발할 필요가 있다.</p><p>타깃 안에서의 호출에는 프록시가 적용되지 않는 문제를 해결할 수 있는 방법은 두 가지가 있다.</p><ol><li>스프링 API를 이용해 프록시 오브젝트에 대한 레퍼런스를 가져온 뒤에 같은 오브젝트의 메소드 호출도 프록시를 이용하도록 강제하는 방법(별로 추천되지 않음)</li><li>AspectJ와 같은 타깃의 바이트코드를 직접 조작하는 방식의 AOP 기술을 적용하는 방법</li></ol><h3 id="트랜잭션-속성-적용"><a href="#트랜잭션-속성-적용" class="headerlink" title="트랜잭션 속성 적용"></a>트랜잭션 속성 적용</h3><h4 id="트랜잭션-경계설정의-일원화"><a href="#트랜잭션-경계설정의-일원화" class="headerlink" title="트랜잭션 경계설정의 일원화"></a>트랜잭션 경계설정의 일원화</h4><p>트랜잭션 경계설정의 부가기능을 여러 계층에서 중구난방으로 적용하는 건 좋지 않다. 일바적으로 특정 계층의 경계를 트랜잭션 경계와 일치시키는 것이 바람직하다. 비즈니스 로직을 담고 있는 서비스 계층 오브젝트의 메소드가 트랜잭션 경계를 부여하기에 가장 적절한 대상이다.</p><h2 id="트랜잭션-지원-테스트"><a href="#트랜잭션-지원-테스트" class="headerlink" title="트랜잭션 지원 테스트"></a>트랜잭션 지원 테스트</h2><h3 id="선언적-트랜잭션과-트랜잭션-전파-속성"><a href="#선언적-트랜잭션과-트랜잭션-전파-속성" class="headerlink" title="선언적 트랜잭션과 트랜잭션 전파 속성"></a>선언적 트랜잭션과 트랜잭션 전파 속성</h3><p>AOP를 이용해 코드 외부에서 트랜잭션의 기능을 부여해주고 속성을 지정 할 수 있게 하는 방법을 <strong>선언적  트랜잭션</strong>이라고 한다. 반대로 TransactionTemplate이나 개별 데이터 기술의 트랜잭션 API를 사용해 직접 코드 안에서 사용하는 방법은 <strong>프로그램에 의한 트랜잭션</strong>이라고 한다. 스프링은 이 두 가지 방법을 모두 지원하고 있다. 물론 특별한 경우가 아니라면 선언적 방식의 트랜잭션을 사용하는 것이 바람직하다.</p><h3 id="트랜잭션-매니저와-트랜잭션-동기화"><a href="#트랜잭션-매니저와-트랜잭션-동기화" class="headerlink" title="트랜잭션 매니저와 트랜잭션 동기화"></a>트랜잭션 매니저와 트랜잭션 동기화</h3><p><strong>트랜잭션 추상화 기술의 핵심은 트랜잭션 매니저와 트랜잭션 동기화다. <code>PlatformTransactionManager</code> 인터페이스를 구현한 트랜잭션 매니저를 통해 구체적인 트랜잭션 기술의 종류에 상관없이 일관된 트랜잭션 제어가 가능했다. 또한 트랜잭션 동기화 기술이 있었기에 시작된 트랜잭션 정보를 저장소에 보관해뒀다가 DAO에서 공유할 수 있었다.</strong></p><p>트랜잭션 동기화 기술은 트랜잭션 전파를 위해서도 중요한 역할을 한다. 진행 중인 트랜잭션이 있는지 확인하고, 트랜잭션 전파 속성에 따라서 이에 참여할 수 있도록 만들어주는 것도 트랜잭션 동기화 기술 덕분이다.</p><p>JdbcTemplate과 같이 스프링이 제공하는 데이터 액세스 추상화를 적용한 DAO에도 동일한 영향을 미친다. JdbcTemplate은 트랜잭션이 시작된 것이 있으면 그 트랜잭션에 자동으로 참여하고, 없으면 트랜잭션 없이 자동커밋 모드로 JDBC 작업을 수행한다. 개념은 조금 다르지만 JdbcTemplate의 메소드 단위로 마치 트랜잭션 전파 속성이 REQUIRED인 것처럼 동작한다고 볼 수 있다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul><li>트랜잭션 경계설정 코드를 분리해서 별도의 클래스로 만들고 비즈니스 로직 클래스와 당일한 인터페이스를 구현하면 DI의 확장 기능을 이용해 클라이언트의 변경 없이도 깔끔하게 분리된 트랜잭션 부가기능을 만들 수 있다.</li><li>트랜잭션처럼 환경과 외부 리소스에 영향을 받는 코드를 분리하면 비즈니스 로직에만 충실한 테스트를 만들 수 있다.</li><li>목 오브젝트를 활용하면 의존관계 속에 있는 오브젝트도 손 쉽게 고립된 테스트로 만들 수 있다.</li><li>DI를 이용한 트랜잭션의 분리는 데코레이터 패턴과 프록시 패턴으로 이해될 수 있다.</li><li>번거로운 프록시 클래스 작성은 JDK의 다이내믹 프록시를 사용하면 간단하게 만들 수 있다.</li><li>다이내믹 프록시는 스태틱 팩토리 메소드를 사용하기 때문에 빈으로 등록하기 번거롭다. 따라서 팩토리 빈으로 만들어야 한다. 스프링은 자동 프록시 생성 기술에 대한 추상화 서비스를 제공하는 프록시 팩토리 빈을 제공한다.</li><li>프록시 팩토리 빈의 설정이 반복되는 문제를 해결하기 위해 자동 프록시 생성기와 포인트 컷을 활용할 수 있다. 자동 프록시 생성기는 부가기능이 담긴 어드바이스를 제공하는 프록시를 스프링 컨테이너 초기화 시점에 자동으로 만들어준다.</li><li>포인트컷은 AspectJ 포인트컷 표현식을 사용해서 작성하면 편리하다.</li><li>AOP는 OOP만으로는 모듈화하기 힘든 부가기능을 효과적으로 모듈화하도록 도와주는 기술이다.</li><li>스프링은 자주 사용되는 AOP 설정과 트랜잭션 속성을 지정하는데 사용할 수 있는 전용 태그를 제공한다.</li><li>AOP를 이용해 트랜잭션 속성을 지정하는 방법에는 포인트컷 표현식과 메소드 이름 패턴을 이용하는 방법과 타깃에 직접 부여하는 @Transactional 애노테이션을 사용하는 방법이 있다.</li><li>@Transactgional을 이용한 트랜잭션 속성을 테스트에 적용하면 손쉽게 DB를 사용하는 코드의 테스트를 만들 수 있다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p><a href="http://www.acornpub.co.kr/book/toby-spring3.1-vol1" target="_blank" rel="noopener">토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;aop&quot;&gt;&lt;a href=&quot;#AOP&quot; class=&quot;headerlink&quot; title=&quot;AOP&quot;&gt;&lt;/a&gt;AOP&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;AOP&lt;/code&gt;는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반기술중 하나다.&lt;
      
    
    </summary>
    
      <category term="Programming" scheme="https://jongmin92.github.io/categories/Programming/"/>
    
      <category term="Spring" scheme="https://jongmin92.github.io/categories/Programming/Spring/"/>
    
    
      <category term="Spring" scheme="https://jongmin92.github.io/tags/Spring/"/>
    
      <category term="Toby" scheme="https://jongmin92.github.io/tags/Toby/"/>
    
      <category term="AOP" scheme="https://jongmin92.github.io/tags/AOP/"/>
    
  </entry>
  
</feed>
